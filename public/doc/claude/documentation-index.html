<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentación StripeLabApp</title>
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="../assets/css/documentation_styles_claude.css">

    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Highlight.js CSS para resaltado de código -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="assets/img/favicon.png">
</head>
<body>
<div class="container-fluid">
    <div class="row">
        <!-- Barra de navegación lateral -->
        <div class="col-md-3 col-lg-2 d-md-block sidebar">
            <div class="position-sticky pt-3">
                <div class="sidebar-header">
                    <h5>StripeLabApp</h5>
                    <p>Documentación</p>
                </div>
                <ul class="nav flex-column">
                    <li class="nav-item">
                        <a class="nav-link active" href="#parte1">
                            <i class="fas fa-book me-2"></i>
                            Parte I: Entendiendo la Integración con Stripe API
                        </a>
                        <ul class="sub-nav">
                            <li><a href="#introduccion">1. Introducción a Stripe</a></li>
                            <li><a href="#webhooks">2. Webhooks de Stripe</a></li>
                            <li><a href="#eventos">3. Eventos de Stripe</a></li>
                            <li><a href="#stripecli">4. Stripe CLI</a></li>
                        </ul>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#parte2">
                            <i class="fas fa-code me-2"></i>
                            Parte II: Arquitectura de StripeLabApp
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#parte3">
                            <i class="fas fa-plug me-2"></i>
                            Parte III: Implementación y Casos de Uso
                        </a>
                    </li>
                </ul>
            </div>
        </div>

        <!-- Contenido principal -->
        <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
            <div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
                <h1>Documentación de StripeLabApp</h1>
            </div>

            <!-- Parte I -->
            <section id="parte1" class="mb-5">
                <h2>PARTE I: Entendiendo la Integración con Stripe API</h2>
                <p class="lead">
                    Esta sección cubre los conceptos fundamentales de Stripe y cómo se integran en StripeLabApp.
                </p>

                <!-- Sección 1 -->
                <section id="introduccion" class="mb-4">
                    <h3>1. Introducción a Stripe para Desarrolladores</h3>

                    <div id="que-es-stripe" class="subsection">

                        <p>
                            Stripe es una plataforma tecnológica de pagos que permite a empresas de todos los tamaños aceptar pagos y gestionar sus negocios en línea. A diferencia de otras soluciones de pago, Stripe está diseñado específicamente para desarrolladores, ofreciendo:
                        </p>
                        <ul>
                            <li><strong>APIs robustas y bien documentadas</strong> que facilitan la integración.</li>
                            <li><strong>Soporte para múltiples métodos de pago</strong> </li>
                            <li><strong>Herramientas de seguridad avanzadas</strong> con cumplimiento PCI DSS nivel 1.</li>
                            <li><strong>Gestión completa de suscripciones</strong> y modelos de negocio recurrentes.</li>
                            <li><strong>Detección de fraudes</strong> mediante Stripe Radar.</li>
                            <li><strong>Panel de control intuitivo</strong> para monitoreo y gestión de transacciones.</li>
                        </ul>
                        <p>
                            Para desarrolladores, Stripe proporciona bibliotecas cliente en los principales lenguajes de programación, webhooks para integraciones en tiempo real, y entornos de prueba completos que facilitan el desarrollo sin riesgos.
                        </p>
                    </div>

                    <div id="conceptos-clave" class="subsection">
                        <h4>1.2. Conceptos Clave de Stripe </h4>
                        <p>
                            Stripe está estructurado en torno a <strong>objetos</strong> que representan diferentes aspectos del proceso de pago. Entender estos objetos es crucial para trabajar eficientemente con la API:
                        </p>

                        <div class="card mb-3">
                            <div class="card-header">
                                <strong>Customers (<code>cus_...</code>)</strong>
                            </div>
                            <div class="card-body">
                                <p>
                                    Representan a los clientes de tu negocio. Los objetos Customer almacenan información de contacto, métodos de pago y metadatos personalizados. Son especialmente útiles para transacciones recurrentes y análisis de clientes.
                                </p>
                            </div>
                        </div>

                        <div class="card mb-3">
                            <div class="card-header">
                                <strong>PaymentIntents (<code>pi_...</code>)</strong>
                            </div>
                            <div class="card-body">
                                <p>
                                    Representan el intento de cobrar a un cliente. Gestionan todo el flujo de pago, incluyendo la autenticación 3D Secure y los reintentos automatizados. Es el objeto central para procesar pagos únicos de forma segura y cumpliendo con SCA (Strong Customer Authentication).
                                </p>
                            </div>
                        </div>

                        <div class="card mb-3">
                            <div class="card-header">
                                <strong>SetupIntents (<code>seti_...</code>)</strong>
                            </div>
                            <div class="card-body">
                                <p>
                                    Similar a PaymentIntents, pero diseñado para configurar métodos de pago para su uso futuro sin realizar un cargo inmediato. Ideal para suscripciones o cuando necesitas autorizar una tarjeta antes de cobrar.
                                </p>
                            </div>
                        </div>

                        <div class="card mb-3">
                            <div class="card-header">
                                <strong>Charges (<code>ch_...</code>)</strong>
                            </div>

                            <div class="card-body">
                                <p>
                                    Representan un cargo a una tarjeta u otra fuente de pago. Generalmente, es mejor usar PaymentIntents que interactuar directamente con Charges. En la API moderna de Stripe, los Charges se crean automáticamente a través de PaymentIntents.
                                </p>
                            </div>

                        </div>

                        <div class="card mb-3">
                            <div class="card-header">
                                <strong>Invoices (<code>in_...</code>)</strong>
                            </div>
                            <div class="card-body">
                                <p>
                                    Documentos que detallan los importes adeudados por un cliente. Las facturas pueden generarse manual o automáticamente (para suscripciones). Stripe puede enviar facturas por correo electrónico, intentar cobrarlas automáticamente, y seguimiento de pagos.
                                </p>
                            </div>
                        </div>

                        <div class="card mb-3">
                            <div class="card-header">
                                <strong>Subscriptions (<code>sub_...</code>)</strong>
                            </div>
                            <div class="card-body">
                                <p>
                                    Representan pagos recurrentes a intervalos regulares. Las suscripciones están vinculadas a un Customer y a un Price, y gestionan automáticamente la facturación recurrente, los ciclos de facturación, las actualizaciones/degradaciones, y los períodos de prueba.
                                </p>
                            </div>
                        </div>

                        <div class="card mb-3">
                            <div class="card-header">
                                <strong>Products y Prices (<code>prod_...</code>, <code>price_...</code>, <code>lookup_key</code>)</strong>
                            </div>
                            <div class="card-body">
                                <p>
                                    Los Products representan los bienes o servicios que ofreces. Los Prices definen cuánto y con qué frecuencia se cobra por un Product específico. Un producto puede tener múltiples precios (por ejemplo, mensual vs. anual). El <code>lookup_key</code> permite identificar fácilmente un Price específico en tu código.
                                </p>
                            </div>
                        </div>

                        <div class="card mb-3">
                            <div class="card-header">
                                <strong>Checkout Sessions (<code>cs_...</code>)</strong>
                            </div>
                            <div class="card-body">
                                <p>
                                    Representan una instancia de la página de pago alojada por Stripe (Stripe Checkout). Proporcionan una experiencia de pago optimizada sin necesidad de crear formularios personalizados. Las Checkout Sessions pueden configurarse para pagos únicos o suscripciones.
                                </p>
                            </div>
                        </div>

                        <div class="card mb-3">
                            <div class="card-header">
                                <strong>Events (<code>evt_...</code>)</strong>
                            </div>
                            <div class="card-body">
                                <p>
                                    Notificaciones que Stripe envía cuando ocurre algo en tu cuenta. Los eventos son fundamentales para crear integraciones asíncronas mediante webhooks. Cada tipo de evento tiene un formato específico y contiene datos sobre el objeto afectado.
                                </p>
                            </div>
                        </div>
                    </div>

                    <div id="claves-api" class="subsection">
                        <h4>1.3. Claves API (Publicable y Secreta)</h4>
                        <p>
                            Stripe utiliza un sistema de autenticación basado en claves API para identificar quién está realizando solicitudes. Existen dos tipos principales de claves:
                        </p>

                        <div class="row g-4 mb-3">
                            <div class="col-md-6">
                                <div class="card h-100">
                                    <div class="card-header bg-success text-white">
                                        <strong>Clave Publicable (pk_...)</strong>
                                    </div>
                                    <div class="card-body">
                                        <p>
                                            <strong>Uso:</strong> En el Fronted.
                                        </p>
                                        <p>
                                            <strong>Propósito:</strong> Identifica tu cuenta Stripe pero no permite acciones sensibles. Se utiliza principalmente con Stripe.js para recopilar información de pago de forma segura.
                                        </p>
                                        <div class="alert alert-success">
                                            <i class="fas fa-info-circle"></i> Segura para exponer en el código del navegador.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="col-md-6">
                                <div class="card h-100">
                                    <div class="card-header bg-danger text-white">
                                        <strong>Clave Secreta (sk_...)</strong>
                                    </div>
                                    <div class="card-body">
                                        <p>
                                            <strong>Uso:</strong> Exclusivamente en el servidor.
                                        </p>
                                        <p>
                                            <strong>Propósito:</strong> Otorga acceso completo a tu cuenta de Stripe. Permite crear cargos, gestionar clientes, acceder a datos sensibles, y realizar cualquier operación con la API.
                                        </p>
                                        <div class="alert alert-danger">
                                            <i class="fas fa-exclamation-triangle"></i> Nunca debe ser expuesta al frontend o en repositorios públicos.
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <p>
                            Ambos tipos de claves tienen versiones para entorno de prueba (prefijo <code>pk_test_</code> y <code>sk_test_</code>) y producción (prefijo <code>pk_live_</code> y <code>sk_live_</code>). Las claves de prueba permiten simular todas las funcionalidades sin procesar pagos reales.
                        </p>

                        <div class="alert alert-info">
                            <i class="fas fa-lightbulb"></i> <strong>Buena práctica:</strong> Almacena las claves secretas en variables de entorno o en un sistema seguro de gestión de secretos, nunca en archivos de configuración que puedan ser comprometidos.
                        </div>
                    </div>
                </section>

                <!-- Sección 2 -->
                <section id="webhooks" class="mb-4">
                    <h3>2. Webhooks de Stripe</h3>

                    <div id="que-son-webhooks" class="subsection">
                        <h4>2.1. ¿Qué son los Webhooks y por qué son cruciales?</h4>
                        <p>
                            Los webhooks son notificaciones <strong>HTTP POST que Stripe envía a tu servidor cuando ocurren eventos</strong> en tu cuenta. Funcionan como un sistema de "notificaciones push" para tu aplicación, permitiendo la comunicación asíncrona entre Stripe y tu backend.
                        </p>

                        <div class="row mb-4">
                            <div class="col-md-6">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <strong>¿Por qué son cruciales los webhooks?</strong>
                                    </div>
                                    <div class="card-body">
                                        <ul>
                                            <li><strong>Procesamiento asíncrono:</strong> Muchas operaciones de pago no son instantáneas (como pagos con confirmación diferida, disputas o reembolsos).</li>
                                            <li><strong>Fiabilidad:</strong> Garantizan que tu aplicación reciba actualizaciones incluso si el usuario cierra el navegador o pierde conexión.</li>
                                            <li><strong>Actualizaciones en tiempo real:</strong> Permiten que tu aplicación reaccione inmediatamente a cambios en el estado de pagos o suscripciones.</li>
                                            <li><strong>Gestión de errores:</strong> Notifican sobre fallos en los pagos, permitiendo acciones correctivas.</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>

                            <div class="col-md-6">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <strong>Casos de uso esenciales</strong>
                                    </div>
                                    <div class="card-body">
                                        <ul>
                                            <li>Actualizar el estado de la suscripción de un cliente cuando se procesa un pago recurrente.</li>
                                            <li>Enviar un correo electrónico de confirmación cuando un pago se completa correctamente.</li>
                                            <li>Activar acceso a un servicio cuando se confirma un pago.</li>
                                            <li>Detectar y gestionar pagos fallidos o tarjetas caducadas.</li>
                                            <li>Registrar eventos financieros en tu base de datos para conciliación.</li>
                                            <li>Reaccionar ante disputas o reembolsos.</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <p>
                            En StripeLabApp, los webhooks son el mecanismo principal para mantener sincronizados nuestros registros con los eventos de pago, haciendo posible una arquitectura orientada a eventos donde cada cambio en Stripe desencadena las actualizaciones correspondientes en nuestra aplicación.
                        </p>
                    </div>

                    <div id="seguridad-webhooks" class="subsection">
                        <h4>2.2. Seguridad de los Webhooks</h4>
                        <p>
                            Los webhooks son endpoints públicos que reciben información potencialmente sensible, por lo que su seguridad es crítica. Stripe proporciona dos mecanismos principales de seguridad:
                        </p>

                        <div class="card mb-4">
                            <div class="card-header">
                                <strong>Verificación de Firmas (Webhook Secret)</strong>
                            </div>
                            <div class="card-body">
                                <p>
                                    Cada webhook incluye una firma criptográfica que permite verificar que la solicitud realmente proviene de Stripe y no ha sido alterada.
                                </p>

                                <div class="alert alert-warning">
                                    <i class="fas fa-shield-alt"></i> <strong>Importante:</strong> La verificación de firma es esencial para prevenir ataques de suplantación donde un atacante podría enviar eventos falsos a tu endpoint.
                                </div>

                                <h5>Proceso de verificación:</h5>
                                <ol>
                                    <li>Stripe proporciona un "Webhook Secret" único para cada endpoint configurado.</li>
                                    <li>Cada evento enviado incluye un encabezado <code>Stripe-Signature</code> con una firma generada usando ese secreto.</li>
                                    <li>Tu servidor debe utilizar la biblioteca de Stripe para verificar esta firma antes de procesar el evento.</li>
                                </ol>

                                <div class="code-snippet">
                                        <pre><code class="language-php">
                                        // Ejemplo de verificación en PHP
                                        $endpoint_secret = 'whsec_...';
                                        $payload = @file_get_contents('php://input');
                                        $sig_header = $_SERVER['HTTP_STRIPE_SIGNATURE'];

                                        try {
                                            $event = \Stripe\Webhook::constructEvent(
                                                $payload, $sig_header, $endpoint_secret
                                            );
                                            // El evento es verificado, procésalo con seguridad
                                        } catch(\UnexpectedValueException $e) {
                                            // Firma inválida
                                            http_response_code(400);
                                            exit();
                                        }
                                        </code></pre>
                                </div>
                            </div>
                        </div>
                        <div class="card mb-4">
                            <div class="card-header">
                                <strong>HTTPS</strong>
                            </div>
                            <div class="card-body">
                                <p>
                                    Stripe requiere que todos los endpoints de webhook utilicen HTTPS para garantizar que los datos se transmitan de forma cifrada entre Stripe y tu servidor.
                                </p>

                                <div class="alert alert-info">
                                    <i class="fas fa-lock"></i> <strong>Requisito:</strong> Tu servidor debe tener un certificado SSL válido. Stripe no enviará eventos a endpoints sin HTTPS en producción.
                                </div>

                                <p>
                                    Durante el desarrollo, puedes utilizar herramientas como:
                                </p>
                                <ul>
                                    <li><strong>Stripe CLI:</strong> Para reenviar eventos a localhost sin necesidad de HTTPS.</li>
                                    <li><strong>ngrok:</strong> Para crear un túnel HTTPS hacia tu servidor local.</li>
                                    <li><strong>Certificados autofirmados:</strong> Solo para entornos de desarrollo local.</li>
                                </ul>
                            </div>
                        </div>

                        <div class="alert alert-danger">
                            <i class="fas fa-exclamation-circle"></i> <strong>Advertencia:</strong> Nunca almacenes el Webhook Secret en archivos públicos o repositorios de código. Al igual que la clave API secreta, debe mantenerse en variables de entorno o sistemas seguros de gestión de secretos.
                        </div>
                    </div>

                    <div id="reintentos-webhooks" class="subsection">
                        <h4>2.3. Reintentos y Mejores Prácticas para la Respuesta del Endpoint</h4>
                        <p>
                            Stripe utiliza un sistema sofisticado de reintentos para garantizar la entrega de webhooks, pero es crucial que tu endpoint responda correctamente:
                        </p>

                        <div class="row mb-4">
                            <div class="col-md-6">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <strong>Política de reintentos de Stripe</strong>
                                    </div>
                                    <div class="card-body">
                                        <p>Si tu servidor no responde con un código 2xx, Stripe reintentará el evento:</p>
                                        <ul>
                                            <li>Reintentos durante 3 días.</li>
                                            <li>Frecuencia: cada hora aproximadamente.</li>
                                            <li>Esquema exponencial: los intervalos aumentan con cada intento fallido.</li>
                                            <li>El mismo evento puede enviarse múltiples veces (idempotencia).</li>
                                        </ul>
                                        <p>Después de los reintentos, el evento se marca como fallido en el panel de Stripe.</p>
                                    </div>
                                </div>
                            </div>

                            <div class="col-md-6">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <strong>Respuestas correctas del endpoint</strong>
                                    </div>
                                    <div class="card-body">
                                        <p><strong>Buenas respuestas (evitan reintentos):</strong></p>
                                        <ul>
                                            <li>HTTP 200: El evento se procesó correctamente.</li>
                                            <li>HTTP 204: El evento se recibió pero no requiere acción.</li>
                                        </ul>
                                        <p><strong>Respuestas que provocan reintentos:</strong></p>
                                        <ul>
                                            <li>HTTP 4xx (excepto 409): Error del cliente.</li>
                                            <li>HTTP 5xx: Error del servidor.</li>
                                            <li>Timeout: Sin respuesta en 30 segundos.</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="card mb-4">
                            <div class="card-header">
                                <strong>Mejores prácticas para el procesamiento de webhooks</strong>
                            </div>
                            <div class="card-body">
                                <ol>
                                    <li>
                                        <strong>Implementa idempotencia:</strong>
                                        <p>Diseña tu código para manejar el mismo evento múltiples veces sin efectos secundarios indeseados. Utiliza el ID del evento como identificador único.</p>
                                    </li>
                                    <li>
                                        <strong>Respuesta rápida:</strong>
                                        <p>Responde 200 lo antes posible, idealmente en menos de 10 segundos. Para tareas largas, confirma la recepción y luego procesa el evento en segundo plano.</p>
                                    </li>
                                    <li>
                                        <strong>Manejo de errores robusto:</strong>
                                        <p>Si encuentras un error que sabes que persistirá (como datos incompatibles), responde 200 pero registra el problema para revisión manual. Evita reintentos innecesarios.</p>
                                    </li>
                                    <li>
                                        <strong>Registro detallado:</strong>
                                        <p>Guarda los webhooks recibidos (sin datos sensibles de tarjetas) para diagnóstico y auditoría.</p>
                                    </li>
                                    <li>
                                        <strong>Monitoreo activo:</strong>
                                        <p>Configura alertas para eventos fallidos en el panel de Stripe o implementa tu propio sistema de monitoreo.</p>
                                    </li>
                                </ol>

                                <div class="alert alert-success">
                                    <i class="fas fa-check-circle"></i> <strong>Consejo:</strong> En StripeLabApp, utilizamos una arquitectura basada en el patrón Strategy para procesar diferentes tipos de eventos, permitiendo un código organizado y mantenible.
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Sección 3 -->
                <section id="eventos" class="mb-4">
                    <h3>3. Eventos de Stripe: Tipos y Uso</h3>

                    <div id="anatomia-evento" class="subsection">
                        <h4>3.1. Anatomía de un Objeto Evento de Stripe</h4>
                        <p>
                            Los eventos de Stripe son objetos JSON con una estructura específica que proporciona información detallada sobre qué ha ocurrido en tu cuenta. Comprender esta estructura es fundamental para procesar correctamente los webhooks.
                        </p>

                        <div class="card mb-4">
                            <div class="card-header">
                                <strong>Estructura básica de un evento</strong>
                            </div>
                            <div class="card-body">
                                <div class="code-snippet">
                                        <pre><code class="language-json">
{
  "id": "evt_1OabCdEFghIJklMN",  // Identificador único del evento
  "object": "event",
  "api_version": "2023-10-16",   // Versión de la API usada
  "created": 1643043046,         // Timestamp Unix de creación
  "data": {
    "object": {
      // El objeto afectado por este evento (payment_intent, subscription, etc.)
      "id": "pi_1OabCdEFghIJklMN",
      "object": "payment_intent",
      // ... resto de propiedades del objeto
    },
    "previous_attributes": {
      // Solo presente en eventos de actualización
      // Contiene los valores anteriores de los atributos modificados
      "status": "requires_payment_method"
    }
  },
  "livemode": false,             // false para el entorno de prueba, true para producción
  "pending_webhooks": 2,         // Número de webhooks pendientes para este evento
  "request": {
    "id": "req_1OabCdEFghIJklMN", // ID de la solicitud que generó el evento
    "idempotency_key": "key123"   // Clave de idempotencia si se proporcionó
  },
  "type": "payment_intent.succeeded" // Tipo de evento
}
                                        </code></pre>
                                </div>

                                <div class="mt-4">
                                    <h5>Campos clave:</h5>
                                    <ul>
                                        <li>
                                            <strong><code>id</code>:</strong> Identificador único del evento (comienza con <code>evt_</code>). Úsalo para implementar la idempotencia y evitar procesamiento duplicado.
                                        </li>
                                        <li>
                                            <strong><code>type</code>:</strong> Especifica qué ha ocurrido. Estructura: <code>resource.event</code>, por ejemplo, <code>payment_intent.succeeded</code> indica que un PaymentIntent ha tenido éxito.
                                        </li>
                                        <li>
                                            <strong><code>data.object</code>:</strong> Contiene el objeto completo relacionado con el evento, con todos sus campos y valores actuales.
                                        </li>
                                        <li>
                                            <strong><code>data.previous_attributes</code>:</strong> Solo presente en eventos de actualización, muestra los valores anteriores de los campos que han cambiado.
                                        </li>
                                        <li>
                                            <strong><code>livemode</code>:</strong> Indica si el evento pertenece al entorno de producción (<code>true</code>) o al entorno de prueba (<code>false</code>).
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <div class="alert alert-info">
                            <i class="fas fa-lightbulb"></i> <strong>Consejo de implementación:</strong> En StripeLabApp, mapeamos estos eventos a DTOs específicos (Data Transfer Objects) para facilitar su procesamiento en nuestra arquitectura por capas.
                        </div>
                    </div>

                    <div id="categorias-eventos" class="subsection">
                        <h4>3.2. Categorías Principales de Eventos</h4>
                        <p>
                            Stripe genera más de 100 tipos de eventos diferentes, agrupados en categorías según el recurso afectado. Aquí están las categorías más relevantes para StripeLabApp:
                        </p>

                        <div class="table-responsive mb-4">
                            <table class="table table-striped table-hover">
                                <thead class="table-primary">
                                <tr>
                                    <th>Categoría</th>
                                    <th>Prefijo del evento</th>
                                    <th>Descripción</th>
                                    <th>Eventos típicos</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td><strong>Charges</strong></td>
                                    <td><code>charge.</code></td>
                                    <td>Eventos relacionados con cargos a métodos de pago.</td>
                                    <td><code>charge.succeeded</code>, <code>charge.failed</code>, <code>charge.refunded</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Payment Intents</strong></td>
                                    <td><code>payment_intent.</code></td>
                                    <td>Eventos que siguen el ciclo de vida de los intentos de pago.</td>
                                    <td><code>payment_intent.created</code>, <code>payment_intent.succeeded</code>, <code>payment_intent.payment_failed</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Checkout Sessions</strong></td>
                                    <td><code>checkout.session.</code></td>
                                    <td>Eventos relacionados con las sesiones de Stripe Checkout.</td>
                                    <td><code>checkout.session.completed</code>, <code>checkout.session.expired</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Customers</strong></td>
                                    <td><code>customer.</code></td>
                                    <td>Eventos relacionados con la creación y modificación de clientes.</td>
                                    <td><code>customer.created</code>, <code>customer.updated</code>, <code>customer.deleted</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Subscriptions</strong></td>
                                    <td><code>customer.subscription.</code></td>
                                    <td>Eventos del ciclo de vida de las suscripciones.</td>
                                    <td><code>customer.subscription.created</code>, <code>customer.subscription.updated</code>, <code>customer.subscription.deleted</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Invoices</strong></td>
                                    <td><code>invoice.</code></td>
                                    <td>Eventos relacionados con facturas, principalmente para suscripciones.</td>
                                    <td><code>invoice.created</code>, <code>invoice.paid</code>, <code>invoice.payment_failed</code></td>
                                </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="alert alert-warning">
                            <i class="fas fa-info-circle"></i> <strong>Nota:</strong> Esta tabla muestra solo las categorías más comunes. Stripe puede añadir nuevos tipos de eventos en cualquier momento, por lo que es recomendable diseñar tu sistema para manejar eventos desconocidos de manera elegante.
                        </div>

                        <p>
                            En StripeLabApp, nos enfocamos principalmente en los eventos relacionados con pagos únicos (<code>payment_intent</code>, <code>charge</code>) y suscripciones (<code>customer.subscription</code>, <code>invoice</code>), ya que estos son fundamentales para mantener el estado de las transacciones y suscripciones de los usuarios.
                        </p>
                    </div>

                    <div id="eventos-detallados" class="subsection">
                        <h4>3.3. Eventos Detallados</h4>
                        <p>
                            A continuación, analizamos en detalle los eventos más importantes que se manejan en StripeLabApp, agrupados por funcionalidad. Entender estos eventos y sus payloads es esencial para implementar correctamente las estrategias de procesamiento.
                        </p>

                        <!-- Checkout Events -->
                        <div class="card mb-4">
                            <div class="card-header bg-primary text-white">
                                <h5 class="mb-0">Checkout</h5>
                            </div>
                            <div class="card-body">
                                <p>
                                    Los eventos de Checkout proporcionan información sobre el proceso de pago mediante Stripe Checkout, incluyendo el resultado final y si la sesión expiró sin completarse.
                                </p>

                                <!-- checkout.session.completed -->
                                <div class="event-details mb-4">
                                    <h5><code>checkout.session.completed</code></h5>
                                    <div class="alert alert-success">
                                        <i class="fas fa-check-circle"></i> <strong>Descripción:</strong> Se dispara cuando un cliente completa el proceso de pago en Stripe Checkout. Este evento es crucial para activar productos o servicios después de un pago exitoso.
                                    </div>
                                    <p>
                                        Este evento contiene toda la información relevante sobre la transacción, incluyendo:
                                    </p>
                                    <ul>
                                        <li>Detalles del cliente (<code>customer</code>, <code>customer_details</code>)</li>
                                        <li>Monto del pago (<code>amount_total</code>)</li>
                                        <li>Modo de operación (<code>mode</code>: "payment" para pagos únicos, "subscription" para suscripciones)</li>
                                        <li>Estado del pago (<code>payment_status</code>)</li>
                                        <li>Referencias a objetos relacionados (<code>payment_intent</code>, <code>subscription</code>, <code>invoice</code>)</li>
                                    </ul>

                                    <p><strong>Payload de Ejemplo:</strong></p>
                                    <div class="code-snippet">
                                            <pre><code class="language-json">
                                                {
                                                    "id": "cs_test_a1pbv8QoyAgXUfa043e3KZqhIgtT3ve1aD7hPgqe73c2HTaNOjc13ki5XI",
                                                    "object": "checkout.session",
                                                    "adaptive_pricing": null,
                                                    "after_expiration": null,
                                                    "allow_promotion_codes": null,
                                                    "amount_subtotal": 1500,
                                                    "amount_total": 1500,
                                                    "automatic_tax": {
                                                        "enabled": false,
                                                        "liability": null,
                                                        "provider": null,
                                                        "status": null
                                                    },
                                                    "billing_address_collection": null,
                                                    "cancel_url": "http://localhost:8000/public/cancel.html",
                                                    "client_reference_id": null,
                                                    "client_secret": null,
                                                    "collected_information": {
                                                        "shipping_details": null
                                                    },
                                                    "consent": null,
                                                    "consent_collection": null,
                                                    "created": 1747091168,
                                                    "currency": "eur",
                                                    "currency_conversion": null,
                                                    "custom_fields": [],
                                                    "custom_text": {
                                                        "after_submit": null,
                                                        "shipping_address": null,
                                                        "submit": null,
                                                        "terms_of_service_acceptance": null
                                                    },
                                                    "customer": "cus_SIgoJvUF0ooe7U",
                                                    "customer_creation": "always",
                                                    "customer_details": {
                                                        "address": {
                                                            "city": null,
                                                            "country": "ES",
                                                            "line1": null,
                                                            "line2": null,
                                                            "postal_code": null,
                                                            "state": null
                                                        },
                                                        "email": "TESTanual@TEST.COM",
                                                        "name": "suscripcion anual",
                                                        "phone": null,
                                                        "tax_exempt": "none",
                                                        "tax_ids": []
                                                    },
                                                    "customer_email": null,
                                                    "discounts": [],
                                                    "expires_at": 1747177568,
                                                    "invoice": "in_1RO5QgP71JLI6sb9HSRdDSiW",
                                                    "invoice_creation": null,
                                                    "livemode": false,
                                                    "locale": null,
                                                    "metadata": [],
                                                    "mode": "subscription",
                                                    "payment_intent": null,
                                                    "payment_link": null,
                                                    "payment_method_collection": "always",
                                                    "payment_method_configuration_details": null,
                                                    "payment_method_options": {
                                                        "card": {
                                                            "request_three_d_secure": "automatic"
                                                        }
                                                    },
                                                    "payment_method_types": [
                                                        "card"
                                                    ],
                                                    "payment_status": "paid",
                                                    "permissions": null,
                                                    "phone_number_collection": {
                                                        "enabled": false
                                                    },
                                                    "recovered_from": null,
                                                    "saved_payment_method_options": {
                                                        "allow_redisplay_filters": [
                                                            "always"
                                                        ],
                                                        "payment_method_remove": "disabled",
                                                        "payment_method_save": null
                                                    },
                                                    "setup_intent": null,
                                                    "shipping_address_collection": null,
                                                    "shipping_cost": null,
                                                    "shipping_options": [],
                                                    "status": "complete",
                                                    "submit_type": null,
                                                    "subscription": "sub_1RO5QfP71JLI6sb9EKIosSQS",
                                                    "success_url": "http://localhost:8000/public/success.html?session_id={CHECKOUT_SESSION_ID}",
                                                    "total_details": {
                                                        "amount_discount": 0,
                                                        "amount_shipping": 0,
                                                        "amount_tax": 0
                                                    },
                                                    "ui_mode": "hosted",
                                                    "url": null,
                                                    "wallet_options": null
                                                }
                                                                                            </code></pre>
                                    </div>

                                    <div class="mt-3 alert alert-info">
                                        <i class="fas fa-lightbulb"></i> <strong>Implementación en StripeLabApp:</strong> Utilizamos este evento para crear registros de transacciones, activar suscripciones y enviar confirmaciones por correo electrónico al usuario.
                                    </div>
                                </div>
                                <!-- checkout.session.expired -->
                                <div class="event-details">
                                    <h5><code>checkout.session.expired</code></h5>
                                    <div class="alert alert-warning">
                                        <i class="fas fa-clock"></i> <strong>Descripción:</strong> Se dispara cuando una sesión de Checkout expira antes de que el cliente complete el pago. Por defecto, las sesiones expiran después de 24 horas.
                                    </div>
                                    <p>
                                        Este evento es útil para:
                                    </p>
                                    <ul>
                                        <li>Limpiar recursos reservados temporalmente para el cliente</li>
                                        <li>Enviar recordatorios de pago pendiente</li>
                                        <li>Realizar análisis de abandono del carrito</li>
                                    </ul>

                                    <p><strong>Payload de Ejemplo:</strong></p>
                                    <div class="code-snippet">
                                            <pre><code class="language-json">
{
    "id": "cs_test_a1M54d8jxXa1ii0F5nl98GugMADB2OllRqFfnBGzLfrhOOCnyTtU0xtUdr",
    "object": "checkout.session",
    "adaptive_pricing": {
        "enabled": true
    },
    "after_expiration": null,
    "allow_promotion_codes": null,
    "amount_subtotal": 1000,
    "amount_total": 1000,
    "automatic_tax": {
        "enabled": false,
        "liability": null,
        "provider": null,
        "status": null
    },
    "billing_address_collection": null,
    "cancel_url": "http://localhost:8000/public/cancel.html",
    "client_reference_id": null,
    "client_secret": null,
    "collected_information": null,
    "consent": null,
    "consent_collection": null,
    "created": 1747004962,
    "currency": "eur",
    "currency_conversion": null,
    "custom_fields": [],
    "custom_text": {
        "after_submit": null,
        "shipping_address": null,
        "submit": null,
        "terms_of_service_acceptance": null
    },
    "customer": null,
    "customer_creation": "if_required",
    "customer_details": null,
    "customer_email": null,
    "discounts": [],
    "expires_at": 1747091362,
    "invoice": null,
    "invoice_creation": {
        "enabled": false,
        "invoice_data": {
            "account_tax_ids": null,
            "custom_fields": null,
            "description": null,
            "footer": null,
            "issuer": null,
            "metadata": [],
            "rendering_options": null
        }
    },
    "livemode": false,
    "locale": null,
    "metadata": [],
    "mode": "payment",
    "payment_intent": null,
    "payment_link": null,
    "payment_method_collection": "if_required",
    "payment_method_configuration_details": null,
    "payment_method_options": {
        "card": {
            "request_three_d_secure": "automatic"
        }
    },
    "payment_method_types": [
        "card"
    ],
    "payment_status": "unpaid",
    "permissions": null,
    "phone_number_collection": {
        "enabled": false
    },
    "recovered_from": null,
    "saved_payment_method_options": null,
    "setup_intent": null,
    "shipping_address_collection": null,
    "shipping_cost": null,
    "shipping_options": [],
    "status": "expired",
    "submit_type": null,
    "subscription": null,
    "success_url": "http://localhost:8000/public/success.html?session_id={CHECKOUT_SESSION_ID}",
    "total_details": {
        "amount_discount": 0,
        "amount_shipping": 0,
        "amount_tax": 0
    },
    "ui_mode": "hosted",
    "url": null,
    "wallet_options": null
}
                                            </code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Customer Events -->
                        <div class="card mb-4">
                            <div class="card-header bg-primary text-white">
                                <h5 class="mb-0">Clientes (Customers)</h5>
                            </div>
                            <div class="card-body">
                                <p>
                                    Los eventos de Clientes proporcionan información sobre cambios en los objetos Customer, que son esenciales para gestionar la información de los usuarios y sus métodos de pago.
                                </p>

                                <!-- customer.created -->
                                <div class="event-details mb-4">
                                    <h5><code>customer.created</code></h5>
                                    <div class="alert alert-success">
                                        <i class="fas fa-user-plus"></i> <strong>Descripción:</strong> Se dispara cuando se crea un nuevo cliente en Stripe. Esto ocurre durante el registro del usuario, la primera compra, o cuando se crea explícitamente mediante la API.
                                    </div>
                                    <p>
                                        El payload incluye toda la información del cliente, como:
                                    </p>
                                    <ul>
                                        <li>Información de contacto (email, nombre, teléfono)</li>
                                        <li>Dirección de facturación</li>
                                        <li>Configuración de facturación predeterminada</li>
                                        <li>Preferencias de localización</li>
                                    </ul>

                                    <p><strong>Payload de Ejemplo:</strong></p>
                                    <div class="code-snippet">
                                            <pre><code class="language-json">
{
    "id": "cus_SIgjYjt5FKHVKG",
    "object": "customer",
    "address": {
        "city": null,
        "country": "ES",
        "line1": null,
        "line2": null,
        "postal_code": null,
        "state": null
    },
    "balance": 0,
    "created": 1747090919,
    "currency": null,
    "default_source": null,
    "delinquent": false,
    "description": null,
    "discount": null,
    "email": "TEST@TEST.COM",
    "invoice_prefix": "4ERGRE3J",
    "invoice_settings": {
        "custom_fields": null,
        "default_payment_method": null,
        "footer": null,
        "rendering_options": null
    },
    "livemode": false,
    "metadata": [],
    "name": "suscripcion mensual",
    "phone": null,
    "preferred_locales": [
        "es-ES"
    ],
    "shipping": null,
    "tax_exempt": "none",
    "test_clock": null
}
                                            </code></pre>
                                    </div>

                                    <div class="mt-3 alert alert-info">
                                        <i class="fas fa-lightbulb"></i> <strong>Implementación en StripeLabApp:</strong> Sincronizamos los datos del cliente con nuestra base de datos para mantener la coherencia entre nuestro sistema y Stripe.
                                    </div>
                                </div>

                                <!-- customer.updated -->
                                <div class="event-details mb-4">
                                    <h5><code>customer.updated</code></h5>
                                    <div class="alert alert-info">
                                        <i class="fas fa-user-edit"></i> <strong>Descripción:</strong> Se dispara cuando se actualiza cualquier información del cliente. Los cambios pueden incluir detalles de contacto, métodos de pago predeterminados o metadatos.
                                    </div>
                                    <p>
                                        Este evento es particularmente útil para mantener sincronizada la información del cliente entre Stripe y tu base de datos. El payload incluye tanto los datos actualizados como el campo <code>previous_attributes</code> en el evento principal, que contiene los valores anteriores de los campos modificados.
                                    </p>

                                    <p><strong>Payload de Ejemplo:</strong></p>
                                    <div class="code-snippet">
                                            <pre><code class="language-json">
{
    "id": "cus_SIgjYjt5FKHVKG",
    "object": "customer",
    "address": {
        "city": null,
        "country": "ES",
        "line1": null,
        "line2": null,
        "postal_code": null,
        "state": null
    },
    "balance": 0,
    "created": 1747090919,
    "currency": "eur",
    "default_source": null,
    "delinquent": false,
    "description": null,
    "discount": null,
    "email": "TEST@TEST.COM",
    "invoice_prefix": "4ERGRE3J",
    "invoice_settings": {
        "custom_fields": null,
        "default_payment_method": null,
        "footer": null,
        "rendering_options": null
    },
    "livemode": false,
    "metadata": [],
    "name": "suscripcion mensual",
    "phone": null,
    "preferred_locales": [
        "es-ES"
    ],
    "shipping": null,
    "tax_exempt": "none",
    "test_clock": null
}
                                            </code></pre>
                                    </div>
                                </div>

                                <!-- customer.deleted (brief mention) -->
                                <div class="event-details">
                                    <h5><code>customer.deleted</code></h5>
                                    <div class="alert alert-warning">
                                        <i class="fas fa-user-slash"></i> <strong>Descripción:</strong> Se dispara cuando se elimina un cliente de Stripe. En StripeLabApp, utilizamos este evento para marcar al cliente como inactivo en nuestra base de datos, sin eliminar su historial por razones de auditoría.
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Payment Events -->
                        <div class="card mb-4">
                            <div class="card-header bg-primary text-white">
                                <h5 class="mb-0">Pagos (PaymentIntents & Charges)</h5>
                            </div>
                            <div class="card-body">
                                <p>
                                    Los eventos de Pagos son fundamentales para rastrear el estado de las transacciones y confirmar cuando un pago ha sido procesado correctamente.
                                </p>

                                <!-- payment_intent.created (brief mention) -->
                                <div class="event-details mb-4">
                                    <h5><code>payment_intent.created</code></h5>
                                    <div class="alert alert-secondary">
                                        <i class="fas fa-info-circle"></i> <strong>Descripción:</strong> Se dispara cuando se crea un nuevo PaymentIntent. En StripeLabApp no procesamos activamente este evento, ya que representa solo el inicio del proceso de pago.
                                    </div>

                                    <p><strong>Payload de Ejemplo:</strong></p>
                                    <div class="code-snippet">
                                            <pre><code class="language-json">
{
    "id": "pi_3RO5MBP71JLI6sb90nUSzhE7",
    "object": "payment_intent",
    "amount": 300,
    "amount_capturable": 0,
    "amount_details": {
        "tip": []
    },
    "amount_received": 0,
    "application": null,
    "application_fee_amount": null,
    "automatic_payment_methods": null,
    "canceled_at": null,
    "cancellation_reason": null,
    "capture_method": "automatic",
    "client_secret": "pi_3RO5MBP71JLI6sb90nUSzhE7_secret_vAWdJSFnikd4n7snnVLBXMDgW",
    "confirmation_method": "automatic",
    "created": 1747090919,
    "currency": "eur",
    "customer": "cus_SIgjYjt5FKHVKG",
    "description": "Subscription creation",
    "last_payment_error": null,
    "latest_charge": null,
    "livemode": false,
    "metadata": [],
    "next_action": null,
    "on_behalf_of": null,
    "payment_method": null,
    "payment_method_configuration_details": null,
    "payment_method_options": {
        "card": {
            "installments": null,
            "mandate_options": null,
            "network": null,
            "request_three_d_secure": "automatic"
        },
        "link": {
            "persistent_token": null
        }
    },
    "payment_method_types": [
        "card",
        "link"
    ],
    "processing": null,
    "receipt_email": null,
    "review": null,
    "setup_future_usage": "off_session",
    "shipping": null,
    "source": null,
    "statement_descriptor": null,
    "statement_descriptor_suffix": null,
    "status": "requires_payment_method",
    "transfer_data": null,
    "transfer_group": null
}
                                            </code></pre>
                                    </div>
                                </div>

                                <!-- payment_intent.succeeded -->
                                <div class="event-details mb-4">
                                    <h5><code>payment_intent.succeeded</code></h5>
                                    <div class="alert alert-success">
                                        <i class="fas fa-check-circle"></i> <strong>Descripción:</strong> Se dispara cuando un pago se completa con éxito. Este es uno de los eventos más importantes para confirmar que una transacción ha sido procesada correctamente.
                                    </div>
                                    <p>
                                        El payload contiene toda la información sobre el pago exitoso, incluyendo:
                                    </p>
                                    <ul>
                                        <li>El monto cobrado y la moneda</li>
                                        <li>El cliente (si está asociado)</li>
                                        <li>El método de pago utilizado</li>
                                        <li>La referencia al cargo (<code>latest_charge</code>) que contiene detalles adicionales</li>
                                    </ul>

                                    <p><strong>Payload de Ejemplo (pago único):</strong></p>
                                    <div class="code-snippet">
                                            <pre><code class="language-json">
{
    "id": "pi_3RO5KdP71JLI6sb91XFQkshR",
    "object": "payment_intent",
    "amount": 1000,
    "amount_capturable": 0,
    "amount_details": {
        "tip": []
    },
    "amount_received": 1000,
    "application": null,
    "application_fee_amount": null,
    "automatic_payment_methods": null,
    "canceled_at": null,
    "cancellation_reason": null,
    "capture_method": "automatic_async",
    "client_secret": "pi_3RO5KdP71JLI6sb91XFQkshR_secret_w5q9oPR0tmbNlYeULXUekzEYt",
    "confirmation_method": "automatic",
    "created": 1747090823,
    "currency": "eur",
    "customer": null,
    "description": null,
    "last_payment_error": null,
    "latest_charge": "ch_3RO5KdP71JLI6sb91oRRGx4P",
    "livemode": false,
    "metadata": [],
    "next_action": null,
    "on_behalf_of": null,
    "payment_method": "pm_1RO5KcP71JLI6sb9DAN632WU",
    "payment_method_configuration_details": null,
    "payment_method_options": {
        "card": {
            "installments": null,
            "mandate_options": null,
            "network": null,
            "request_three_d_secure": "automatic"
        }
    },
    "payment_method_types": [
        "card"
    ],
    "processing": null,
    "receipt_email": null,
    "review": null,
    "setup_future_usage": null,
    "shipping": null,
    "source": null,
    "statement_descriptor": null,
    "statement_descriptor_suffix": null,
    "status": "succeeded",
    "transfer_data": null,
    "transfer_group": null
}
                                            </code></pre>
                                    </div>

                                    <p><strong>Payload de Ejemplo (pago de suscripción):</strong></p>
                                    <div class="code-snippet">
                                            <pre><code class="language-json">
{
    "id": "pi_3RO5QeP71JLI6sb90iwvxrFW",
    "object": "payment_intent",
    "amount": 1500,
    "amount_capturable": 0,
    "amount_details": {
        "tip": []
    },
    "amount_received": 1500,
    "application": null,
    "application_fee_amount": null,
    "automatic_payment_methods": null,
    "canceled_at": null,
    "cancellation_reason": null,
    "capture_method": "automatic",
    "client_secret": "pi_3RO5QeP71JLI6sb90iwvxrFW_secret_jYRCh9uUSLrrbosrHRfOxYm9e",
    "confirmation_method": "automatic",
    "created": 1747091196,
    "currency": "eur",
    "customer": "cus_SIgoJvUF0ooe7U",
    "description": "Subscription creation",
    "last_payment_error": null,
    "latest_charge": "ch_3RO5QeP71JLI6sb90RTFOULQ",
    "livemode": false,
    "metadata": [],
    "next_action": null,
    "on_behalf_of": null,
    "payment_method": "pm_1RO5QdP71JLI6sb9E6WLHpfW",
    "payment_method_configuration_details": null,
    "payment_method_options": {
        "card": {
            "installments": null,
            "mandate_options": null,
            "network": null,
            "request_three_d_secure": "automatic",
            "setup_future_usage": "off_session"
        }
    },
    "payment_method_types": [
        "card"
    ],
    "processing": null,
    "receipt_email": null,
    "review": null,
    "setup_future_usage": "off_session",
    "shipping": null,
    "source": null,
    "statement_descriptor": null,
    "statement_descriptor_suffix": null,
    "status": "succeeded",
    "transfer_data": null,
    "transfer_group": null
}
                                            </code></pre>
                                    </div>

                                    <div class="mt-3 alert alert-info">
                                        <i class="fas fa-lightbulb"></i> <strong>Implementación en StripeLabApp:</strong> Usamos este evento para registrar transacciones exitosas, actualizar el estado de las órdenes y desencadenar la entrega de productos o servicios.
                                    </div>
                                </div>

                                <!-- payment_intent.payment_failed (brief mention) -->
                                <div class="event-details mb-4">
                                    <h5><code>payment_intent.payment_failed</code></h5>
                                    <div class="alert alert-danger">
                                        <i class="fas fa-exclamation-circle"></i> <strong>Descripción:</strong> Se dispara cuando un intento de pago falla por cualquier motivo (tarjeta rechazada, fondos insuficientes, error de autenticación, etc.). En StripeLabApp, utilizamos este evento para notificar a los usuarios y ofrecerles alternativas para completar su pago.
                                    </div>
                                </div>

                                <!-- charge.succeeded -->
                                <div class="event-details mb-4">
                                    <h5><code>charge.succeeded</code></h5>
                                    <div class="alert alert-success">
                                        <i class="fas fa-credit-card"></i> <strong>Descripción:</strong> Se dispara cuando un cargo a una tarjeta o método de pago se procesa correctamente. Aunque está estrechamente relacionado con <code>payment_intent.succeeded</code>, este evento proporciona información adicional específica del cargo.
                                    </div>
                                    <p>
                                        La importancia de este evento reside en que contiene detalles adicionales como:
                                    </p>
                                    <ul>
                                        <li>El <code>receipt_url</code> (URL del recibo) que puedes proporcionar a tus clientes</li>
                                        <li>Detalles específicos del método de pago (últimos 4 dígitos, marca, país de emisión)</li>
                                        <li>Resultados de verificaciones de seguridad (CVC, dirección)</li>
                                        <li>Información detallada sobre el procesamiento del pago</li>
                                    </ul>

                                    <p><strong>Payload de Ejemplo:</strong></p>
                                    <div class="code-snippet">
                                            <pre><code class="language-json">
{
    "id": "ch_3RO5KdP71JLI6sb91oRRGx4P",
    "object": "charge",
    "amount": 1000,
    "amount_captured": 1000,
    "amount_refunded": 0,
    "application": null,
    "application_fee": null,
    "application_fee_amount": null,
    "balance_transaction": null,
    "billing_details": {
        "address": {
            "city": null,
            "country": "ES",
            "line1": null,
            "line2": null,
            "postal_code": null,
            "state": null
        },
        "email": "jccataluna@ddd.com",
        "name": "Pago unico",
        "phone": null,
        "tax_id": null
    },
    "calculated_statement_descriptor": "Stripe",
    "captured": true,
    "created": 1747090823,
    "currency": "eur",
    "customer": null,
    "description": null,
    "destination": null,
    "dispute": null,
    "disputed": false,
    "failure_balance_transaction": null,
    "failure_code": null,
    "failure_message": null,
    "fraud_details": [],
    "livemode": false,
    "metadata": [],
    "on_behalf_of": null,
    "order": null,
    "outcome": {
        "advice_code": null,
        "network_advice_code": null,
        "network_decline_code": null,
        "network_status": "approved_by_network",
        "reason": null,
        "risk_level": "normal",
        "risk_score": 33,
        "seller_message": "Payment complete.",
        "type": "authorized"
    },
    "paid": true,
    "payment_intent": "pi_3RO5KdP71JLI6sb91XFQkshR",
    "payment_method": "pm_1RO5KcP71JLI6sb9DAN632WU",
    "payment_method_details": {
        "card": {
            "amount_authorized": 1000,
            "authorization_code": null,
            "brand": "visa",
            "checks": {
                "address_line1_check": null,
                "address_postal_code_check": null,
                "cvc_check": "pass"
            },
            "country": "US",
            "exp_month": 2,
            "exp_year": 2026,
            "extended_authorization": {
                "status": "disabled"
            },
            "fingerprint": "H2RjQOzJ2vMTHb1p",
            "funding": "credit",
            "incremental_authorization": {
                "status": "unavailable"
            },
            "installments": null,
            "last4": "4242",
            "mandate": null,
            "multicapture": {
                "status": "unavailable"
            },
            "network": "visa",
            "network_token": {
                "used": false
            },
            "network_transaction_id": "725082106817912",
            "overcapture": {
                "maximum_amount_capturable": 1000,
                "status": "unavailable"
            },
            "regulated_status": "unregulated",
            "three_d_secure": null,
            "wallet": null
        },
        "type": "card"
    },
    "radar_options": [],
    "receipt_email": null,
    "receipt_number": null,
    "receipt_url": "https://pay.stripe.com/receipts/payment/CAcaFwoVYWNjdF8xUkhKNjFQNzFKTEk2c2I5KIj7icEGMgZeDpPk1pQ6LBaNV8plHjPjyBGcptjwO_J4m04Rts0jrS-KR4rCdXiuo6L8ogY29dtVIBzV",
    "refunded": false,
    "review": null,
    "shipping": null,
    "source": null,
    "source_transfer": null,
    "statement_descriptor": null,
    "statement_descriptor_suffix": null,
    "status": "succeeded",
    "transfer_data": null,
    "transfer_group": null
}
                                            </code></pre>
                                    </div>

                                    <div class="mt-3 alert alert-info">
                                        <i class="fas fa-lightbulb"></i> <strong>Implementación en StripeLabApp:</strong> Extraemos y almacenamos el <code>receipt_url</code> para proporcionarlo a nuestros usuarios, y registramos los detalles del método de pago para análisis y servicio al cliente.
                                    </div>
                                </div>

                                <!-- charge.failed and charge.refunded (brief mention) -->
                                <div class="event-details">
                                    <h5><code>charge.failed</code> y <code>charge.refunded</code></h5>
                                    <div class="alert alert-warning">
                                        <i class="fas fa-exclamation-triangle"></i> <strong>Descripción:</strong>
                                        <ul>
                                            <li><code>charge.failed</code>: Se dispara cuando un cargo no puede procesarse. Contiene información detallada sobre el motivo del fallo.</li>
                                            <li><code>charge.refunded</code>: Se dispara cuando se reembolsa un cargo, ya sea parcial o totalmente. Importante para actualizar el estado de las transacciones y ajustar el inventario si es necesario.</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="alert alert-info mb-4">
                            <i class="fas fa-cogs"></i> <strong>Estrategia de implementación en StripeLabApp:</strong> Utilizamos el patrón Strategy para manejar diferentes tipos de eventos, con una clase de estrategia dedicada para cada tipo de evento importante. Esto nos permite mantener un código limpio y modular, donde cada estrategia tiene una única responsabilidad: procesar su tipo específico de evento.
                        </div>

                        <div class="alert alert-warning">
                            <i class="fas fa-exclamation-circle"></i> <strong>Consideraciones importantes:</strong>
                            <ul>
                                <li>Los eventos pueden llegar en cualquier orden, por lo que tu implementación debe ser robusta ante eventos fuera de secuencia.</li>
                                <li>Implementa idempotencia para garantizar que el procesamiento repetido del mismo evento no cause problemas.</li>
                                <li>Siempre verifica la firma del webhook antes de procesar cualquier evento.</li>
                                <li>Responde rápidamente con un código 200 al recibir el evento, incluso si el procesamiento continúa en segundo plano.</li>
                            </ul>
                        </div>
                    </div>
                </section>
                <!-- Invoice Events -->
                <div class="card mb-4">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0">Facturas (Invoices)</h5>
                    </div>
                    <div class="card-body">
                        <p>
                            Los eventos de facturas proporcionan información sobre la creación, actualización y pago de facturas, elementos esenciales para gestionar y rastrear los pagos, especialmente en modelos de suscripción.
                        </p>

                        <!-- invoice.created -->
                        <div class="event-details mb-4">
                            <h5><code>invoice.created</code></h5>
                            <div class="alert alert-secondary">
                                <i class="fas fa-info-circle"></i> <strong>Descripción:</strong> Se dispara cuando se crea una nueva factura, generalmente como resultado de la creación de una suscripción o cuando se aproxima la fecha de renovación. En StripeLabApp no procesamos activamente este evento, ya que normalmente esperamos a que la factura sea pagada.
                            </div>

                            <p><strong>Payload de Ejemplo:</strong></p>
                            <div class="code-snippet">
                                            <pre><code class="language-json">
{
    "id": "in_1RO5MDP71JLI6sb9eWuwpvJj",
    "object": "invoice",
    "account_country": "ES",
    "account_name": "Stripe Lab App",
    "account_tax_ids": null,
    "amount_due": 300,
    "amount_overpaid": 0,
    "amount_paid": 300,
    "amount_remaining": 0,
    "amount_shipping": 0,
    "application": null,
    "attempt_count": 0,
    "attempted": true,
    "auto_advance": false,
    "automatic_tax": {
        "disabled_reason": null,
        "enabled": false,
        "liability": null,
        "provider": null,
        "status": null
    },
    "automatically_finalizes_at": null,
    "billing_reason": "subscription_create",
    "collection_method": "charge_automatically",
    "created": 1747090919,
    "currency": "eur",
    "custom_fields": null,
    "customer": "cus_SIgjYjt5FKHVKG",
    "customer_address": {
        "city": null,
        "country": "ES",
        "line1": null,
        "line2": null,
        "postal_code": null,
        "state": null
    },
    "customer_email": "TEST@TEST.COM",
    "customer_name": "suscripcion mensual",
    "customer_phone": null,
    "customer_shipping": null,
    "customer_tax_exempt": "none",
    "customer_tax_ids": [],
    "default_payment_method": null,
    "default_source": null,
    "default_tax_rates": [],
    "description": null,
    "discounts": [],
    "due_date": null,
    "effective_at": 1747090919,
    "ending_balance": 0,
    "footer": null,
    "from_invoice": null,
    "hosted_invoice_url": "https://invoice.stripe.com/i/acct_1RHJ61P71JLI6sb9/test_YWNjdF8xUkhKNjFQNzFKTEk2c2I5LF9TSWdqeU9vWU0ycktEOEQ1ZXdjakg4YXdTNlE1a0FJLDEzNzYzMTcyMg0200xYhbKGe5?s=ap",
    "invoice_pdf": "https://pay.stripe.com/invoice/acct_1RHJ61P71JLI6sb9/test_YWNjdF8xUkhKNjFQNzFKTEk2c2I5LF9TSWdqeU9vWU0ycktEOEQ1ZXdjakg4YXdTNlE1a0FJLDEzNzYzMTcyMg0200xYhbKGe5/pdf?s=ap",
    "issuer": {
        "type": "self"
    },
    "last_finalization_error": null,
    "latest_revision": null,
    "lines": {
        "object": "list",
        "data": [
            {
                "id": "il_1RO5MDP71JLI6sb9iN3orsCH",
                "object": "line_item",
                "amount": 300,
                "currency": "eur",
                "description": "1 × Test App (at €3.00 / month)",
                "discount_amounts": [],
                "discountable": true,
                "discounts": [],
                "invoice": "in_1RO5MDP71JLI6sb9eWuwpvJj",
                "livemode": false,
                "metadata": [],
                "parent": {
                    "invoice_item_details": null,
                    "subscription_item_details": {
                        "invoice_item": null,
                        "proration": false,
                        "proration_details": {
                            "credited_items": null
                        },
                        "subscription": "sub_1RO5MDP71JLI6sb9V5sdUJ8V",
                        "subscription_item": "si_SIgjYKrxsGix1W"
                    },
                    "type": "subscription_item_details"
                },
                "period": {
                    "end": 1749769319,
                    "start": 1747090919
                },
                "pretax_credit_amounts": [],
                "pricing": {
                    "price_details": {
                        "price": "price_1RLNcyP71JLI6sb92qc9ywRx",
                        "product": "prod_SFsxoaHLKoYbKj"
                    },
                    "type": "price_details",
                    "unit_amount_decimal": "300"
                },
                "quantity": 1,
                "taxes": []
            }
        ],
        "has_more": false,
        "total_count": 1,
        "url": "/v1/invoices/in_1RO5MDP71JLI6sb9eWuwpvJj/lines"
    },
    "livemode": false,
    "metadata": [],
    "next_payment_attempt": null,
    "number": "98CD073B-0044",
    "on_behalf_of": null,
    "parent": {
        "quote_details": null,
        "subscription_details": {
            "metadata": [],
            "subscription": "sub_1RO5MDP71JLI6sb9V5sdUJ8V"
        },
        "type": "subscription_details"
    },
    "payment_settings": {
        "default_mandate": null,
        "payment_method_options": {
            "acss_debit": null,
            "bancontact": null,
            "card": {
                "request_three_d_secure": "automatic"
            },
            "customer_balance": null,
            "konbini": null,
            "sepa_debit": null,
            "us_bank_account": null
        },
        "payment_method_types": [
            "card"
        ]
    },
    "period_end": 1747090919,
    "period_start": 1747090919,
    "post_payment_credit_notes_amount": 0,
    "pre_payment_credit_notes_amount": 0,
    "receipt_number": null,
    "rendering": null,
    "shipping_cost": null,
    "shipping_details": null,
    "starting_balance": 0,
    "statement_descriptor": null,
    "status": "paid",
    "status_transitions": {
        "finalized_at": 1747090919,
        "marked_uncollectible_at": null,
        "paid_at": 1747090920,
        "voided_at": null
    },
    "subtotal": 300,
    "subtotal_excluding_tax": 300,
    "test_clock": null,
    "total": 300,
    "total_discount_amounts": [],
    "total_excluding_tax": 300,
    "total_pretax_credit_amounts": [],
    "total_taxes": [],
    "webhooks_delivered_at": null
}
                                            </code></pre>
                            </div>
                        </div>

                        <!-- invoice.paid -->
                        <div class="event-details mb-4">
                            <h5><code>invoice.paid</code></h5>
                            <div class="alert alert-success">
                                <i class="fas fa-file-invoice-dollar"></i> <strong>Descripción:</strong> Se dispara cuando se paga una factura con éxito. Este evento es crucial para confirmar pagos recurrentes de suscripciones y actualizar el estado de las suscripciones en tu sistema.
                            </div>
                            <p>
                                El payload contiene toda la información sobre la factura pagada, incluyendo:
                            </p>
                            <ul>
                                <li>Detalles de los elementos facturados (<code>lines</code>)</li>
                                <li>Enlaces a la factura en línea y PDF (<code>hosted_invoice_url</code>, <code>invoice_pdf</code>)</li>
                                <li>Información del periodo facturado (<code>period_start</code>, <code>period_end</code>)</li>
                                <li>Información del cliente y suscripción asociada</li>
                            </ul>

                            <p><strong>Payload de Ejemplo (para factura de suscripción):</strong></p>
                            <div class="code-snippet">
                                            <pre><code class="language-json">
{
    "id": "in_1RO5QgP71JLI6sb9HSRdDSiW",
    "object": "invoice",
    "account_country": "ES",
    "account_name": "Stripe Lab App",
    "account_tax_ids": null,
    "amount_due": 1500,
    "amount_overpaid": 0,
    "amount_paid": 1500,
    "amount_remaining": 0,
    "amount_shipping": 0,
    "application": null,
    "attempt_count": 0,
    "attempted": true,
    "auto_advance": false,
    "automatic_tax": {
        "disabled_reason": null,
        "enabled": false,
        "liability": null,
        "provider": null,
        "status": null
    },
    "automatically_finalizes_at": null,
    "billing_reason": "subscription_create",
    "collection_method": "charge_automatically",
    "created": 1747091196,
    "currency": "eur",
    "custom_fields": null,
    "customer": "cus_SIgoJvUF0ooe7U",
    "customer_address": {
        "city": null,
        "country": "ES",
        "line1": null,
        "line2": null,
        "postal_code": null,
        "state": null
    },
    "customer_email": "TESTanual@TEST.COM",
    "customer_name": "suscripcion anual",
    "customer_phone": null,
    "customer_shipping": null,
    "customer_tax_exempt": "none",
    "customer_tax_ids": [],
    "default_payment_method": null,
    "default_source": null,
    "default_tax_rates": [],
    "description": null,
    "discounts": [],
    "due_date": null,
    "effective_at": 1747091196,
    "ending_balance": 0,
    "footer": null,
    "from_invoice": null,
    "hosted_invoice_url": "https://invoice.stripe.com/i/acct_1RHJ61P71JLI6sb9/test_YWNjdF8xUkhKNjFQNzFKTEk2c2I5LF9TSWdvcVFJOGI2ZkQ2ZXRSV0IycE53YVczVGQwS2lkLDEzNzYzMTk5OQ02004O5XAkp5?s=ap",
    "invoice_pdf": "https://pay.stripe.com/invoice/acct_1RHJ61P71JLI6sb9/test_YWNjdF8xUkhKNjFQNzFKTEk2c2I5LF9TSWdvcVFJOGI2ZkQ2ZXRSV0IycE53YVczVGQwS2lkLDEzNzYzMTk5OQ02004O5XAkp5/pdf?s=ap",
    "issuer": {
        "type": "self"
    },
    "last_finalization_error": null,
    "latest_revision": null,
    "lines": {
        "object": "list",
        "data": [
            {
                "id": "il_1RO5QgP71JLI6sb9L5auB3lj",
                "object": "line_item",
                "amount": 1500,
                "currency": "eur",
                "description": "1 × Test App (at €15.00 / year)",
                "discount_amounts": [],
                "discountable": true,
                "discounts": [],
                "invoice": "in_1RO5QgP71JLI6sb9HSRdDSiW",
                "livemode": false,
                "metadata": [],
                "parent": {
                    "invoice_item_details": null,
                    "subscription_item_details": {
                        "invoice_item": null,
                        "proration": false,
                        "proration_details": {
                            "credited_items": null
                        },
                        "subscription": "sub_1RO5QfP71JLI6sb9EKIosSQS",
                        "subscription_item": "si_SIgoQLiytr2oW7"
                    },
                    "type": "subscription_item_details"
                },
                "period": {
                    "end": 1778627196,
                    "start": 1747091196
                },
                "pretax_credit_amounts": [],
                "pricing": {
                    "price_details": {
                        "price": "price_1RLNsHP71JLI6sb9ez8HJsHt",
                        "product": "prod_SFsxoaHLKoYbKj"
                    },
                    "type": "price_details",
                    "unit_amount_decimal": "1500"
                },
                "quantity": 1,
                "taxes": []
            }
        ],
        "has_more": false,
        "total_count": 1,
        "url": "/v1/invoices/in_1RO5QgP71JLI6sb9HSRdDSiW/lines"
    },
    "livemode": false,
    "metadata": [],
    "next_payment_attempt": null,
    "number": "98CD073B-0046",
    "on_behalf_of": null,
    "parent": {
        "quote_details": null,
        "subscription_details": {
            "metadata": [],
            "subscription": "sub_1RO5QfP71JLI6sb9EKIosSQS"
        },
        "type": "subscription_details"
    },
    "payment_settings": {
        "default_mandate": null,
        "payment_method_options": {
            "acss_debit": null,
            "bancontact": null,
            "card": {
                "request_three_d_secure": "automatic"
            },
            "customer_balance": null,
            "konbini": null,
            "sepa_debit": null,
            "us_bank_account": null
        },
        "payment_method_types": [
            "card"
        ]
    },
    "period_end": 1747091196,
    "period_start": 1747091196,
    "post_payment_credit_notes_amount": 0,
    "pre_payment_credit_notes_amount": 0,
    "receipt_number": null,
    "rendering": null,
    "shipping_cost": null,
    "shipping_details": null,
    "starting_balance": 0,
    "statement_descriptor": null,
    "status": "paid",
    "status_transitions": {
        "finalized_at": 1747091196,
        "marked_uncollectible_at": null,
        "paid_at": 1747091196,
        "voided_at": null
    },
    "subtotal": 1500,
    "subtotal_excluding_tax": 1500,
    "test_clock": null,
    "total": 1500,
    "total_discount_amounts": [],
    "total_excluding_tax": 1500,
    "total_pretax_credit_amounts": [],
    "total_taxes": [],
    "webhooks_delivered_at": null
}
                                            </code></pre>
                            </div>

                            <div class="mt-3 alert alert-info">
                                <i class="fas fa-lightbulb"></i> <strong>Implementación en StripeLabApp:</strong> Utilizamos este evento para actualizar los registros de pago, enviar recibos a los clientes, y extender el período de acceso a servicios en suscripciones.
                            </div>
                        </div>

                        <!-- Other invoice events (brief mention) -->
                        <div class="event-details">
                            <h5>Otros eventos de facturación</h5>
                            <div class="alert alert-secondary">
                                <i class="fas fa-list-ul"></i> <strong>Descripción:</strong> Stripe genera varios eventos adicionales relacionados con facturas que pueden ser útiles en casos específicos:
                                <ul>
                                    <li><code>invoice.payment_failed</code>: Se dispara cuando falla el pago de una factura. Útil para notificar a los clientes y gestionar reintentos.</li>
                                    <li><code>invoice.finalized</code>: Se dispara cuando una factura se finaliza y está lista para ser pagada.</li>
                                    <li><code>invoice.upcoming</code>: Se dispara una hora antes de que Stripe genere una factura próxima. Útil para realizar validaciones previas.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Subscription Events -->
                <div class="card mb-4">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0">Suscripciones (Subscriptions)</h5>
                    </div>
                    <div class="card-body">
                        <p>
                            Los eventos de suscripciones son fundamentales para gestionar el ciclo de vida de las suscripciones en tu aplicación, desde la creación hasta la cancelación.
                        </p>

                        <!-- customer.subscription.created -->
                        <div class="event-details mb-4">
                            <h5><code>customer.subscription.created</code></h5>
                            <div class="alert alert-success">
                                <i class="fas fa-calendar-check"></i> <strong>Descripción:</strong> Se dispara cuando se crea una nueva suscripción para un cliente, generalmente después de un pago exitoso mediante Checkout o cuando se crea mediante API.
                            </div>
                            <p>
                                El payload contiene toda la información sobre la nueva suscripción, incluyendo:
                            </p>
                            <ul>
                                <li>El plan y precio asociados (<code>plan</code>, <code>items</code>)</li>
                                <li>Datos del ciclo de facturación (<code>billing_cycle_anchor</code>, <code>current_period_start</code>, <code>current_period_end</code>)</li>
                                <li>El estado de la suscripción (<code>status</code>)</li>
                                <li>El método de pago predeterminado (<code>default_payment_method</code>)</li>
                            </ul>

                            <p><strong>Payload de Ejemplo:</strong></p>
                            <div class="code-snippet">
                                            <pre><code class="language-json">
{
    "id": "sub_1RO5QfP71JLI6sb9EKIosSQS",
    "object": "subscription",
    "application": null,
    "application_fee_percent": null,
    "automatic_tax": {
        "disabled_reason": null,
        "enabled": false,
        "liability": null
    },
    "billing_cycle_anchor": 1747091196,
    "billing_cycle_anchor_config": null,
    "cancel_at": null,
    "cancel_at_period_end": false,
    "canceled_at": null,
    "cancellation_details": {
        "comment": null,
        "feedback": null,
        "reason": null
    },
    "collection_method": "charge_automatically",
    "created": 1747091196,
    "currency": "eur",
    "customer": "cus_SIgoJvUF0ooe7U",
    "days_until_due": null,
    "default_payment_method": "pm_1RO5QdP71JLI6sb9E6WLHpfW",
    "default_source": null,
    "default_tax_rates": [],
    "description": null,
    "discounts": [],
    "ended_at": null,
    "invoice_settings": {
        "account_tax_ids": null,
        "issuer": {
            "type": "self"
        }
    },
    "items": {
        "object": "list",
        "data": [
            {
                "id": "si_SIgoQLiytr2oW7",
                "object": "subscription_item",
                "created": 1747091196,
                "current_period_end": 1778627196,
                "current_period_start": 1747091196,
                "discounts": [],
                "metadata": [],
                "plan": {
                    "id": "price_1RLNsHP71JLI6sb9ez8HJsHt",
                    "object": "plan",
                    "active": true,
                    "amount": 1500,
                    "amount_decimal": "1500",
                    "billing_scheme": "per_unit",
                    "created": 1746447117,
                    "currency": "eur",
                    "interval": "year",
                    "interval_count": 1,
                    "livemode": false,
                    "metadata": [],
                    "meter": null,
                    "nickname": "Annual payment of the Test Surlabs product",
                    "product": "prod_SFsxoaHLKoYbKj",
                    "tiers_mode": null,
                    "transform_usage": null,
                    "trial_period_days": null,
                    "usage_type": "licensed"
                },
                "price": {
                    "id": "price_1RLNsHP71JLI6sb9ez8HJsHt",
                    "object": "price",
                    "active": true,
                    "billing_scheme": "per_unit",
                    "created": 1746447117,
                    "currency": "eur",
                    "custom_unit_amount": null,
                    "livemode": false,
                    "lookup_key": "annual_payment",
                    "metadata": [],
                    "nickname": "Annual payment of the Test Surlabs product",
                    "product": "prod_SFsxoaHLKoYbKj",
                    "recurring": {
                        "interval": "year",
                        "interval_count": 1,
                        "meter": null,
                        "trial_period_days": null,
                        "usage_type": "licensed"
                    },
                    "tax_behavior": "unspecified",
                    "tiers_mode": null,
                    "transform_quantity": null,
                    "type": "recurring",
                    "unit_amount": 1500,
                    "unit_amount_decimal": "1500"
                },
                "quantity": 1,
                "subscription": "sub_1RO5QfP71JLI6sb9EKIosSQS",
                "tax_rates": []
            }
        ],
        "has_more": false,
        "total_count": 1,
        "url": "/v1/subscription_items?subscription=sub_1RO5QfP71JLI6sb9EKIosSQS"
    },
    "latest_invoice": "in_1RO5QgP71JLI6sb9HSRdDSiW",
    "livemode": false,
    "metadata": [],
    "next_pending_invoice_item_invoice": null,
    "on_behalf_of": null,
    "pause_collection": null,
    "payment_settings": {
        "payment_method_options": {
            "acss_debit": null,
            "bancontact": null,
            "card": {
                "network": null,
                "request_three_d_secure": "automatic"
            },
            "customer_balance": null,
            "konbini": null,
            "sepa_debit": null,
            "us_bank_account": null
        },
        "payment_method_types": [
            "card"
        ],
        "save_default_payment_method": "off"
    },
    "pending_invoice_item_interval": null,
    "pending_setup_intent": null,
    "pending_update": null,
    "plan": {
        "id": "price_1RLNsHP71JLI6sb9ez8HJsHt",
        "object": "plan",
        "active": true,
        "amount": 1500,
        "amount_decimal": "1500",
        "billing_scheme": "per_unit",
        "created": 1746447117,
        "currency": "eur",
        "interval": "year",
        "interval_count": 1,
        "livemode": false,
        "metadata": [],
        "meter": null,
        "nickname": "Annual payment of the Test Surlabs product",
        "product": "prod_SFsxoaHLKoYbKj",
        "tiers_mode": null,
        "transform_usage": null,
        "trial_period_days": null,
        "usage_type": "licensed"
    },
    "quantity": 1,
    "schedule": null,
    "start_date": 1747091196,
    "status": "active",
    "test_clock": null,
    "transfer_data": null,
    "trial_end": null,
    "trial_settings": {
        "end_behavior": {
            "missing_payment_method": "create_invoice"
        }
    },
    "trial_start": null
}
                                            </code></pre>
                            </div>

                            <div class="mt-3 alert alert-info">
                                <i class="fas fa-lightbulb"></i> <strong>Implementación en StripeLabApp:</strong> Utilizamos este evento para crear un nuevo registro de suscripción en nuestra base de datos, y activar el acceso del usuario a las funcionalidades de suscripción.
                            </div>
                        </div>

                        <!-- customer.subscription.updated -->
                        <div class="event-details mb-4">
                            <h5><code>customer.subscription.updated</code></h5>
                            <div class="alert alert-info">
                                <i class="fas fa-sync"></i> <strong>Descripción:</strong> Se dispara cuando se actualiza algún aspecto de la suscripción, como el plan, la cantidad, el método de pago, o cuando se programa una cancelación futura mediante <code>cancel_at_period_end</code>.
                            </div>
                            <p>
                                Este evento es particularmente importante para detectar:
                            </p>
                            <ul>
                                <li>Cambios de plan (actualizaciones/degradaciones)</li>
                                <li>Cancelaciones programadas (<code>cancel_at_period_end: true</code>)</li>
                                <li>Cambios en el estado de la suscripción (<code>status</code>)</li>
                                <li>Actualizaciones del método de pago</li>
                            </ul>

                            <p><strong>Payload de Ejemplo (para <code>cancel_at_period_end</code>):</strong></p>
                            <div class="code-snippet">
                                            <pre><code class="language-json">
{
    "id": "sub_1RO5PaP71JLI6sb9JeUmU3lZ",
    "object": "subscription",
    "application": null,
    "application_fee_percent": null,
    "automatic_tax": {
        "disabled_reason": null,
        "enabled": false,
        "liability": null
    },
    "billing_cycle_anchor": 1747091129,
    "billing_cycle_anchor_config": null,
    "cancel_at": 1778627129,
    "cancel_at_period_end": true,
    "canceled_at": 1747091360,
    "cancellation_details": {
        "comment": null,
        "feedback": null,
        "reason": "cancellation_requested"
    },
    "collection_method": "charge_automatically",
    "created": 1747091129,
    "currency": "eur",
    "customer": "cus_SIgnD5ZnJtFkKF",
    "days_until_due": null,
    "default_payment_method": "pm_1RO5PYP71JLI6sb9WmxI8bzK",
    "default_source": null,
    "default_tax_rates": [],
    "description": null,
    "discounts": [],
    "ended_at": null,
    "invoice_settings": {
        "account_tax_ids": null,
        "issuer": {
            "type": "self"
        }
    },
    "items": {
        "object": "list",
        "data": [
            {
                "id": "si_SIgnlukijBew1r",
                "object": "subscription_item",
                "created": 1747091129,
                "current_period_end": 1778627129,
                "current_period_start": 1747091129,"discounts": [],
                "metadata": [],
                "plan": {
                    "id": "price_1RLNsHP71JLI6sb9ez8HJsHt",
                    "object": "plan",
                    "active": true,
                    "amount": 1500,
                    "amount_decimal": "1500",
                    "billing_scheme": "per_unit",
                    "created": 1746447117,
                    "currency": "eur",
                    "interval": "year",
                    "interval_count": 1,
                    "livemode": false,
                    "metadata": [],
                    "meter": null,
                    "nickname": "Annual payment of the Test Surlabs product",
                    "product": "prod_SFsxoaHLKoYbKj",
                    "tiers_mode": null,
                    "transform_usage": null,
                    "trial_period_days": null,
                    "usage_type": "licensed"
                },
                "price": {
                    "id": "price_1RLNsHP71JLI6sb9ez8HJsHt",
                    "object": "price",
                    "active": true,
                    "billing_scheme": "per_unit",
                    "created": 1746447117,
                    "currency": "eur",
                    "custom_unit_amount": null,
                    "livemode": false,
                    "lookup_key": "annual_payment",
                    "metadata": [],
                    "nickname": "Annual payment of the Test Surlabs product",
                    "product": "prod_SFsxoaHLKoYbKj",
                    "recurring": {
                        "interval": "year",
                        "interval_count": 1,
                        "meter": null,
                        "trial_period_days": null,
                        "usage_type": "licensed"
                    },
                    "tax_behavior": "unspecified",
                    "tiers_mode": null,
                    "transform_quantity": null,
                    "type": "recurring",
                    "unit_amount": 1500,
                    "unit_amount_decimal": "1500"
                },
                "quantity": 1,
                "subscription": "sub_1RO5PaP71JLI6sb9JeUmU3lZ",
                "tax_rates": []
            }
        ],
        "has_more": false,
        "total_count": 1,
        "url": "/v1/subscription_items?subscription=sub_1RO5PaP71JLI6sb9JeUmU3lZ"
    },
    "latest_invoice": "in_1RO5PaP71JLI6sb9hSZVU0YK",
    "livemode": false,
    "metadata": [],
    "next_pending_invoice_item_invoice": null,
    "on_behalf_of": null,
    "pause_collection": null,
    "payment_settings": {
        "payment_method_options": {
            "acss_debit": null,
            "bancontact": null,
            "card": {
                "network": null,
                "request_three_d_secure": "automatic"
            },
            "customer_balance": null,
            "konbini": null,
            "sepa_debit": null,
            "us_bank_account": null
        },
        "payment_method_types": [
            "card"
        ],
        "save_default_payment_method": "off"
    },
    "pending_invoice_item_interval": null,
    "pending_setup_intent": null,
    "pending_update": null,
    "plan": {
        "id": "price_1RLNsHP71JLI6sb9ez8HJsHt",
        "object": "plan",
        "active": true,
        "amount": 1500,
        "amount_decimal": "1500",
        "billing_scheme": "per_unit",
        "created": 1746447117,
        "currency": "eur",
        "interval": "year",
        "interval_count": 1,
        "livemode": false,
        "metadata": [],
        "meter": null,
        "nickname": "Annual payment of the Test Surlabs product",
        "product": "prod_SFsxoaHLKoYbKj",
        "tiers_mode": null,
        "transform_usage": null,
        "trial_period_days": null,
        "usage_type": "licensed"
    },
    "quantity": 1,
    "schedule": null,
    "start_date": 1747091129,
    "status": "active",
    "test_clock": null,
    "transfer_data": null,
    "trial_end": null,
    "trial_settings": {
        "end_behavior": {
            "missing_payment_method": "create_invoice"
        }
    },
    "trial_start": null
}
                                            </code></pre>
                            </div>

                            <div class="mt-3 alert alert-info">
                                <i class="fas fa-lightbulb"></i> <strong>Implementación en StripeLabApp:</strong> Este evento desencadena actualizaciones en nuestros registros de suscripción, ajustes en los permisos de usuario, y si es necesario, envía notificaciones sobre cambios en el estado de la suscripción.
                            </div>
                        </div>

                        <!-- customer.subscription.deleted -->
                        <div class="event-details mb-4">
                            <h5><code>customer.subscription.deleted</code></h5>
                            <div class="alert alert-danger">
                                <i class="fas fa-calendar-times"></i> <strong>Descripción:</strong> Se dispara cuando una suscripción es cancelada inmediatamente (no al final del periodo). Este evento indica que la suscripción ha finalizado y el cliente ya no tiene acceso a los servicios.
                            </div>
                            <p>
                                Es importante diferenciar entre:
                            </p>
                            <ul>
                                <li>Cancelación inmediata: genera este evento y el campo <code>status</code> cambia a "canceled"</li>
                                <li>Cancelación al final del periodo: genera primero un evento <code>customer.subscription.updated</code> con <code>cancel_at_period_end: true</code> y posteriormente, al llegar el final del periodo, un evento <code>customer.subscription.deleted</code></li>
                            </ul>

                            <p><strong>Payload de Ejemplo (cancelación inmediata):</strong></p>
                            <div class="code-snippet">
                                            <pre><code class="language-json">
{
    "id": "sub_1RO5QfP71JLI6sb9EKIosSQS",
    "object": "subscription",
    "application": null,
    "application_fee_percent": null,
    "automatic_tax": {
        "disabled_reason": null,
        "enabled": false,
        "liability": null
    },
    "billing_cycle_anchor": 1747091196,
    "billing_cycle_anchor_config": null,
    "cancel_at": null,
    "cancel_at_period_end": false,
    "canceled_at": 1747091349,
    "cancellation_details": {
        "comment": null,
        "feedback": null,
        "reason": "cancellation_requested"
    },
    "collection_method": "charge_automatically",
    "created": 1747091196,
    "currency": "eur",
    "customer": "cus_SIgoJvUF0ooe7U",
    "days_until_due": null,
    "default_payment_method": "pm_1RO5QdP71JLI6sb9E6WLHpfW",
    "default_source": null,
    "default_tax_rates": [],
    "description": null,
    "discounts": [],
    "ended_at": 1747091349,
    "invoice_settings": {
        "account_tax_ids": null,
        "issuer": {
            "type": "self"
        }
    },
    "items": {
        "object": "list",
        "data": [
            {
                "id": "si_SIgoQLiytr2oW7",
                "object": "subscription_item",
                "created": 1747091196,
                "current_period_end": 1778627196,
                "current_period_start": 1747091196,
                "discounts": [],
                "metadata": [],
                "plan": {
                    "id": "price_1RLNsHP71JLI6sb9ez8HJsHt",
                    "object": "plan",
                    "active": true,
                    "amount": 1500,
                    "amount_decimal": "1500",
                    "billing_scheme": "per_unit",
                    "created": 1746447117,
                    "currency": "eur",
                    "interval": "year",
                    "interval_count": 1,
                    "livemode": false,
                    "metadata": [],
                    "meter": null,
                    "nickname": "Annual payment of the Test Surlabs product",
                    "product": "prod_SFsxoaHLKoYbKj",
                    "tiers_mode": null,
                    "transform_usage": null,
                    "trial_period_days": null,
                    "usage_type": "licensed"
                },
                "price": {
                    "id": "price_1RLNsHP71JLI6sb9ez8HJsHt",
                    "object": "price",
                    "active": true,
                    "billing_scheme": "per_unit",
                    "created": 1746447117,
                    "currency": "eur",
                    "custom_unit_amount": null,
                    "livemode": false,
                    "lookup_key": "annual_payment",
                    "metadata": [],
                    "nickname": "Annual payment of the Test Surlabs product",
                    "product": "prod_SFsxoaHLKoYbKj",
                    "recurring": {
                        "interval": "year",
                        "interval_count": 1,
                        "meter": null,
                        "trial_period_days": null,
                        "usage_type": "licensed"
                    },
                    "tax_behavior": "unspecified",
                    "tiers_mode": null,
                    "transform_quantity": null,
                    "type": "recurring",
                    "unit_amount": 1500,
                    "unit_amount_decimal": "1500"
                },
                "quantity": 1,
                "subscription": "sub_1RO5QfP71JLI6sb9EKIosSQS",
                "tax_rates": []
            }
        ],
        "has_more": false,
        "total_count": 1,
        "url": "/v1/subscription_items?subscription=sub_1RO5QfP71JLI6sb9EKIosSQS"
    },
    "latest_invoice": "in_1RO5QgP71JLI6sb9HSRdDSiW",
    "livemode": false,
    "metadata": [],
    "next_pending_invoice_item_invoice": null,
    "on_behalf_of": null,
    "pause_collection": null,
    "payment_settings": {
        "payment_method_options": {
            "acss_debit": null,
            "bancontact": null,
            "card": {
                "network": null,
                "request_three_d_secure": "automatic"
            },
            "customer_balance": null,
            "konbini": null,
            "sepa_debit": null,
            "us_bank_account": null
        },
        "payment_method_types": [
            "card"
        ],
        "save_default_payment_method": "off"
    },
    "pending_invoice_item_interval": null,
    "pending_setup_intent": null,
    "pending_update": null,
    "plan": {
        "id": "price_1RLNsHP71JLI6sb9ez8HJsHt",
        "object": "plan",
        "active": true,
        "amount": 1500,
        "amount_decimal": "1500",
        "billing_scheme": "per_unit",
        "created": 1746447117,
        "currency": "eur",
        "interval": "year",
        "interval_count": 1,
        "livemode": false,
        "metadata": [],
        "meter": null,
        "nickname": "Annual payment of the Test Surlabs product",
        "product": "prod_SFsxoaHLKoYbKj",
        "tiers_mode": null,
        "transform_usage": null,
        "trial_period_days": null,
        "usage_type": "licensed"
    },
    "quantity": 1,
    "schedule": null,
    "start_date": 1747091196,
    "status": "canceled",
    "test_clock": null,
    "transfer_data": null,
    "trial_end": null,
    "trial_settings": {
        "end_behavior": {
            "missing_payment_method": "create_invoice"
        }
    },
    "trial_start": null
}
                                            </code></pre>
                            </div>

                            <div class="mt-3 alert alert-info">
                                <i class="fas fa-lightbulb"></i> <strong>Implementación en StripeLabApp:</strong> Este evento desencadena la actualización de estado de suscripción en nuestra base de datos, revoca el acceso a funcionalidades premium, y notifica al usuario sobre la cancelación efectiva.
                            </div>
                        </div>

                        <!-- customer.subscription.trial_will_end (brief mention) -->
                        <div class="event-details">
                            <h5><code>customer.subscription.trial_will_end</code></h5>
                            <div class="alert alert-warning">
                                <i class="fas fa-hourglass-end"></i> <strong>Descripción:</strong> Se dispara tres días antes de que finalice el periodo de prueba de una suscripción. Este evento permite notificar proactivamente a los usuarios que su tarjeta será cobrada pronto, reduciendo las sorpresas y posibles disputas.
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Product and Price Events -->
                <div class="card mb-4">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0">Productos y Precios (Informativo)</h5>
                    </div>
                    <div class="card-body">
                        <p>
                            Los eventos de Productos y Precios generalmente no se procesan activamente en la mayoría de las aplicaciones, ya que estos objetos suelen gestionarse manualmente a través del panel de control de Stripe o mediante scripts de configuración.
                        </p>

                        <div class="alert alert-info">
                            <i class="fas fa-info-circle"></i> <strong>Eventos disponibles:</strong>
                            <ul>
                                <li><code>product.created</code> y <code>product.updated</code>: Se disparan cuando se crea o actualiza un producto en Stripe.</li>
                                <li><code>price.created</code> y <code>price.updated</code>: Se disparan cuando se crea o actualiza un precio en Stripe.</li>
                            </ul>
                            <p>En StripeLabApp, no procesamos activamente estos eventos, ya que nuestros productos y precios se configuran manualmente o mediante scripts de despliegue. Sin embargo, podrían ser útiles para sincronizar catálogos de productos entre Stripe y sistemas de gestión de inventarios o CRM.</p>
                        </div>
                    </div>
                </div>


    <div id="orden-eventos" class="subsection">
        <h4>3.4. Orden de los Eventos y Flujos Comunes</h4>
        <p>
            Stripe envía eventos en el orden en que ocurren en su sistema, pero debido a la naturaleza asíncrona de los webhooks, es importante diseñar tu aplicación para manejar eventos que puedan llegar en cualquier orden o incluso duplicados.
        </p>

        <div class="alert alert-warning mb-4">
            <i class="fas fa-exclamation-triangle"></i> <strong>Importante:</strong> Nunca asumas un orden específico de eventos. Diseña tu sistema para ser resiliente ante eventos fuera de secuencia o duplicados, y siempre implementa la idempotencia en tus manejadores de eventos.
        </div>

        <p>
            A continuación, se muestran los flujos de eventos más comunes en Stripe, pero recuerda que estos diagramas representan el orden <em>habitual</em>, no garantizado.
        </p>

        <!-- Flujo de Nueva Suscripción -->
        <div class="card mb-4">
            <div class="card-header">
                <strong>Flujo de Eventos: Nueva Suscripción</strong>
            </div>
            <div class="card-body">
                <p>Este flujo representa el proceso completo desde que un cliente selecciona un plan de suscripción hasta que se confirma y activa la suscripción.</p>

                <div class="mermaid-diagram">
                                        <pre class="mermaid">
                                            sequenceDiagram
                                                participant User
                                                participant FrontendApp as StripeLabApp Frontend
                                                participant BackendApp as StripeLabApp Backend
                                                participant Stripe
                                                User->>FrontendApp: Selecciona Plan de Suscripción
                                                FrontendApp->>BackendApp: Solicita crear Checkout Session (via /v1/create_subscription_session.php)
                                                BackendApp->>Stripe: POST /v1/checkout/sessions
                                                Stripe-->>BackendApp: Checkout Session ID
                                                BackendApp-->>FrontendApp: Checkout Session ID
                                                FrontendApp->>Stripe: redirectToCheckout(sessionId)
                                                User->>Stripe: Completa Formulario de Pago
                                                Stripe-->>User: Redirige a success_url
                                                Stripe-->>BackendApp: Webhook: checkout.session.completed
                                                Stripe-->>BackendApp: Webhook: customer.created (si nuevo)
                                                Stripe-->>BackendApp: Webhook: payment_intent.succeeded (pago inicial)
                                                Stripe-->>BackendApp: Webhook: invoice.paid (primera factura)
                                                Stripe-->>BackendApp: Webhook: customer.subscription.created
                                                BackendApp->>BackendApp: Procesa eventos con Estrategias
                                                BackendApp->>Database: Guarda/Actualiza Suscripción y Transacción
                                        </pre>
                </div>

                <div class="alert alert-info mt-3">
                    <i class="fas fa-lightbulb"></i> <strong>Consejo:</strong> En StripeLabApp, el evento <code>checkout.session.completed</code> se utiliza como punto de entrada principal para activar la suscripción, mientras que los demás eventos se utilizan para actualizar información adicional y confirmar el estado.
                </div>
            </div>
        </div>

        <!-- Flujo de Pago Único -->
        <div class="card mb-4">
            <div class="card-header">
                <strong>Flujo de Eventos: Pago Único</strong>
            </div>
            <div class="card-body">
                <p>Este flujo representa el proceso de un pago único, desde la selección del producto hasta la confirmación de la transacción.</p>

                <div class="mermaid-diagram">
                                        <pre class="mermaid">
sequenceDiagram
    participant User
    participant FrontendApp as StripeLabApp Frontend
    participant BackendApp as StripeLabApp Backend
    participant Stripe
    User->>FrontendApp: Selecciona Producto Pago Único
    FrontendApp->>BackendApp: Solicita crear Checkout Session (via /v1/create_payment_session.php)
    BackendApp->>Stripe: POST /v1/checkout/sessions
    Stripe-->>BackendApp: Checkout Session ID
    BackendApp-->>FrontendApp: Checkout Session ID
    FrontendApp->>Stripe: redirectToCheckout(sessionId)
    User->>Stripe: Completa Formulario de Pago
    Stripe-->>User: Redirige a success_url
    Stripe-->>BackendApp: Webhook: checkout.session.completed
    Stripe-->>BackendApp: Webhook: payment_intent.succeeded
    Stripe-->>BackendApp: Webhook: charge.succeeded
    BackendApp->>BackendApp: Procesa eventos con Estrategias
    BackendApp->>Database: Guarda Transacción
                                        </pre>
                </div>

                <div class="alert alert-info mt-3">
                    <i class="fas fa-lightbulb"></i> <strong>Consejo:</strong> En los pagos únicos, utilizamos el evento <code>checkout.session.completed</code> como principal desencadenante para registrar la transacción y proporcionar acceso al producto o servicio, mientras que <code>charge.succeeded</code> se utiliza para obtener el <code>receipt_url</code> y otros detalles específicos del cargo.
                </div>
            </div>
        </div>

        <div class="alert alert-success">
            <i class="fas fa-check-circle"></i> <strong>Mejor práctica:</strong> Al diseñar tu sistema de manejo de webhooks, enfócate en la <em>idempotencia</em> y en el <em>estado final deseado</em> en lugar de depender de un orden específico de eventos. Esto garantizará que tu aplicación sea robusta ante posibles retrasos o reintentos en la entrega de eventos.
        </div>
    </div>
    </section>

    <!-- Sección 4 - Stripe CLI -->
    <section id="stripecli" class="mb-4">
        <h3>4. Stripe CLI: Herramienta Esencial para Desarrollo y Pruebas</h3>

        <div id="que-es-stripecli" class="subsection">
            <h4>4.1. ¿Qué es Stripe CLI y por qué es útil?</h4>
            <p>
                Stripe CLI (Command Line Interface) es una herramienta oficial de Stripe que simplifica significativamente el desarrollo y las pruebas de integraciones con Stripe, especialmente cuando se trabaja con webhooks.
            </p>

            <div class="row mb-4">
                <div class="col-md-6">
                    <div class="card h-100">
                        <div class="card-header">
                            <strong>Funcionalidades principales</strong>
                        </div>
                        <div class="card-body">
                            <ul>
                                <li><strong>Reenvío de webhooks:</strong> Recibe eventos de Stripe y los reenvía a tu servidor local.</li>
                                <li><strong>Activador de eventos:</strong> Genera eventos de prueba sin necesidad de realizar acciones reales en el panel.</li>
                                <li><strong>Interacción con API:</strong> Realiza llamadas a la API de Stripe directamente desde la línea de comandos.</li>
                                <li><strong>Logs en tiempo real:</strong> Visualiza y filtra los eventos que ocurren en tu cuenta de Stripe.</li>
                                <li><strong>Depuración:</strong> Diagnostica problemas comunes en la integración.</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="col-md-6">
                    <div class="card h-100">
                        <div class="card-header">
                            <strong>Beneficios para el desarrollo</strong>
                        </div>
                        <div class="card-body">
                            <ul>
                                <li><strong>Desarrollo local:</strong> Prueba webhooks sin exponer tu localhost a internet ni configurar túneles.</li>
                                <li><strong>Ciclo de retroalimentación rápido:</strong> Observa inmediatamente cómo tu aplicación maneja los eventos.</li>
                                <li><strong>Simulación completa:</strong> Prueba flujos completos desde el pago hasta el webhook sin procesar pagos reales.</li>
                                <li><strong>Automatización:</strong> Integra Stripe CLI en scripts y pipelines de CI/CD.</li>
                                <li><strong>Documentación interactiva:</strong> Explora la API y sus respuestas en tiempo real.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Aquí termina la sección anterior -->
            <p>
                <strong>Instalación:</strong> Stripe CLI está disponible para Windows, macOS y Linux. La instalación es sencilla:
            </p>
            <ul>
                <li><strong>macOS (con Homebrew):</strong> <code>brew install stripe/stripe-cli/stripe</code></li>
                <li><strong>Windows (con scoop):</strong> <code>scoop bucket add stripe https://github.com/stripe/scoop-stripe-cli.git</code> seguido de <code>scoop install stripe</code></li>
                <li><strong>Linux:</strong> Descarga el binario desde <a href="https://github.com/stripe/stripe-cli/releases" target="_blank">GitHub</a></li>
            </ul>

            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i> <strong>Nota:</strong> Para instrucciones detalladas, visita la <a href="https://stripe.com/docs/stripe-cli" target="_blank">documentación oficial</a>.
            </div>
        </div>

        <div id="configuracion-stripecli" class="subsection">
            <h4>4.2. Configuración y Autenticación</h4>
            <p>
                Antes de poder utilizar Stripe CLI, necesitas autenticarte con tu cuenta de Stripe. Este proceso es seguro y permite a la CLI acceder a tu cuenta con los permisos adecuados.
            </p>

            <div class="card mb-4">
                <div class="card-header">
                    <strong>Proceso de autenticación</strong>
                </div>
                <div class="card-body">
                    <ol>
                        <li>
                            <strong>Iniciar el proceso de login:</strong>
                            <p>Ejecuta el siguiente comando en tu terminal:</p>
                            <div class="code-snippet">
                                <pre><code class="language-bash">stripe login</code></pre>
                            </div>
                        </li>
                        <li>
                            <strong>Autorizar en el navegador:</strong>
                            <p>Se abrirá una página en tu navegador donde deberás autorizar a Stripe CLI para acceder a tu cuenta.</p>
                        </li>
                        <li>
                            <strong>Verificar la conexión:</strong>
                            <p>Una vez autorizado, verás un mensaje de confirmación en la terminal y puedes verificar la conexión con:</p>
                            <div class="code-snippet">
                                <pre><code class="language-bash">stripe status</code></pre>
                            </div>
                        </li>
                    </ol>

                    <div class="alert alert-warning">
                        <i class="fas fa-lock"></i> <strong>Seguridad:</strong> La autenticación genera un par de claves API restringidas que se almacenan localmente. Estas claves tienen permisos limitados y expiran después de 90 días, por lo que deberás volver a ejecutar <code>stripe login</code> periódicamente.
                    </div>
                </div>
            </div>

            <p>
                <strong>Configuración del modo (test/live):</strong> Por defecto, Stripe CLI opera en modo de prueba (<code>test</code>). Puedes cambiar explícitamente el modo con los modificadores <code>--test</code> o <code>--live</code> en cualquier comando, o configurar el modo predeterminado:
            </p>

            <div class="code-snippet">
                <pre><code class="language-bash"># Establecer modo por defecto
stripe config set default_mode test

# Verificar configuración actual
stripe config list</code></pre>
            </div>

            <div class="alert alert-danger">
                <i class="fas fa-exclamation-triangle"></i> <strong>Precaución:</strong> Utiliza el modo <code>live</code> con extrema precaución, ya que afectará a transacciones reales y datos de clientes en producción.
            </div>
        </div>

        <div id="reenvio-webhooks" class="subsection">
            <h4>4.3. Reenvío de Webhooks y Pruebas Locales</h4>
            <p>
                La funcionalidad más potente de Stripe CLI es su capacidad para reenviar webhooks de Stripe a tu servidor local, eliminando la necesidad de exponer tu entorno de desarrollo a internet o configurar túneles complejos.
            </p>

            <div class="card mb-4">
                <div class="card-header">
                    <strong>Iniciar el reenvío de webhooks</strong>
                </div>
                <div class="card-body">
                    <p>El comando básico para iniciar el reenvío es:</p>
                    <div class="code-snippet">
                        <pre><code class="language-bash">stripe listen --forward-to http://localhost:8000/v1/webhook.php</code></pre>
                    </div>

                    <p>
                        Esto inicia un proceso que:
                    </p>
                    <ol>
                        <li>Se suscribe a todos los eventos de tu cuenta de Stripe en modo de prueba.</li>
                        <li>Recibe los eventos en tiempo real cuando ocurren.</li>
                        <li>Reenvía cada evento a la URL especificada en tu servidor local.</li>
                    </ol>

                    <div class="alert alert-success mt-3">
                        <i class="fas fa-key"></i> <strong>Webhook signing secret:</strong> Al iniciar el reenvío, Stripe CLI genera automáticamente un secreto de firma (signing secret) y lo muestra en la terminal. Debe utilizarse en tu aplicación para verificar que las solicitudes son realmente de Stripe CLI.
                    </div>

                    <p><strong>Opciones útiles para el reenvío:</strong></p>
                    <ul>
                        <li><code>--events="payment_intent.succeeded,customer.subscription.created"</code>: Filtra para recibir solo eventos específicos.</li>
                        <li><code>--skip-verify</code>: Omite la verificación de SSL (útil para certificados autofirmados).</li>
                        <li><code>--latest</code>: Solo reenvía el evento más reciente de cada tipo.</li>
                        <li><code>--log-level=debug</code>: Muestra información detallada para depuración.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <div class="card-header">
                    <strong>Simulación de eventos</strong>
                </div>
                <div class="card-body">
                    <p>
                        Stripe CLI también te permite simular eventos de webhook sin necesidad de realizar acciones reales en el panel de control. Esto es extremadamente útil para probar cómo tu aplicación maneja diferentes escenarios sin procesar pagos de prueba.
                    </p>

                    <p><strong>Comando para activar eventos:</strong></p>
                    <div class="code-snippet">
                        <pre><code class="language-bash"># Estructura general
stripe trigger [evento]

# Ejemplos específicos
stripe trigger payment_intent.succeeded
stripe trigger customer.subscription.created
stripe trigger invoice.payment_failed</code></pre>
                    </div>

                    <p>
                        Al combinar <code>stripe listen</code> en una terminal y <code>stripe trigger</code> en otra, puedes simular todo el flujo de webhooks para probar tu implementación.
                    </p>

                    <div class="alert alert-info">
                        <i class="fas fa-lightbulb"></i> <strong>Consejo:</strong> Puedes personalizar el payload del evento con el modificador <code>--add</code>. Por ejemplo: <code>stripe trigger payment_intent.succeeded --add "payment_intent:amount=2000"</code>.
                    </div>
                </div>
            </div>

            <div class="alert alert-success mb-4">
                <i class="fas fa-check-circle"></i> <strong>Beneficio clave:</strong> El reenvío de webhooks de Stripe CLI hace que el desarrollo y la depuración sean significativamente más rápidos y eficientes, reduciendo el tiempo necesario para verificar que tu aplicación maneja correctamente los eventos de Stripe.
            </div>
        </div>

        <div id="comandos-utiles" class="subsection">
            <h4>4.4. Otros Comandos Útiles para el Desarrollo</h4>
            <p>
                Además del reenvío de webhooks, Stripe CLI ofrece una amplia gama de comandos que pueden facilitar el desarrollo y las pruebas de tu integración.
            </p>

            <div class="table-responsive mb-4">
                <table class="table table-striped table-hover">
                    <thead class="table-primary">
                    <tr>
                        <th>Categoría</th>
                        <th>Comando</th>
                        <th>Descripción</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td rowspan="3"><strong>Exploración de la API</strong></td>
                        <td><code>stripe get /v1/customers</code></td>
                        <td>Lista todos los clientes en tu cuenta.</td>
                    </tr>
                    <tr>
                        <td><code>stripe get /v1/subscriptions/sub_123</code></td>
                        <td>Obtiene detalles de una suscripción específica.</td>
                    </tr>
                    <tr>
                        <td><code>stripe get /v1/events --limit=5</code></td>
                        <td>Lista los 5 eventos más recientes.</td>
                    </tr>
                    <tr>
                        <td rowspan="3"><strong>Creación y modificación</strong></td>
                        <td><code>stripe post /v1/customers -d name="Test Customer"</code></td>
                        <td>Crea un nuevo cliente.</td>
                    </tr>
                    <tr>
                        <td><code>stripe post /v1/refunds -d charge=ch_123</code></td>
                        <td>Reembolsa un cargo específico.</td>
                    </tr>
                    <tr>
                        <td><code>stripe delete /v1/customers/cus_123</code></td>
                        <td>Elimina un cliente (cuando sea posible).</td>
                    </tr>
                    <tr>
                        <td rowspan="2"><strong>Depuración</strong></td>
                        <td><code>stripe logs tail</code></td>
                        <td>Muestra los logs de la API en tiempo real.</td>
                    </tr>
                    <tr>
                        <td><code>stripe logs list</code></td>
                        <td>Lista las solicitudes recientes a la API.</td>
                    </tr>
                    <tr>
                        <td rowspan="2"><strong>Datos de prueba</strong></td>
                        <td><code>stripe fixtures</code></td>
                        <td>Crea un conjunto de objetos de prueba en tu cuenta.</td>
                    </tr>
                    <tr>
                        <td><code>stripe samples create accept-a-card-payment</code></td>
                        <td>Descarga e instala ejemplos de integración.</td>
                    </tr>
                    </tbody>
                </table>
            </div>

            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i> <strong>Lista completa de comandos:</strong> Puedes ver todos los comandos disponibles ejecutando <code>stripe help</code> o consultando la <a href="https://stripe.com/docs/cli/commands" target="_blank">documentación de referencia</a>.
            </div>

            <p>
                En StripeLabApp, utilizamos Stripe CLI principalmente para:
            </p>
            <ul>
                <li>Reenviar webhooks durante el desarrollo con <code>stripe listen</code>.</li>
                <li>Probar diferentes escenarios de evento con <code>stripe trigger</code>.</li>
                <li>Verificar el estado de las suscripciones y transacciones con <code>stripe get</code>.</li>
                <li>Monitorear logs para depurar problemas con <code>stripe logs tail</code>.</li>
            </ul>
        </div>

        <div class="alert alert-success">
            <i class="fas fa-graduation-cap"></i> <strong>Resumen:</strong> Stripe CLI es una herramienta indispensable para los desarrolladores que trabajan con Stripe. Simplifica significativamente el desarrollo local, las pruebas de integración y la depuración, especialmente para webhooks. En StripeLabApp, se ha convertido en una parte esencial de nuestro flujo de trabajo de desarrollo.
        </div>
    </section>
    </section>

    <!-- PARTE II -->
    <section id="parte2" class="mb-5">
        <h2>PARTE II: Arquitectura de StripeLabApp</h2>
        <p class="lead">
            Esta sección explora la arquitectura, configuración y funcionamiento interno de StripeLabApp, nuestra aplicación de demostración para integraciones con Stripe.
        </p>

        <!-- Sección 5 -->
        <section id="introduccion-stripelabapp" class="mb-4">
            <h3>5. Introducción a StripeLabApp</h3>

            <div id="objetivos-proyecto" class="subsection">
                <h4>5.1. Objetivos del Proyecto</h4>
                <p>
                    StripeLabApp nació como un proyecto con múltiples propósitos, enfocados en demostrar las mejores prácticas para integraciones de pago con Stripe:
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Objetivos principales</strong>
                    </div>
                    <div class="card-body">
                        <ul>
                            <li>
                                <strong>Entorno de aprendizaje:</strong> Proporcionar un ejemplo funcional y bien documentado para desarrolladores que buscan implementar pagos en sus aplicaciones.
                            </li>
                            <li>
                                <strong>Demostración de integración completa:</strong> Mostrar cómo implementar correctamente tanto pagos únicos como suscripciones, cubriendo todo el ciclo de vida de las transacciones.
                            </li>
                            <li>
                                <strong>Gestión robusta de webhooks:</strong> Ilustrar las mejores prácticas para procesar eventos de Stripe de manera asíncrona y resiliente.
                            </li>
                            <li>
                                <strong>Arquitectura modular y extensible:</strong> Presentar una estructura de código que sea fácil de entender, mantener y ampliar con nuevas funcionalidades.
                            </li>
                            <li>
                                <strong>Referencia de implementación segura:</strong> Demostrar cómo manejar secretos, verificar firmas de webhook y seguir las recomendaciones de seguridad de Stripe.
                            </li>
                        </ul>
                    </div>
                </div>

                <p>
                    A diferencia de los ejemplos simplificados que se encuentran comúnmente en la documentación, StripeLabApp se ha diseñado como una aplicación más completa que aborda desafíos reales que los desarrolladores enfrentan al implementar sistemas de pago, como la persistencia de datos, la gestión de errores y el manejo de diferentes tipos de eventos.
                </p>

                <div class="alert alert-info">
                    <i class="fas fa-lightbulb"></i> <strong>Nota:</strong> StripeLabApp no pretende ser una solución lista para producción, sino un recurso educativo y un punto de partida para adaptarse a los requisitos específicos de cada proyecto.
                </div>
            </div>

            <div id="funcionalidades-implementadas" class="subsection">
                <h4>5.2. Funcionalidades Implementadas</h4>
                <p>
                    StripeLabApp implementa un conjunto de funcionalidades centradas en la integración con Stripe, con énfasis en los flujos de pago más comunes y su gestión a través de webhooks.
                </p>

                <div class="row mb-4">
                    <div class="col-md-6 mb-3">
                        <div class="card h-100">
                            <div class="card-header bg-success text-white">
                                <strong>Pagos Únicos</strong>
                            </div>
                            <div class="card-body">
                                <ul>
                                    <li>Página de producto con opciones de pago único</li>
                                    <li>Integración con Stripe Checkout para procesamiento seguro de pagos</li>
                                    <li>Manejo de eventos <code>checkout.session.completed</code> y <code>payment_intent.succeeded</code></li>
                                    <li>Registro de transacciones en base de datos</li>
                                    <li>Visualización del historial de pagos</li>
                                    <li>Acceso a recibos generados por Stripe</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="col-md-6 mb-3">
                        <div class="card h-100">
                            <div class="card-header bg-primary text-white">
                                <strong>Suscripciones</strong>
                            </div>
                            <div class="card-body">
                                <ul>
                                    <li>Planes de suscripción mensual y anual</li>
                                    <li>Checkout de suscripción con creación automática de clientes</li>
                                    <li>Procesamiento de eventos de suscripción (<code>customer.subscription.created</code>, <code>invoice.paid</code>, etc.)</li>
                                    <li>Gestión del ciclo de vida de las suscripciones</li>
                                    <li>Visualización de suscripciones activas y su estado</li>
                                    <li>Cancelación de suscripciones (inmediata o al final del periodo)</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="row mb-4">
                    <div class="col-md-6 mb-3">
                        <div class="card h-100">
                            <div class="card-header bg-warning text-dark">
                                <strong>Gestión de Webhooks</strong>
                            </div>
                            <div class="card-body">
                                <ul>
                                    <li>Endpoint único para recibir todos los tipos de eventos</li>
                                    <li>Verificación criptográfica de firmas de webhook</li>
                                    <li>Sistema de estrategias para procesar diferentes tipos de eventos</li>
                                    <li>Manejo de idempotencia para evitar procesamiento duplicado</li>
                                    <li>Logging detallado de eventos recibidos y procesados</li>
                                    <li>Gestión robusta de errores y excepciones</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="col-md-6 mb-3">
                        <div class="card h-100">
                            <div class="card-header bg-info text-white">
                                <strong>Interfaz y Utilidades</strong>
                            </div>
                            <div class="card-body">
                                <ul>
                                    <li>Panel para visualizar facturas y su estado</li>
                                    <li>Panel para gestionar suscripciones activas</li>
                                    <li>Endpoints API para obtener datos de transacciones y suscripciones</li>
                                    <li>Interfaz simple basada en Bootstrap para facilitar la interacción</li>
                                    <li>Mensajes de confirmación y error después de acciones clave</li>
                                    <li>Sistema de logs para depuración y auditoría</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="alert alert-info">
                    <i class="fas fa-info-circle"></i> <strong>Alcance:</strong> StripeLabApp se enfoca en demostrar los aspectos técnicos de la integración con Stripe, por lo que carece de algunas funcionalidades que tendría una aplicación de producción, como autenticación de usuarios, sistemas de roles, o un panel de administración completo.
                </div>
            </div>

            <div id="estructura-directorios" class="subsection">
                <h4>5.3. Estructura de Directorios del Proyecto</h4>
                <p>
                    StripeLabApp sigue una estructura de directorios organizada que separa claramente las diferentes capas y responsabilidades de la aplicación, facilitando la navegación y el mantenimiento del código.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Estructura completa del proyecto</strong>
                    </div>
                    <div class="card-body">
                        <div class="code-snippet">
                        <pre><code class="language-plaintext">
StripeLabApp/
│
├── config/
│   ├── Bootstrap.php
│   └── DatabaseConnection.php
│
├── database/
│   └── tables.txt
│
├── logs/
│
├── public/
│   ├── index.php
│   ├── single-payment.php
│   ├── subscriptions-payment.php
│   ├── view-subscriptions.php
│   ├── invoices.php
│   ├── assets/
│   └── v1/
│       ├── create_payment_session.php
│       ├── create_subscription_session.php
│       ├── webhook.php
│       └── api/
│           ├── api-invoices.php
│           ├── api-subscriptions.php
│           └── api-manage-subscription.php
│
├── src/
│   ├── Controller/
│   │   ├── StripeWebhookController.php
│   │   └── DisplayController.php
│   │
│   ├── Service/
│   │   ├── StripeCheckoutSessionService.php
│   │   ├── StripeWebhookService.php
│   │   ├── StripeEventProcessorService.php
│   │   ├── DisplayService.php
│   │   └── StripeSubscriptionManagementService.php
│   │
│   ├── Strategy/
│   │   ├── StripeEventStrategyInterface.php
│   │   ├── DefaultStripeEventStrategy.php
│   │   ├── CheckoutSessionCompletedStrategy.php
│   │   ├── PaymentIntentSucceededStrategy.php
│   │   ├── InvoicePaidStrategy.php
│   │   └── ... [otras estrategias]
│   │
│   ├── Repository/
│   │   ├── TransactionRepository.php
│   │   └── SubscriptionRepository.php
│   │
│   ├── Mappers/
│   │   ├── TransactionMapper.php
│   │   └── SubscriptionMapper.php
│   │
│   ├── Factories/
│   │   └── StripeEventStrategyFactory.php
│   │
│   ├── Models/
│   │   ├── TransactionsModel.php
│   │   └── SubscriptionsModel.php
│   │
│   ├── DTOs/
│   │   ├── TransactionDTO.php
│   │   ├── SubscriptionDTO.php
│   │   └── InvoiceDTO.php
│   │
│   ├── Enums/
│   │   ├── StripeEventTypeEnum.php
│   │   └── TransactionTypeEnum.php
│   │
│   ├── Exceptions/
│   │   ├── ConfigurationException.php
│   │   ├── DatabaseException.php
│   │   ├── InvalidWebhookPayloadException.php
│   │   └── WebhookProcessingException.php
│   │
│   └── Logger/
│       ├── EventLogger.php
│       ├── ErrorLogger.php
│       ├── DatabaseLogger.php
│       ├── StripePayloadLogger.php
│       └── UnhandledStripeEventLogger.php
│
├── .env.example
├── .gitignore
├── composer.json
└── README.md
                        </code></pre>
                        </div>
                    </div>
                </div>

                <p>
                    Esta estructura refleja un enfoque de arquitectura en capas, donde:
                </p>
                <ul>
                    <li><strong>Interfaz de usuario:</strong> Se encuentra en <code>public/</code> y actúa como punto de entrada para los usuarios.</li>
                    <li><strong>Controladores:</strong> Manejan las solicitudes y coordinan el flujo de la aplicación.</li>
                    <li><strong>Servicios:</strong> Implementan la lógica de negocio principal e interactúan con APIs externas.</li>
                    <li><strong>Repositorios:</strong> Abstracten el acceso a datos y las operaciones con la base de datos.</li>
                    <li><strong>Modelos y DTOs:</strong> Representan las entidades del dominio y facilitan la transferencia de datos entre capas.</li>
                </ul>

                <div class="alert alert-success">
                    <i class="fas fa-check-circle"></i> <strong>Ventajas de esta estructura:</strong> Proporciona una clara separación de responsabilidades, facilita las pruebas unitarias, y permite que la aplicación sea fácilmente extensible con nuevas funcionalidades o adaptaciones.
                </div>
            </div>
        </section>

        <!-- Sección 6 -->
        <section id="configuracion-puesta-marcha" class="mb-4">
            <h3>6. Configuración y Puesta en Marcha de StripeLabApp</h3>

            <div id="requisitos-especificos" class="subsection">
                <h4>6.1. Requisitos Específicos de la Aplicación</h4>
                <p>
                    Antes de instalar y ejecutar StripeLabApp, asegúrate de que tu entorno de desarrollo cumple con los siguientes requisitos:
                </p>

                <div class="row mb-4">
                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header">
                                <strong>Requisitos de software</strong>
                            </div>
                            <div class="card-body">
                                <ul>
                                    <li><strong>PHP 8.1 o superior</strong> con las siguientes extensiones:
                                        <ul>
                                            <li>PDO y PDO_MySQL</li>
                                            <li>cURL</li>
                                            <li>JSON</li>
                                            <li>mbstring</li>
                                        </ul>
                                    </li>
                                    <li><strong>Composer</strong> para gestión de dependencias</li>
                                    <li><strong>MySQL 5.7 o superior</strong> o MariaDB 10.3+</li>
                                    <li><strong>Stripe CLI</strong> para pruebas de webhook (opcional pero recomendado)</li>
                                    <li><strong>Servidor web</strong> (Apache, Nginx) o servidor PHP integrado</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <div class="col-md-6">
                        <div class="card h-100">
                            <div class="card-header">
                                <strong>Requisitos de Stripe</strong>
                            </div>
                            <div class="card-body">
                                <ul>
                                    <li><strong>Cuenta de Stripe</strong>: Necesitarás una cuenta para obtener claves API y configurar webhooks.</li>
                                    <li><strong>Claves API de prueba</strong>:
                                        <ul>
                                            <li>Clave publicable (<code>pk_test_...</code>)</li>
                                            <li>Clave secreta (<code>sk_test_...</code>)</li>
                                        </ul>
                                    </li>
                                    <li><strong>Productos y precios configurados</strong> en tu panel de Stripe:
                                        <ul>
                                            <li>Un producto para pago único</li>
                                            <li>Un producto para suscripción con planes mensual y anual</li>
                                        </ul>
                                    </li>
                                    <li><strong>Webhook endpoint</strong> configurado para desarrollo local o producción</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="alert alert-info">
                    <i class="fas fa-lightbulb"></i> <strong>Recomendación:</strong> Para un entorno de desarrollo fluido, considera utilizar Docker para configurar MySQL y PHP, evitando así conflictos con otros proyectos o versiones instaladas en tu sistema.
                </div>
            </div>

            <div id="guia-instalacion" class="subsection">
                <h4>6.2. Guía de Instalación</h4>
                <p>
                    Sigue estos pasos para configurar StripeLabApp en tu entorno de desarrollo:
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Paso 1: Clonar el repositorio</strong>
                    </div>
                    <div class="card-body">
                        <p>Clona el repositorio de StripeLabApp desde GitHub:</p>
                        <div class="code-snippet">
                        <pre><code class="language-bash">git clone https://github.com/yourusername/StripeLabApp.git
cd StripeLabApp</code></pre>
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Paso 2: Instalar dependencias</strong>
                    </div>
                    <div class="card-body">
                        <p>Utiliza Composer para instalar las dependencias del proyecto:</p>
                        <div class="code-snippet">
                            <pre><code class="language-bash">composer install</code></pre>
                        </div>
                        <p>Esto instalará principalmente:</p>
                        <ul>
                            <li><strong>stripe/stripe-php</strong>: Biblioteca oficial de Stripe para PHP</li>
                            <li><strong>vlucas/phpdotenv</strong>: Para gestionar variables de entorno</li>
                        </ul>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Paso 3: Configurar variables de entorno</strong>
                    </div>
                    <div class="card-body">
                        <p>Crea un archivo <code>.env</code> a partir del ejemplo proporcionado:</p>
                        <div class="code-snippet">
                            <pre><code class="language-bash">cp .env.example .env</code></pre>
                        </div>
                        <p>Edita el archivo <code>.env</code> con tu configuración:</p>
                        <div class="code-snippet">
                        <pre><code class="language-plaintext"># Configuración de la base de datos
DB_HOST=localhost
DB_PORT=3306
DB_NAME=stripelabapp
DB_USER=tu_usuario
DB_PASSWORD=tu_contraseña

# Claves de Stripe (modo de prueba)
STRIPE_SECRET_KEY=sk_test_...
STRIPE_PUBLISHABLE_KEY=pk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...  # Lo obtendrás al configurar el webhook

# IDs de productos y precios (cópialos de tu panel de Stripe)
STRIPE_SINGLE_PAYMENT_PRICE_ID=price_...
STRIPE_MONTHLY_SUBSCRIPTION_PRICE_ID=price_...
STRIPE_ANNUAL_SUBSCRIPTION_PRICE_ID=price_...

# URLs de redirección (ajusta según tu configuración)
SUCCESS_URL=http://localhost:8000/public/success.html
CANCEL_URL=http://localhost:8000/public/cancel.html

# Configuración de logs
LOG_ENABLED=true
LOG_LEVEL=debug  # debug, info, warning, error</code></pre>
                        </div>
                        <div class="alert alert-warning mt-3">
                            <i class="fas fa-exclamation-triangle"></i> <strong>Importante:</strong> Nunca compartas o subas a repositorios públicos tu archivo <code>.env</code> con claves secretas. Asegúrate de que esté incluido en <code>.gitignore</code>.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Paso 4: Configurar la base de datos</strong>
                    </div>
                    <div class="card-body">
                        <p><strong>Opción A: Configuración manual</strong></p>
                        <ol>
                            <li>Crea una base de datos MySQL:
                                <div class="code-snippet">
                                    <pre><code class="language-sql">CREATE DATABASE stripelabapp CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</code></pre>
                                </div>
                            </li>
                            <li>Crea las tablas necesarias ejecutando el script SQL que se encuentra en <code>database/tables.txt</code>:
                                <div class="code-snippet">
                                    <pre><code class="language-bash">mysql -u tu_usuario -p stripelabapp < database/tables.txt</code></pre>
                                </div>
                            </li>
                        </ol>

                        <p><strong>Opción B: Usando Docker (recomendado para desarrollo)</strong></p>
                        <ol>
                            <li>Si tienes Docker instalado, puedes usar el siguiente comando para iniciar un contenedor MySQL:
                                <div class="code-snippet">
                                    <pre><code class="language-bash">docker run --name stripelabapp-mysql -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=stripelabapp -p 3306:3306 -d mysql:8.0</code></pre>
                                </div>
                            </li>
                            <li>Ejecuta el script SQL para crear las tablas:
                                <div class="code-snippet">
                                    <pre><code class="language-bash">docker exec -i stripelabapp-mysql mysql -uroot -proot stripelabapp < database/tables.txt</code></pre>
                                </div>
                            </li>
                        </ol>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Paso 5: Iniciar el servidor</strong>
                    </div>
                    <div class="card-body">
                        <p>Para desarrollo local, puedes utilizar el servidor web incorporado de PHP:</p>
                        <div class="code-snippet">
                        <pre><code class="language-bash">cd public
php -S localhost:8000</code></pre>
                        </div>
                        <p>Ahora puedes acceder a la aplicación en <a href="http://localhost:8000" target="_blank">http://localhost:8000</a></p>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-info-circle"></i> <strong>Nota:</strong> Para un entorno de producción, configura un servidor web como Apache o Nginx y asegúrate de que el directorio <code>public/</code> sea la raíz del sitio web.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Paso 6: Verificar la instalación</strong>
                    </div>
                    <div class="card-body">
                        <p>Verifica que la aplicación esté funcionando correctamente:</p>
                        <ol>
                            <li>Accede a la página principal para ver las opciones de pago.</li>
                            <li>Verifica que no aparezcan errores de conexión a la base de datos.</li>
                            <li>Prueba la conexión a Stripe accediendo a las páginas de pago único o suscripción.</li>
                        </ol>
                        <p>Si encuentras errores, verifica los archivos de log en el directorio <code>logs/</code> para obtener más detalles.</p>
                    </div>
                </div>
            </div>

            <div id="configuracion-webhook" class="subsection">
                <h4>6.3. Configuración del Endpoint de Webhook para StripeLabApp</h4>
                <p>
                    Los webhooks son esenciales para StripeLabApp, ya que permiten recibir y procesar eventos de Stripe de manera asíncrona. Hay dos formas de configurar los webhooks: para desarrollo local con Stripe CLI o para un entorno de producción.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Opción 1: Configuración para desarrollo local con Stripe CLI</strong>
                    </div>
                    <div class="card-body">
                        <p>Esta es la opción más sencilla para desarrollo, ya que no requiere exponer tu servidor local a internet:</p>
                        <ol>
                            <li>Asegúrate de tener Stripe CLI instalado y autenticado (como se explicó en la sección 4).</li>
                            <li>Inicia el reenvío de webhooks a tu servidor local:
                                <div class="code-snippet">
                                    <pre><code class="language-bash">stripe listen --forward-to http://localhost:8000/v1/webhook.php</code></pre>
                                </div>
                            </li>
                            <li>Stripe CLI generará un signing secret que deberás copiar y agregar a tu archivo <code>.env</code>:
                                <div class="code-snippet">
                                    <pre><code class="language-plaintext">STRIPE_WEBHOOK_SECRET=whsec_...</code></pre>
                                </div>
                            </li>
                        </ol>
                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Ventaja:</strong> Con este método, los eventos se reenvían a tu servidor local incluso cuando está detrás de un firewall o NAT, y puedes simular eventos con <code>stripe trigger</code>.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Opción 2: Configuración para producción o servidor público</strong>
                    </div>
                    <div class="card-body">
                        <p>Para un entorno de producción, necesitarás configurar un endpoint de webhook en el panel de Stripe:</p>
                        <ol>
                            <li>Asegúrate de que tu servidor sea accesible desde internet con una URL pública (HTTPS es obligatorio para producción).</li>
                            <li>Ve al <a href="https://dashboard.stripe.com/webhooks" target="_blank">Panel de Webhooks de Stripe</a>.</li>
                            <li>Haz clic en "Añadir endpoint" y configura:
                                <ul>
                                    <li><strong>URL del endpoint:</strong> La URL completa a tu endpoint de webhook (ej: <code>https://tudominio.com/v1/webhook.php</code>)</li>
                                    <li><strong>Versión:</strong> Selecciona la versión más reciente de la API.</li>
                                    <li><strong>Eventos a escuchar:</strong> Selecciona al menos estos eventos:
                                        <ul>
                                            <li><code>checkout.session.completed</code></li>
                                            <li><code>payment_intent.succeeded</code></li>
                                            <li><code>charge.succeeded</code></li>
                                            <li><code>invoice.paid</code></li>
                                            <li><code>customer.subscription.created</code></li>
                                            <li><code>customer.subscription.updated</code></li>
                                            <li><code>customer.subscription.deleted</code></li>
                                        </ul>
                                    </li>
                                </ul>
                            </li>
                            <li>Una vez creado, Stripe te mostrará un signing secret que debes copiar y agregar a tu archivo <code>.env</code>:
                                <div class="code-snippet">
                                    <pre><code class="language-plaintext">STRIPE_WEBHOOK_SECRET=whsec_...</code></pre>
                                </div>
                            </li>
                        </ol>
                        <div class="alert alert-warning mt-3">
                            <i class="fas fa-exclamation-triangle"></i> <strong>Importante:</strong> El signing secret es diferente para cada endpoint de webhook. Asegúrate de usar el correcto según el entorno (desarrollo o producción).
                        </div>
                    </div>
                </div>

                <div class="alert alert-info">
                    <i class="fas fa-lightbulb"></i> <strong>Recomendación:</strong> Durante el desarrollo, es más fácil y rápido utilizar Stripe CLI para webhooks. Para pruebas más avanzadas o cuando necesites comprobar el funcionamiento en un entorno similar a producción, puedes usar servicios como ngrok para exponer temporalmente tu servidor local a internet.
                </div>

                <p>
                    Con estos pasos, StripeLabApp estará configurado y listo para procesar pagos y suscripciones con Stripe. La aplicación recibirá eventos a través del endpoint de webhook y los procesará según las estrategias implementadas.
                </p>
            </div>
        </section>

        <!-- Sección 7 -->
        <section id="arquitectura-detallada" class="mb-4">
            <h3>7. Arquitectura Detallada de StripeLabApp</h3>

            <div id="diagrama-componentes" class="subsection">
                <h4>7.1. Diagrama de Componentes de StripeLabApp</h4>
                <p>
                    El siguiente diagrama muestra la estructura de componentes de StripeLabApp y cómo interactúan entre sí. Esto proporciona una visión general de la arquitectura de la aplicación antes de profundizar en cada capa.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Diagrama de componentes y sus interacciones</strong>
                    </div>
                    <div class="card-body">
                        <div class="mermaid-diagram">
                        <pre class="mermaid">
graph LR
    subgraph "User Interaction"
        direction LR
        UserInterface["Frontend (public/)"]
    end

    subgraph "Application Core (src/)"
        direction TB
        Controllers["Controllers (src/Controller)"]
        Services["Services (src/Service)"]
        Strategies["Strategies (src/Strategy)"]
        MappersFactories["Mappers & Factories (src/Mappers, src/Factories)"]
        Repositories["Repositories (src/Repository)"]
        Commons["Commons (DTOs, Entities, Enums, Exceptions, Loggers)"]
    end

    subgraph "Configuration"
        direction LR
        Bootstrap["config/Bootstrap.php"]
        EnvFile[".env File"]
    end

    subgraph "External Services"
        direction LR
        StripeAPI[("Stripe API")]
        Database[("MySQL DB")]
    end

    UserInterface --> EndpointsApi["Endpoints API (public/v1/api)"]
    UserInterface --> EndpointsCheckout["Endpoints Checkout (public/v1/)"]
    EndpointsApi --> Controllers
    EndpointsCheckout --> Services

    StripeAPI -- Webhooks --> WebhookEndpoint["Webhook Endpoint (public/v1/webhook.php)"]
    WebhookEndpoint --> Controllers

    Controllers --> Services
    Services --> Strategies
    Services --> Repositories  // Directamente para servicios de display/gestión
    Services --> StripeAPI     // Para StripeCheckoutSessionService, StripeSubscriptionManagementService

    Strategies --> MappersFactories
    MappersFactories --> CommonsDtoEntity["DTOs / Entities"]
    Strategies --> Repositories

    Repositories --> Database
    Repositories --> CommonsEntities["Entities"]

    Bootstrap -- Manages/Provides --> Controllers
    Bootstrap -- Manages/Provides --> Services
    Bootstrap -- Manages/Provides --> Strategies
    Bootstrap -- Manages/Provides --> MappersFactories
    Bootstrap -- Manages/Provides --> Repositories
    Bootstrap -- Uses --> EnvFile
    Bootstrap -- Uses --> CommonsLoggers["Loggers"]

    Commons --> Controllers
    Commons --> Services
    Commons --> Strategies
    Commons --> MappersFactories
    Commons --> Repositories

    classDef default fill:#fff,stroke:#333,stroke-width:2px;
                        </pre>
                        </div>
                    </div>
                </div>

                <p>
                    Como se muestra en el diagrama, StripeLabApp sigue una arquitectura en capas con una clara separación de responsabilidades:
                </p>
                <ul>
                    <li><strong>Capa de Presentación:</strong> Interfaz de usuario y puntos de entrada API.</li>
                    <li><strong>Capa de Controladores:</strong> Manejan las solicitudes HTTP y coordinan las operaciones.</li>
                    <li><strong>Capa de Servicios:</strong> Implementan la lógica de negocio y orquestan las operaciones complejas.</li>
                    <li><strong>Capa de Estrategias:</strong> Encapsulan la lógica específica para cada tipo de evento de Stripe.</li>
                    <li><strong>Capa de Mappers y Factories:</strong> Facilitan la conversión entre formatos de datos y la creación de objetos.</li>
                    <li><strong>Capa de Repositorios:</strong> Proporcionan acceso a datos y abstraen la capa de persistencia.</li>
                    <li><strong>Capa de Commons:</strong> Contiene componentes transversales utilizados por toda la aplicación.</li>
                </ul>

                <div class="alert alert-info">
                    <i class="fas fa-info-circle"></i> <strong>Patrón de diseño:</strong> La arquitectura combina varios patrones, incluyendo MVC (Modelo-Vista-Controlador), Repository, Strategy y Factory. Esta combinación proporciona flexibilidad y facilita la extensión del sistema para manejar nuevos tipos de eventos o funcionalidades.
                </div>
            </div>

            <div id="capa-commons" class="subsection">
                <h4>7.2. Capa Commons</h4>
                <p>
                    La capa Commons contiene componentes fundamentales utilizados en toda la aplicación, proporcionando estructura, tipado y funcionalidades comunes. Estos componentes son la base sobre la que se construyen las demás capas.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>DTOs (Data Transfer Objects)</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Los DTOs en StripeLabApp facilitan la transferencia de datos entre las diferentes capas de la aplicación sin exponer los detalles de implementación de las entidades de dominio. También proporcionan una estructura clara para los datos que se envían al frontend.
                        </p>

                        <p><strong>Ejemplos de DTOs:</strong></p>
                        <ul>
                            <li>
                                <strong>SubscriptionDTO:</strong> Representa una suscripción con todos los datos necesarios para la visualización y gestión:
                                <div class="code-snippet">
                                <pre><code class="language-php">
class SubscriptionDTO
{
    public int $id;
    public string $subscriptionId;
    public string $customerId;
    public string $status;
    public string $planId;
    public string $planName;
    public float $amount;
    public string $currency;
    public string $interval;
    public DateTime $currentPeriodStart;
    public DateTime $currentPeriodEnd;
    public ?DateTime $canceledAt;
    public bool $cancelAtPeriodEnd;
    public DateTime $createdAt;
    public ?DateTime $endedAt;
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>InvoiceDTO:</strong> Contiene la información de una factura para mostrar en la interfaz:
                                <div class="code-snippet">
                                <pre><code class="language-php">
class InvoiceDTO
{
    public string $invoiceId;
    public string $customerId;
    public ?string $subscriptionId;
    public float $amount;
    public string $currency;
    public string $status;
    public DateTime $createdAt;
    public ?string $invoiceUrl;
    public ?string $receiptUrl;
    public ?string $description;
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>TransactionDTO:</strong> Representa una transacción de pago, ya sea única o parte de una suscripción:
                                <div class="code-snippet">
                                <pre><code class="language-php">
                                class TransactionDTO
                                {
                                    public int $id;
                                    public string $transactionId;
                                    public ?string $customerId;
                                    public string $type;
                                    public float $amount;
                                    public string $currency;
                                    public string $status;
                                    public ?string $paymentMethodDetails;
                                    public ?string $receiptUrl;
                                    public DateTime $createdAt;
                                    public ?string $description;
                                }

                                 </code></pre>
                                </div>
                            </li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-lightbulb"></i> <strong>Beneficio:</strong> Los DTOs proporcionan una capa de abstracción que facilita la evolución de las entidades internas sin afectar a las interfaces externas. También simplifican la serialización a JSON para las respuestas API.
                        </div>
                    </div>
                </div>
                <!-- Aquí termina la sección 7.2 parcial - continúa con el resto de la sección 7.2 y las siguientes secciones -->

                <!-- Continuación de la sección 7.2 Capa Commons -->
                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Entidades (Models)</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Las entidades o modelos representan los objetos de dominio principales de la aplicación y corresponden directamente a las tablas de la base de datos. Contienen la lógica específica del dominio y las reglas de negocio.
                        </p>

                        <p><strong>Principales modelos:</strong></p>
                        <ul>
                            <li>
                                <strong>TransactionsModel:</strong> Representa una transacción financiera en el sistema:
                                <div class="code-snippet">
                                <pre><code class="language-php">
class TransactionsModel
{
    public int $transaction_id; // ID autoincremental en la BD
    public string $stripe_transaction_id; // ID de Stripe (payment_intent o charge)
    public ?string $stripe_customer_id; // ID del cliente en Stripe
    public string $transaction_type; // Tipo (PAYMENT, SUBSCRIPTION, REFUND)
    public float $amount; // Importe
    public string $currency; // Moneda (EUR, USD, etc.)
    public string $status; // Estado (COMPLETED, FAILED, REFUNDED)
    public ?string $payment_method_details; // Detalles del método de pago en JSON
    public ?string $receipt_url; // URL al recibo en Stripe
    public DateTimeImmutable $created_at; // Fecha de creación
    public ?string $description; // Descripción opcional
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>SubscriptionsModel:</strong> Representa una suscripción de un cliente:
                                <div class="code-snippet">
                                <pre><code class="language-php">
class SubscriptionsModel
{
    public string $subscription_id; // ID de Stripe (sub_...)
    public string $customer_id; // ID del cliente en Stripe
    public string $status; // Estado (active, canceled, etc.)
    public string $plan_id; // ID del plan en Stripe
    public string $plan_name; // Nombre descriptivo del plan
    public float $amount; // Importe por periodo
    public string $currency; // Moneda
    public string $interval; // Intervalo (month, year)
    public DateTimeImmutable $current_period_start; // Inicio del periodo actual
    public DateTimeImmutable $current_period_end; // Fin del periodo actual
    public ?DateTimeImmutable $canceled_at; // Fecha de cancelación (si aplica)
    public bool $cancel_at_period_end; // Si se cancelará al final del periodo
    public DateTimeImmutable $created_at; // Fecha de creación
    public ?DateTimeImmutable $ended_at; // Fecha de finalización (si terminó)
}
                                </code></pre>
                                </div>
                            </li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-database"></i> <strong>Relación con la base de datos:</strong>
                            <p>Cada campo de estos modelos corresponde directamente a una columna en las tablas <code>transactions</code> y <code>subscriptions</code> respectivamente. La tabla <code>transactions</code> utiliza un <code>transaction_id</code> autoincremental como clave primaria, mientras que <code>subscriptions</code> utiliza el <code>subscription_id</code> de Stripe como clave primaria natural.</p>
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Enums</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Las enumeraciones proporcionan un tipado fuerte para valores constantes en la aplicación, mejorando la legibilidad del código y reduciendo errores por el uso de strings literales.
                        </p>

                        <p><strong>Principales enumeraciones:</strong></p>
                        <ul>
                            <li>
                                <strong>StripeEventTypeEnum:</strong> Define los tipos de eventos de Stripe que la aplicación maneja:
                                <div class="code-snippet">
                                <pre><code class="language-php">
enum StripeEventTypeEnum: string
{
    case CHECKOUT_SESSION_COMPLETED = 'checkout.session.completed';
    case PAYMENT_INTENT_SUCCEEDED = 'payment_intent.succeeded';
    case CHARGE_SUCCEEDED = 'charge.succeeded';
    case CUSTOMER_CREATED = 'customer.created';
    case CUSTOMER_UPDATED = 'customer.updated';
    case CUSTOMER_SUBSCRIPTION_CREATED = 'customer.subscription.created';
    case CUSTOMER_SUBSCRIPTION_UPDATED = 'customer.subscription.updated';
    case CUSTOMER_SUBSCRIPTION_DELETED = 'customer.subscription.deleted';
    case INVOICE_PAID = 'invoice.paid';
    // ... otros eventos soportados
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>TransactionTypeEnum:</strong> Define los tipos de transacciones financieras:
                                <div class="code-snippet">
                                <pre><code class="language-php">
enum TransactionTypeEnum: string
{
    case PAYMENT = 'PAYMENT';           // Pago único
    case SUBSCRIPTION = 'SUBSCRIPTION';  // Pago de suscripción
    case REFUND = 'REFUND';              // Reembolso
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>TransactionStatusEnum:</strong> Define los posibles estados de una transacción:
                                <div class="code-snippet">
                                <pre><code class="language-php">
enum TransactionStatusEnum: string
{
    case COMPLETED = 'COMPLETED';  // Transacción completada
    case FAILED = 'FAILED';        // Transacción fallida
    case REFUNDED = 'REFUNDED';    // Transacción reembolsada
    case PENDING = 'PENDING';      // Transacción pendiente
}
                                </code></pre>
                                </div>
                            </li>
                        </ul>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Beneficio:</strong> El uso de enums mejora la legibilidad del código, proporciona autocompletado en IDEs, y evita errores por el uso de strings incorrectos. También facilita la evolución del código, ya que los cambios en los valores se reflejan automáticamente en todas partes donde se utiliza el enum.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Excepciones Personalizadas</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            StripeLabApp utiliza excepciones personalizadas para manejar diferentes tipos de errores de manera específica, facilitando su captura y tratamiento adecuado.
                        </p>

                        <p><strong>Principales excepciones:</strong></p>
                        <ul>
                            <li>
                                <strong>ConfigurationException:</strong> Lanzada cuando hay un problema con la configuración de la aplicación (variables de entorno faltantes, valores incorrectos).
                            </li>
                            <li>
                                <strong>DatabaseException:</strong> Encapsula errores de la base de datos, proporcionando contexto adicional sobre la operación que falló.
                            </li>
                            <li>
                                <strong>InvalidWebhookPayloadException:</strong> Lanzada cuando el payload de un webhook no tiene el formato esperado o falta información crítica.
                            </li>
                            <li>
                                <strong>WebhookProcessingException:</strong> Indica un error durante el procesamiento de un webhook por parte de una estrategia específica.
                            </li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-info-circle"></i> <strong>Nota:</strong> Además de estas excepciones personalizadas, StripeLabApp también maneja las excepciones nativas de la biblioteca de Stripe, como <code>Stripe\Exception\SignatureVerificationException</code> para errores de verificación de firma de webhook, o <code>Stripe\Exception\ApiErrorException</code> para errores de la API de Stripe.
                        </div>

                        <p>
                            El uso de excepciones personalizadas permite un manejo más granular de los errores, facilitando respuestas específicas según el tipo de problema que ocurra.
                        </p>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Loggers</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            StripeLabApp implementa un sistema de logging especializado para diferentes aspectos de la aplicación, facilitando la depuración y la auditoría de operaciones críticas.
                        </p>

                        <p><strong>Loggers especializados:</strong></p>
                        <ul>
                            <li>
                                <strong>EventLogger:</strong> Registra información general sobre los eventos de la aplicación, como inicializaciones, procesos completados, o cambios de estado.
                            </li>
                            <li>
                                <strong>ErrorLogger:</strong> Captura y registra errores y excepciones, incluyendo trazas completas para facilitar la depuración.
                            </li>
                            <li>
                                <strong>DatabaseLogger:</strong> Registra operaciones críticas de base de datos, como inserciones, actualizaciones y errores específicos de la capa de persistencia.
                            </li>
                            <li>
                                <strong>StripePayloadLogger:</strong> Guarda los payloads recibidos de Stripe (omitiendo información sensible), lo que facilita el diagnóstico de problemas relacionados con webhooks.
                            </li>
                            <li>
                                <strong>UnhandledStripeEventLogger:</strong> Registra eventos de Stripe para los que no hay una estrategia implementada, facilitando la identificación de eventos que podrían requerir soporte en el futuro.
                            </li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
// Ejemplo de uso de loggers en una estrategia
try {
    // Procesar evento de Stripe
    $this->stripePayloadLogger->log($webhookPayload, 'payment_intent.succeeded');

    // Operación específica
    $transaction = $this->createTransaction($paymentIntent);
    $this->eventLogger->log("Transacción creada: {$transaction->stripe_transaction_id}");

    // Operación de base de datos
    $success = $this->transactionRepository->save($transaction);
    $this->databaseLogger->log("Transacción guardada en BD: {$transaction->stripe_transaction_id}");
} catch (Exception $e) {
    $this->errorLogger->logException($e, "Error al procesar payment_intent.succeeded");
    throw new WebhookProcessingException("No se pudo procesar el pago", 0, $e);
}
                        </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-shield-alt"></i> <strong>Importancia:</strong> Un buen sistema de logging es crucial para aplicaciones que manejan pagos, ya que permite auditar todas las operaciones financieras, facilita la detección y solución de problemas, y proporciona evidencia para la reconciliación financiera y resolución de disputas.
                        </div>
                    </div>
                </div>
            </div>

            <div id="capa-configuracion" class="subsection">
                <h4>7.3. Capa de Configuración (config/)</h4>
                <p>
                    La capa de configuración proporciona la infraestructura básica para inicializar la aplicación, cargar configuraciones y gestionar dependencias.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Bootstrap.php</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <code>Bootstrap.php</code> actúa como un Service Locator simple, gestionando la inicialización de la aplicación y la instanciación perezosa (lazy loading) de las dependencias principales. Sus responsabilidades incluyen:
                        </p>
                        <ul>
                            <li><strong>Carga de variables de entorno</strong> desde el archivo <code>.env</code> utilizando la biblioteca PHPDotEnv.</li>
                            <li><strong>Definición de constantes globales</strong> basadas en variables de entorno.</li>
                            <li><strong>Inicialización de Stripe</strong> con la clave API secreta.</li>
                            <li><strong>Registro de manejadores de errores y excepciones</strong> para capturar problemas no controlados.</li>
                            <li><strong>Configuración de zonas horarias y locales</strong> para estandarizar el formato de fechas y números.</li>
                            <li><strong>Provisión de instancias de servicios, controladores y repositorios</strong> mediante métodos de acceso.</li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
class Bootstrap
{
    private static ?Bootstrap $instance = null;
    private array $services = [];

    private function __construct()
    {
        // Cargar variables de entorno desde .env
        $dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/..');
        $dotenv->load();

        // Inicializar Stripe con la clave API secreta
        \Stripe\Stripe::setApiKey($_ENV['STRIPE_SECRET_KEY']);

        // Configurar zona horaria y locale
        date_default_timezone_set('Europe/Madrid');
        setlocale(LC_MONETARY, 'es_ES.UTF-8');
    }

    public static function getInstance(): Bootstrap
    {
        if (self::$instance === null) {
            self::$instance = new Bootstrap();
        }
        return self::$instance;
    }

    // Métodos para obtener servicios y dependencias (lazy loading)
    public function getTransactionRepository(): TransactionRepository
    {
        if (!isset($this->services[TransactionRepository::class])) {
            $this->services[TransactionRepository::class] = new TransactionRepository(
                DatabaseConnection::getInstance()->getPdo()
            );
        }
        return $this->services[TransactionRepository::class];
    }

    public function getStripeWebhookController(): StripeWebhookController
    {
        if (!isset($this->services[StripeWebhookController::class])) {
            $this->services[StripeWebhookController::class] = new StripeWebhookController(
                $this->getStripeWebhookService(),
                $this->getEventLogger(),
                $this->getErrorLogger()
            );
        }
        return $this->services[StripeWebhookController::class];
    }

    // ... métodos similares para otros servicios y dependencias
}
                        </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-lightbulb"></i> <strong>Enfoque:</strong> Aunque esta implementación es más simple que un contenedor de inyección de dependencias completo, proporciona muchos de los mismos beneficios: centralización de la creación de objetos, lazy loading, y gestión de dependencias sin acoplamiento rígido.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>DatabaseConnection.php</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <code>DatabaseConnection.php</code> implementa un patrón Singleton para proporcionar una única instancia de conexión PDO a la base de datos MySQL. Sus responsabilidades incluyen:
                        </p>
                        <ul>
                            <li><strong>Establecer la conexión a la base de datos</strong> utilizando los parámetros de configuración del archivo <code>.env</code>.</li>
                            <li><strong>Configurar opciones de PDO</strong> para manejo de errores y codificación.</li>
                            <li><strong>Proporcionar acceso a la instancia PDO</strong> para los repositorios.</li>
                            <li><strong>Manejar errores de conexión</strong> y lanzar excepciones apropiadas.</li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
class DatabaseConnection
{
    private static ?DatabaseConnection $instance = null;
    private ?\PDO $pdo = null;

    private function __construct()
    {
        try {
            $host = $_ENV['DB_HOST'];
            $port = $_ENV['DB_PORT'];
            $dbname = $_ENV['DB_NAME'];
            $username = $_ENV['DB_USER'];
            $password = $_ENV['DB_PASSWORD'];

            $dsn = "mysql:host=$host;port=$port;dbname=$dbname;charset=utf8mb4";

            $this->pdo = new \PDO($dsn, $username, $password, [
                \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
                \PDO::ATTR_DEFAULT_FETCH_MODE => \PDO::FETCH_ASSOC,
                \PDO::ATTR_EMULATE_PREPARES => false,
            ]);
        } catch (\PDOException $e) {
            throw new DatabaseException("Error de conexión a la base de datos: " . $e->getMessage(), 0, $e);
        }
    }

    public static function getInstance(): DatabaseConnection
    {
        if (self::$instance === null) {
            self::$instance = new DatabaseConnection();
        }
        return self::$instance;
    }

    public function getPdo(): \PDO
    {
        return $this->pdo;
    }
}
                        </code></pre>
                        </div>

                        <div class="alert alert-warning mt-3">
                            <i class="fas fa-exclamation-triangle"></i> <strong>Consideración:</strong> Aunque el patrón Singleton es adecuado para este caso de uso, en aplicaciones más complejas podría ser preferible utilizar un pool de conexiones o un sistema de inyección de dependencias más sofisticado para gestionar las conexiones a la base de datos.
                        </div>
                    </div>
                </div>
            </div>

            <div id="capa-presentacion" class="subsection">
                <h4>7.4. Capa de Presentación y Puntos de Entrada (public/)</h4>
                <p>
                    La capa de presentación contiene los puntos de entrada de la aplicación, incluyendo páginas web, endpoints API y el endpoint de webhook. Esta capa se encarga de la interacción con el usuario y la comunicación con sistemas externos.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Páginas de Interfaz de Usuario</strong>
                    </div>
                    <div class="card-body">
                        <p><strong>Páginas principales para iniciar flujos de pago:</strong></p>
                        <ul>
                            <li>
                                <strong>index.php:</strong> Página principal que muestra las opciones disponibles (pago único o suscripción).
                            </li>
                            <li>
                                <strong>single-payment.php:</strong> Muestra el producto de pago único con opciones para proceder al checkout.
                            </li>
                            <li>
                                <strong>subscriptions-payment.php:</strong> Presenta los planes de suscripción disponibles (mensual y anual) y permite iniciar el proceso de suscripción.
                            </li>
                        </ul>

                        <p><strong>Páginas para visualización y gestión:</strong></p>
                        <ul>
                            <li>
                                <strong>invoices.php:</strong> Muestra un listado de facturas y recibos, con opciones de filtrado por cliente y acceso a los documentos PDF.
                            </li>
                            <li>
                                <strong>view-subscriptions.php:</strong> Permite ver y gestionar las suscripciones activas, incluyendo opciones para cancelación inmediata o al final del periodo.
                            </li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-paint-brush"></i> <strong>Diseño:</strong> Todas las páginas utilizan Bootstrap 5 para el diseño y la maquetación, lo que proporciona una interfaz responsiva y moderna. También utilizan JavaScript para cargar datos de manera asíncrona desde los endpoints API.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Endpoints de Checkout</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Estos endpoints son responsables de crear sesiones de Checkout en Stripe cuando el usuario decide realizar un pago o suscribirse a un plan.
                        </p>
                        <ul>
                            <li>
                                <strong>v1/create_payment_session.php:</strong> Crea una sesión de Checkout para un pago único. Recibe parámetros como cantidad, moneda y datos del cliente, y utiliza el <code>StripeCheckoutSessionService</code> para generar la sesión en Stripe.
                            </li>
                            <li>
                                <strong>v1/create_subscription_session.php:</strong> Crea una sesión de Checkout para una suscripción. Recibe el ID del plan (mensual o anual) y datos del cliente, y utiliza el <code>StripeCheckoutSessionService</code> para configurar la suscripción en Stripe.
                            </li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
// Ejemplo simplificado de create_subscription_session.php
require_once __DIR__ . '/../../config/Bootstrap.php';

$bootstrap = Bootstrap::getInstance();
$sessionService = $bootstrap->getStripeCheckoutSessionService();

// Validar y sanitizar datos de entrada
$priceId = $_POST['price_id'] ?? null;
$customerEmail = filter_var($_POST['email'] ?? '', FILTER_SANITIZE_EMAIL);
$customerName = htmlspecialchars($_POST['name'] ?? '');

if (!$priceId || !filter_var($customerEmail, FILTER_VALIDATE_EMAIL)) {
    http_response_code(400);
    echo json_encode(['error' => 'Datos inválidos']);
    exit;
}

try {
    // Crear sesión de Checkout para suscripción
    $session = $sessionService->createSubscriptionSession(
        $priceId,
        $customerEmail,
        $customerName,
        $_ENV['SUCCESS_URL'],
        $_ENV['CANCEL_URL']
    );

    // Devolver el ID de sesión para que el frontend redirija al Checkout
    echo json_encode(['sessionId' => $session->id]);
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['error' => 'Error al crear la sesión de pago']);
    $bootstrap->getErrorLogger()->logException($e);
}
                        </code></pre>
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Endpoint de Webhook</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>v1/webhook.php:</strong> Este es el punto de entrada más crítico de la aplicación, responsable de recibir todos los webhooks enviados por Stripe. Sus responsabilidades incluyen:
                        </p>
                        <ul>
                            <li>Recibir el payload JSON completo del webhook de Stripe.</li>
                            <li>Verificar la firma criptográfica utilizando el signing secret de Stripe.</li>
                            <li>Delegar el procesamiento al <code>StripeWebhookController</code>.</li>
                            <li>Manejar errores y devolver códigos de estado HTTP apropiados.</li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
// webhook.php - Punto de entrada para webhooks de Stripe
require_once __DIR__ . '/../../config/Bootstrap.php';

$bootstrap = Bootstrap::getInstance();
$webhookController = $bootstrap->getStripeWebhookController();
$logger = $bootstrap->getEventLogger();

// Obtener el payload completo y los headers
$payload = @file_get_contents('php://input');
$sigHeader = $_SERVER['HTTP_STRIPE_SIGNATURE'] ?? '';

try {
    // Procesar el webhook y obtener una respuesta
    $response = $webhookController->handleWebhook($payload, $sigHeader);

    // Enviar la respuesta con el código HTTP adecuado
    http_response_code($response['code']);
    echo json_encode($response['body']);

    $logger->log("Webhook procesado: " . $response['body']['type'] ?? 'desconocido');
} catch (Exception $e) {
    // Manejar errores y devolver códigos apropiados
    http_response_code(500);
    echo json_encode(['error' => 'Error interno del servidor']);

    $bootstrap->getErrorLogger()->logException($e, "Error al procesar webhook");
}
                        </code></pre>
                        </div>

                        <div class="alert alert-warning mt-3">
                            <i class="fas fa-shield-alt"></i> <strong>Seguridad crítica:</strong> La verificación de la firma es esencial para garantizar que las peticiones provienen realmente de Stripe y no han sido manipuladas. Sin esta verificación, un atacante podría enviar eventos falsos que podrían resultar en fraude o manipulación de datos sensibles.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Endpoints API</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Estos endpoints proporcionan acceso a los datos de la aplicación para que la interfaz de usuario pueda mostrarlos y permitir interacciones con ellos.
                        </p>
                        <ul>
                            <li>
                                <strong>v1/api/api-invoices.php:</strong> Proporciona acceso a los datos de facturas y recibos. Admite acciones como <code>list_all</code> (listar todas las facturas) y <code>list_customer</code> (listar facturas de un cliente específico).
                            </li>
                            <li>
                                <strong>v1/api/api-subscriptions.php:</strong> Permite acceder a los datos de suscripciones. Soporta acciones como <code>list_all_system</code> (todas las suscripciones) y <code>list_customer</code> (suscripciones de un cliente).
                            </li>
                            <li>
                                <strong>v1/api/api-manage-subscription.php:</strong> Gestiona operaciones sobre suscripciones, principalmente la cancelación (inmediata o al final del periodo) utilizando el <code>StripeSubscriptionManagementService</code>.
                            </li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
// Ejemplo simplificado de api-subscriptions.php
require_once __DIR__ . '/../../../config/Bootstrap.php';

$bootstrap = Bootstrap::getInstance();
$displayService = $bootstrap->getDisplayService();

// Validar la acción solicitada
$action = $_GET['action'] ?? '';
$validActions = ['list_all_system', 'list_customer'];

if (!in_array($action, $validActions)) {
    http_response_code(400);
    echo json_encode(['error' => 'Acción no válida']);
    exit;
}

try {
    $result = [];

    // Ejecutar la acción correspondiente
    if ($action === 'list_all_system') {
        $result = $displayService->getAllSubscriptions();
    } elseif ($action === 'list_customer') {
        $customerId = $_GET['customer_id'] ?? '';
        if (!$customerId) {
            throw new \InvalidArgumentException('ID de cliente requerido');
        }
        $result = $displayService->getCustomerSubscriptions($customerId);
    }

    // Devolver los resultados como JSON
    header('Content-Type: application/json');
    echo json_encode(['subscriptions' => $result]);
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['error' => $e->getMessage()]);
    $bootstrap->getErrorLogger()->logException($e);
}
                        </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-code"></i> <strong>Arquitectura:</strong> Estos endpoints API siguen un patrón simple pero efectivo: validar la entrada, delegar la lógica a servicios especializados, y devolver respuestas JSON estructuradas que pueden ser consumidas fácilmente por el frontend.
                        </div>
                    </div>
                </div>
            </div>

            <div id="controladores" class="subsection">
                <h4>7.5. Controladores (src/Controller/)</h4>
                <p>
                    Los controladores coordinan el flujo de la aplicación, recibiendo peticiones HTTP, delegando la lógica de negocio a los servicios apropiados, y devolviendo respuestas estructuradas.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>StripeWebhookController</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Actúa como punto de entrada para los eventos de webhook de Stripe, verificando la firma y delegando el procesamiento al servicio adecuado.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Recibir y validar los payloads de webhook entrantes.</li>
                            <li>Verificar la firma criptográfica del webhook utilizando el signing secret.</li>
                            <li>Delegar el procesamiento del evento al <code>StripeWebhookService</code>.</li>
                            <li>Manejar excepciones y errores que puedan ocurrir durante el procesamiento.</li>
                            <li>Devolver respuestas HTTP apropiadas (200 OK para procesamiento exitoso, 4xx para errores del cliente, 5xx para errores del servidor).</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class StripeWebhookController
{
   private StripeWebhookService $webhookService;
   private EventLogger $eventLogger;
   private ErrorLogger $errorLogger;

   public function __construct(
       StripeWebhookService $webhookService,
       EventLogger $eventLogger,
       ErrorLogger $errorLogger
   ) {
       $this->webhookService = $webhookService;
       $this->eventLogger = $eventLogger;
       $this->errorLogger = $errorLogger;
   }

   public function handleWebhook(string $payload, string $sigHeader): array
   {
       try {
           // Verificar firma y construir el evento
           $event = $this->webhookService->constructEvent($payload, $sigHeader);

           // Registrar la recepción del evento
           $this->eventLogger->log("Webhook recibido: {$event->type} - {$event->id}");

           // Procesar el evento
           $result = $this->webhookService->processEvent($event);

           // Devolver respuesta exitosa
           return [
               'code' => 200,
               'body' => [
                   'status' => 'success',
                   'type' => $event->type,
                   'id' => $event->id
               ]
           ];
       } catch (\Stripe\Exception\SignatureVerificationException $e) {
           // Error de verificación de firma
           $this->errorLogger->logException($e, "Error de verificación de firma de webhook");
           return [
               'code' => 400,
               'body' => ['error' => 'Invalid signature']
           ];
       } catch (InvalidWebhookPayloadException $e) {
           // Payload inválido
           $this->errorLogger->logException($e, "Payload de webhook inválido");
           return [
               'code' => 400,
               'body' => ['error' => 'Invalid payload']
           ];
       } catch (WebhookProcessingException $e) {
           // Error durante el procesamiento
           $this->errorLogger->logException($e, "Error al procesar webhook");
           return [
               'code' => 500,
               'body' => ['error' => 'Processing error']
           ];
       } catch (\Exception $e) {
           // Error inesperado
           $this->errorLogger->logException($e, "Error inesperado al manejar webhook");
           return [
               'code' => 500,
               'body' => ['error' => 'Internal server error']
           ];
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-info-circle"></i> <strong>Importancia:</strong> Este controlador es crítico para el funcionamiento de la aplicación, ya que gestiona toda la comunicación asíncrona con Stripe. Su diseño robusto para el manejo de errores asegura que los webhooks sean procesados correctamente o que se proporcionen respuestas adecuadas en caso de fallos.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>DisplayController</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Proporciona endpoints para que la interfaz de usuario obtenga datos sobre facturas, suscripciones y transacciones.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Validar y procesar parámetros de solicitud (filtros, paginación, etc.).</li>
                            <li>Delegar la recuperación de datos al <code>DisplayService</code>.</li>
                            <li>Formatear y devolver datos en formato JSON para su consumo por el frontend.</li>
                            <li>Gestionar errores y excepciones que puedan ocurrir durante la recuperación de datos.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class DisplayController
{
   private DisplayService $displayService;
   private ErrorLogger $errorLogger;

   public function __construct(
       DisplayService $displayService,
       ErrorLogger $errorLogger
   ) {
       $this->displayService = $displayService;
       $this->errorLogger = $errorLogger;
   }

   public function getInvoices(array $params): array
   {
       try {
           // Determinar el tipo de consulta basado en los parámetros
           if (isset($params['customer_id'])) {
               $invoices = $this->displayService->getCustomerInvoices($params['customer_id']);
           } else {
               $page = isset($params['page']) ? (int)$params['page'] : 1;
               $limit = isset($params['limit']) ? (int)$params['limit'] : 10;
               $invoices = $this->displayService->getAllInvoices($page, $limit);
           }

           return [
               'code' => 200,
               'body' => [
                   'status' => 'success',
                   'invoices' => $invoices
               ]
           ];
       } catch (\Exception $e) {
           $this->errorLogger->logException($e, "Error al obtener facturas");
           return [
               'code' => 500,
               'body' => ['error' => 'Error al recuperar los datos de facturas']
           ];
       }
   }

   public function getSubscriptions(array $params): array
   {
       try {
           // Lógica similar para obtener suscripciones
           if (isset($params['customer_id'])) {
               $subscriptions = $this->displayService->getCustomerSubscriptions($params['customer_id']);
           } else {
               $subscriptions = $this->displayService->getAllSubscriptions();
           }

           return [
               'code' => 200,
               'body' => [
                   'status' => 'success',
                   'subscriptions' => $subscriptions
               ]
           ];
       } catch (\Exception $e) {
           $this->errorLogger->logException($e, "Error al obtener suscripciones");
           return [
               'code' => 500,
               'body' => ['error' => 'Error al recuperar los datos de suscripciones']
           ];
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Diseño:</strong> Este controlador sigue el principio de responsabilidad única, centrándose exclusivamente en la coordinación de las solicitudes de visualización de datos. Toda la lógica de negocio y acceso a datos se delega al <code>DisplayService</code>, manteniendo el código limpio y modular.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>SubscriptionManagementController</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Gestiona las operaciones relacionadas con la administración de suscripciones, principalmente la cancelación.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Validar parámetros de solicitud para operaciones de gestión de suscripciones.</li>
                            <li>Delegar las operaciones al <code>StripeSubscriptionManagementService</code>.</li>
                            <li>Proporcionar feedback sobre el resultado de las operaciones.</li>
                            <li>Manejar errores específicos de la API de Stripe relacionados con la gestión de suscripciones.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class SubscriptionManagementController
{
   private StripeSubscriptionManagementService $subscriptionService;
   private ErrorLogger $errorLogger;

   public function __construct(
       StripeSubscriptionManagementService $subscriptionService,
       ErrorLogger $errorLogger
   ) {
       $this->subscriptionService = $subscriptionService;
       $this->errorLogger = $errorLogger;
   }

   public function cancelSubscription(array $params): array
   {
       // Validar parámetros necesarios
       if (!isset($params['subscription_id'])) {
           return [
               'code' => 400,
               'body' => ['error' => 'ID de suscripción requerido']
           ];
       }

       $subscriptionId = $params['subscription_id'];
       $cancelAtPeriodEnd = isset($params['cancel_at_period_end'])
           ? (bool)$params['cancel_at_period_end']
           : true;

       try {
           // Intentar cancelar la suscripción
           $result = $this->subscriptionService->cancelSubscription(
               $subscriptionId,
               $cancelAtPeriodEnd
           );

           return [
               'code' => 200,
               'body' => [
                   'status' => 'success',
                   'message' => $cancelAtPeriodEnd
                       ? 'La suscripción se cancelará al final del periodo actual'
                       : 'La suscripción ha sido cancelada inmediatamente',
                   'subscription' => $result
               ]
           ];
       } catch (\Stripe\Exception\ApiErrorException $e) {
           // Manejar errores específicos de la API de Stripe
           $this->errorLogger->logException($e, "Error de API de Stripe al cancelar suscripción");
           return [
               'code' => 400,
               'body' => ['error' => 'Error al cancelar la suscripción: ' . $e->getMessage()]
           ];
       } catch (\Exception $e) {
           // Manejar otros errores inesperados
           $this->errorLogger->logException($e, "Error inesperado al cancelar suscripción");
           return [
               'code' => 500,
               'body' => ['error' => 'Error interno al procesar la solicitud']
           ];
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-lightbulb"></i> <strong>Flexibilidad:</strong> Este controlador proporciona opciones para cancelar suscripciones de forma inmediata o al final del periodo de facturación actual, dando flexibilidad tanto a los usuarios como a los administradores del sistema.
                        </div>
                    </div>
                </div>
            </div>

            <div id="servicios" class="subsection">
                <h4>7.6. Servicios (src/Service/)</h4>
                <p>
                    Los servicios implementan la lógica de negocio principal de la aplicación, coordinando operaciones complejas, interactuando con APIs externas y orquestando el flujo de datos entre diferentes componentes.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>StripeWebhookService</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Orquestar la validación y el procesamiento de los webhooks de Stripe, enrutando cada tipo de evento a la estrategia apropiada.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Verificar la firma criptográfica de los webhooks utilizando el signing secret de Stripe.</li>
                            <li>Analizar el tipo de evento recibido y determinar qué estrategia debe procesarlo.</li>
                            <li>Utilizar el <code>StripeEventStrategyFactory</code> para obtener la estrategia adecuada.</li>
                            <li>Ejecutar la estrategia correspondiente para procesar el evento.</li>
                            <li>Gestionar errores durante el procesamiento y lanzar excepciones apropiadas.</li>
                            <li>Registrar eventos no manejados para análisis futuro.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class StripeWebhookService
{
   private string $webhookSecret;
   private StripeEventStrategyFactory $strategyFactory;
   private UnhandledStripeEventLogger $unhandledEventLogger;
   private StripePayloadLogger $payloadLogger;

   public function __construct(
       string $webhookSecret,
       StripeEventStrategyFactory $strategyFactory,
       UnhandledStripeEventLogger $unhandledEventLogger,
       StripePayloadLogger $payloadLogger
   ) {
       $this->webhookSecret = $webhookSecret;
       $this->strategyFactory = $strategyFactory;
       $this->unhandledEventLogger = $unhandledEventLogger;
       $this->payloadLogger = $payloadLogger;
   }

   /**
    * Construye un objeto Event de Stripe a partir del payload y verifica su firma
    */
   public function constructEvent(string $payload, string $sigHeader): \Stripe\Event
   {
       try {
           return \Stripe\Webhook::constructEvent(
               $payload, $sigHeader, $this->webhookSecret
           );
       } catch (\UnexpectedValueException $e) {
           throw new InvalidWebhookPayloadException(
               "Invalid payload: " . $e->getMessage(), 0, $e
           );
       } catch (\Stripe\Exception\SignatureVerificationException $e) {
           throw $e; // Reenviar esta excepción específica para manejarla en el controlador
       }
   }

   /**
    * Procesa un evento de Stripe utilizando la estrategia apropiada
    */
   public function processEvent(\Stripe\Event $event): bool
   {
       // Registrar el payload (sin datos sensibles)
       $this->payloadLogger->log(json_encode($event), $event->type);

       try {
           // Intentar obtener una estrategia para este tipo de evento
           $strategy = $this->strategyFactory->createStrategy($event->type);

           // Si no hay estrategia disponible, registrar como no manejado y devolver éxito
           if ($strategy === null) {
               $this->unhandledEventLogger->log(
                   "Evento no manejado: {$event->type} - {$event->id}"
               );
               return true;
           }

           // Procesar el evento con la estrategia correspondiente
           return $strategy->process($event);
       } catch (WebhookProcessingException $e) {
           // Reenviar excepciones específicas de procesamiento
           throw $e;
       } catch (\Exception $e) {
           // Convertir otras excepciones en WebhookProcessingException
           throw new WebhookProcessingException(
               "Error al procesar evento {$event->type}: " . $e->getMessage(),
               0, $e
           );
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-cogs"></i> <strong>Diseño:</strong> Este servicio actúa como un coordinador central para el procesamiento de webhooks, siguiendo el principio de alta cohesión y bajo acoplamiento. Utiliza el patrón Factory Method para crear estrategias y el patrón Strategy para delegar el procesamiento específico de cada tipo de evento.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>StripeCheckoutSessionService</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Crear y configurar sesiones de Checkout de Stripe para pagos únicos y suscripciones.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Interactuar con la API de Stripe para crear sesiones de Checkout.</li>
                            <li>Configurar parámetros específicos para diferentes tipos de sesiones (pago único vs. suscripción).</li>
                            <li>Gestionar la información del cliente (email, nombre) y pasarla a Stripe.</li>
                            <li>Configurar URLs de redirección para éxito y cancelación.</li>
                            <li>Manejar errores de la API de Stripe y convertirlos en excepciones amigables.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class StripeCheckoutSessionService
{
   private ErrorLogger $errorLogger;

   public function __construct(ErrorLogger $errorLogger)
   {
       $this->errorLogger = $errorLogger;
   }

   /**
    * Crea una sesión de Checkout para un pago único
    */
   public function createPaymentSession(
       float $amount,
       string $currency,
       string $customerEmail,
       string $customerName,
       string $successUrl,
       string $cancelUrl
   ): \Stripe\Checkout\Session {
       try {
           return \Stripe\Checkout\Session::create([
               'payment_method_types' => ['card'],
               'line_items' => [[
                   'price_data' => [
                       'currency' => $currency,
                       'product_data' => [
                           'name' => 'Producto de pago único',
                       ],
                       'unit_amount' => (int)($amount * 100), // Convertir a centavos
                   ],
                   'quantity' => 1,
               ]],
               'customer_creation' => 'always',
               'customer_email' => $customerEmail,
               'client_reference_id' => $customerName,
               'mode' => 'payment',
               'success_url' => $successUrl,
               'cancel_url' => $cancelUrl,
           ]);
       } catch (\Stripe\Exception\ApiErrorException $e) {
           $this->errorLogger->logException($e, "Error al crear sesión de pago");
           throw new \RuntimeException("Error al crear sesión de pago: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Crea una sesión de Checkout para una suscripción
    */
   public function createSubscriptionSession(
       string $priceId,
       string $customerEmail,
       string $customerName,
       string $successUrl,
       string $cancelUrl
   ): \Stripe\Checkout\Session {
       try {
           return \Stripe\Checkout\Session::create([
               'payment_method_types' => ['card'],
               'line_items' => [[
                   'price' => $priceId,
                   'quantity' => 1,
               ]],
               'customer_creation' => 'always',
               'customer_email' => $customerEmail,
               'client_reference_id' => $customerName,
               'mode' => 'subscription',
               'success_url' => $successUrl,
               'cancel_url' => $cancelUrl,
           ]);
       } catch (\Stripe\Exception\ApiErrorException $e) {
           $this->errorLogger->logException($e, "Error al crear sesión de suscripción");
           throw new \RuntimeException("Error al crear sesión de suscripción: " . $e->getMessage(), 0, $e);
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-shield-alt"></i> <strong>Ventaja:</strong> Stripe Checkout simplifica enormemente el proceso de pago, ya que maneja automáticamente la validación de tarjetas, la autenticación 3D Secure, y ofrece una experiencia de usuario optimizada y consistente. Este servicio aprovecha esas ventajas mientras proporciona una interfaz limpia para el resto de la aplicación.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>StripeSubscriptionManagementService</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Gestionar operaciones relacionadas con suscripciones existentes, como la cancelación o actualización.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Interactuar con la API de Stripe para modificar suscripciones existentes.</li>
                            <li>Proporcionar opciones para cancelar suscripciones inmediatamente o al final del periodo.</li>
                            <li>Actualizar el estado de las suscripciones en la base de datos local para mantener la sincronización.</li>
                            <li>Manejar errores y excepciones específicas de la API de Stripe relacionadas con suscripciones.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class StripeSubscriptionManagementService
{
   private SubscriptionRepository $subscriptionRepository;
   private ErrorLogger $errorLogger;

   public function __construct(
       SubscriptionRepository $subscriptionRepository,
       ErrorLogger $errorLogger
   ) {
       $this->subscriptionRepository = $subscriptionRepository;
       $this->errorLogger = $errorLogger;
   }

   /**
    * Cancela una suscripción, inmediatamente o al final del periodo
    */
   public function cancelSubscription(
       string $subscriptionId,
       bool $cancelAtPeriodEnd = true
   ): array {
       try {
           if ($cancelAtPeriodEnd) {
               // Cancelar al final del periodo actual
               $subscription = \Stripe\Subscription::update($subscriptionId, [
                   'cancel_at_period_end' => true,
               ]);
           } else {
               // Cancelar inmediatamente
               $subscription = \Stripe\Subscription::retrieve($subscriptionId);
               $subscription = $subscription->cancel();
           }

           // Actualizar el estado en la base de datos local
           $this->updateLocalSubscription($subscription);

           return [
               'id' => $subscription->id,
               'status' => $subscription->status,
               'cancel_at_period_end' => $subscription->cancel_at_period_end,
               'current_period_end' => date('Y-m-d H:i:s', $subscription->current_period_end),
               'canceled_at' => $subscription->canceled_at
                   ? date('Y-m-d H:i:s', $subscription->canceled_at)
                   : null,
           ];
       } catch (\Stripe\Exception\ApiErrorException $e) {
           $this->errorLogger->logException($e, "Error al cancelar suscripción en Stripe");
           throw $e; // Reenviar para manejo específico en el controlador
       } catch (\Exception $e) {
           $this->errorLogger->logException($e, "Error inesperado al cancelar suscripción");
           throw new \RuntimeException("Error al cancelar la suscripción", 0, $e);
       }
   }

   /**
    * Actualiza los datos de la suscripción en la base de datos local
    */
   private function updateLocalSubscription(\Stripe\Subscription $subscription): bool
   {
       try {
           $model = new SubscriptionsModel();
           $model->subscription_id = $subscription->id;
           $model->status = $subscription->status;
           $model->cancel_at_period_end = $subscription->cancel_at_period_end;
           $model->canceled_at = $subscription->canceled_at
               ? new \DateTimeImmutable('@' . $subscription->canceled_at)
               : null;
           $model->ended_at = $subscription->ended_at
               ? new \DateTimeImmutable('@' . $subscription->ended_at)
               : null;

           return $this->subscriptionRepository->update($model);
       } catch (\Exception $e) {
           $this->errorLogger->logException($e, "Error al actualizar suscripción en BD local");
           // No relanzar la excepción para no interrumpir el flujo principal
           return false;
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-sync-alt"></i> <strong>Sincronización:</strong> Este servicio cumple un rol crucial en mantener sincronizados los datos entre Stripe y la base de datos local. Cuando se modifica una suscripción a través de este servicio, se actualiza inmediatamente el estado local, sin esperar a que llegue el webhook correspondiente.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>DisplayService</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Recuperar y preparar datos de la base de datos para su visualización en la interfaz de usuario.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Coordinar la recuperación de datos desde los repositorios.</li>
                            <li>Transformar las entidades del dominio en DTOs adecuados para la presentación.</li>
                            <li>Aplicar filtros, paginación y ordenamiento a los resultados según las necesidades de la UI.</li>
                            <li>Combinar datos de múltiples fuentes cuando sea necesario.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class DisplayService
{
   private TransactionRepository $transactionRepository;
   private SubscriptionRepository $subscriptionRepository;
   private TransactionMapper $transactionMapper;
   private SubscriptionMapper $subscriptionMapper;

   public function __construct(
       TransactionRepository $transactionRepository,
       SubscriptionRepository $subscriptionRepository,
       TransactionMapper $transactionMapper,
       SubscriptionMapper $subscriptionMapper
   ) {
       $this->transactionRepository = $transactionRepository;
       $this->subscriptionRepository = $subscriptionRepository;
       $this->transactionMapper = $transactionMapper;
       $this->subscriptionMapper = $subscriptionMapper;
   }

   /**
    * Obtiene todas las facturas/transacciones con paginación
    */
   public function getAllInvoices(int $page = 1, int $limit = 10): array
   {
       $offset = ($page - 1) * $limit;
       $transactions = $this->transactionRepository->findAll($limit, $offset);

       return array_map(
           fn($model) => $this->transactionMapper->toDto($model),
           $transactions
       );
   }

   /**
    * Obtiene las facturas/transacciones de un cliente específico
    */
   public function getCustomerInvoices(string $customerId): array
   {
       $transactions = $this->transactionRepository->findByCustomerId($customerId);

       return array_map(
           fn($model) => $this->transactionMapper->toDto($model),
           $transactions
       );
   }

   /**
    * Obtiene todas las suscripciones
    */
   public function getAllSubscriptions(): array
   {
       $subscriptions = $this->subscriptionRepository->findAll();

       return array_map(
           fn($model) => $this->subscriptionMapper->toDto($model),
           $subscriptions
       );
   }

   /**
    * Obtiene las suscripciones de un cliente específico
    */
   public function getCustomerSubscriptions(string $customerId): array
   {
       $subscriptions = $this->subscriptionRepository->findByCustomerId($customerId);

       return array_map(
           fn($model) => $this->subscriptionMapper->toDto($model),
           $subscriptions
       );
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-layer-group"></i> <strong>Separación de responsabilidades:</strong> Este servicio proporciona una clara separación entre la capa de acceso a datos (repositorios) y la capa de presentación (controladores). Los datos se transforman mediante mappers para asegurar que solo se expone la información necesaria en el formato adecuado.
                        </div>
                    </div>
                </div>
            </div>

            <div id="estrategias" class="subsection">
                <h4>7.7. Estrategias (src/Strategy/)</h4>
                <p>
                    El patrón Strategy se utiliza extensivamente en StripeLabApp para manejar los diferentes tipos de eventos de webhook de Stripe de forma modular y extensible. Cada estrategia encapsula la lógica específica para procesar un tipo particular de evento.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Patrón Strategy en StripeLabApp</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>¿Por qué usar el patrón Strategy?</strong> Stripe puede enviar más de 100 tipos diferentes de eventos de webhook, cada uno requiriendo un procesamiento específico. El patrón Strategy permite:
                        </p>
                        <ul>
                            <li>Encapsular la lógica de procesamiento de cada tipo de evento en clases separadas.</li>
                            <li>Añadir soporte para nuevos tipos de eventos sin modificar el código existente (principio Open/Closed).</li>
                            <li>Facilitar las pruebas unitarias al aislar la lógica específica de cada tipo de evento.</li>
                            <li>Mantener una estructura de código clara y organizada, evitando funciones monolíticas con múltiples declaraciones switch/case.</li>
                        </ul>

                        <p><strong>Implementación:</strong></p>
                        <div class="code-snippet">
                       <pre><code class="language-php">
/**
* Interfaz común para todas las estrategias de procesamiento de eventos
*/
interface StripeEventStrategyInterface
{
   /**
    * @param \Stripe\Event $event El evento de Stripe a procesar
    * @return bool Éxito o fracaso del procesamiento
    * @throws WebhookProcessingException si ocurre un error durante el procesamiento
    */
   public function process(\Stripe\Event $event): bool;

   /**
    * @return string|array El tipo o tipos de eventos que maneja esta estrategia
    */
   public function getEventType(): string|array;
}
                       </code></pre>
                        </div>

                        <p>
                            <strong>Estrategia por defecto:</strong> Para manejar elegantemente los tipos de eventos para los que no hay una estrategia específica implementada.
                        </p>
                        <div class="code-snippet">
                       <pre><code class="language-php">
/**
* Estrategia por defecto para eventos no manejados específicamente
*/
class DefaultStripeEventStrategy implements StripeEventStrategyInterface
{
   private UnhandledStripeEventLogger $logger;

   public function __construct(UnhandledStripeEventLogger $logger)
   {
       $this->logger = $logger;
   }

   public function process(\Stripe\Event $event): bool
   {
       $this->logger->log("Evento no manejado procesado por la estrategia por defecto: {$event->type} - {$event->id}");
       return true; // Devolver éxito para no reintentar eventos que no necesitamos procesar
   }

   public function getEventType(): string
   {
       return 'default'; // Identificador especial, no corresponde a un tipo real de evento
   }
}
                       </code></pre>
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Detalle de cada Estrategia Implementada</strong>
                    </div>
                    <div class="card-body">
                        <div class="accordion" id="accordionStrategies">
                            <!-- CheckoutSessionCompletedStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingCheckoutSession">
                                    <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseCheckoutSession" aria-expanded="true" aria-controls="collapseCheckoutSession">
                                        CheckoutSessionCompletedStrategy
                                    </button>
                                </h2>
                                <div id="collapseCheckoutSession" class="accordion-collapse collapse show" aria-labelledby="headingCheckoutSession" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>checkout.session.completed</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>TransactionRepository</code>, <code>SubscriptionRepository</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Determina si la sesión de Checkout es para un pago único o una suscripción, basándose en el campo <code>mode</code>.</li>
                                            <li>Para pagos únicos: crea un registro de transacción en la base de datos.</li>
                                            <li>Para suscripciones: registra los metadatos de la sesión para su uso posterior por otras estrategias.</li>
                                            <li>Guarda referencias al cliente, pago o suscripción asociados.</li>
                                        </ul>
                                        <div class="alert alert-info mt-3">
                                            <i class="fas fa-info-circle"></i> <strong>Nota:</strong> Este evento es importante porque confirma que el usuario ha completado el flujo de pago en Stripe Checkout. Sin embargo, para pagos de suscripción, este evento se complementa con <code>invoice.paid</code> y <code>customer.subscription.created</code>, que proporcionan información adicional sobre la transacción.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- PaymentIntentSucceededStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingPaymentIntent">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapsePaymentIntent" aria-expanded="false" aria-controls="collapsePaymentIntent">
                                        PaymentIntentSucceededStrategy
                                    </button>
                                </h2>
                                <div id="collapsePaymentIntent" class="accordion-collapse collapse" aria-labelledby="headingPaymentIntent" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>payment_intent.succeeded</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>TransactionRepository</code>, <code>TransactionFactory</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Procesa eventos de pago exitoso, tanto para pagos únicos como para suscripciones.</li>
                                            <li>Extrae detalles del pago como importe, moneda, cliente, y estado.</li>
                                            <li>Utiliza una heurística para determinar si el PaymentIntent ya ha sido procesado:</li>
                                            <ul>
                                                <li>Verifica si ya existe una transacción con el mismo ID en la base de datos.</li>
                                                <li>Comprueba si el PaymentIntent está asociado a una suscripción, en cuyo caso se deja el procesamiento a <code>InvoicePaidStrategy</code>.</li>
                                            </ul>
                                            <li>Crea un registro de transacción con el tipo adecuado (PAYMENT o SUBSCRIPTION).</li>
                                        </ul>
                                        <div class="alert alert-warning mt-3">
                                            <i class="fas fa-exclamation-triangle"></i> <strong>Desafío:</strong> La correcta gestión de pagos de suscripción requiere evitar duplicaciones, ya que tanto <code>payment_intent.succeeded</code> como <code>invoice.paid</code> pueden referirse a la misma transacción. La estrategia resuelve esto comprobando la vinculación del PaymentIntent con una suscripción y delegando el procesamiento cuando corresponde.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- ChargeSucceededStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingCharge">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseCharge" aria-expanded="false" aria-controls="collapseCharge">
                                        ChargeSucceededStrategy
                                    </button>
                                </h2>
                                <div id="collapseCharge" class="accordion-collapse collapse" aria-labelledby="headingCharge" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>charge.succeeded</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>TransactionRepository</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Enriquece los registros de transacción existentes con información adicional del cargo:</li>
                                            <ul>
                                                <li>URL del recibo (<code>receipt_url</code>)</li>
                                                <li>Detalles del método de pago (últimos 4 dígitos, marca, etc.)</li>
                                                <li>Resultados de validaciones (verificación de CVC, dirección)</li>
                                            </ul>
                                            <li>Actualiza la transacción en la base de datos con estos datos adicionales.</li>
                                        </ul>
                                        <div class="alert alert-info mt-3">
                                            <i class="fas fa-lightbulb"></i> <strong>Diseño:</strong> Esta estrategia se enfoca en enriquecer datos, no en crear nuevos registros. Funciona bajo la premisa de que la transacción ya existe en la base de datos, creada previamente por <code>PaymentIntentSucceededStrategy</code> o <code>InvoicePaidStrategy</code>.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- CustomerCreatedOrUpdatedStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingCustomer">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseCustomer" aria-expanded="false" aria-controls="collapseCustomer">
                                        CustomerCreatedOrUpdatedStrategy
                                    </button>
                                </h2>
                                <div id="collapseCustomer" class="accordion-collapse collapse" aria-labelledby="headingCustomer" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>customer.created</code>, <code>customer.updated</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>CustomerRepository</code> (si se implementara la gestión de clientes)</p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>En la implementación actual, simplemente registra la recepción del evento sin realizar acciones adicionales.</li>
                                            <li>En una implementación más completa, podría:</li>
                                            <ul>
                                                <li>Crear o actualizar un registro de cliente en la base de datos.</li>
                                                <li>Sincronizar información como email, nombre, o dirección de facturación.</li>
                                                <li>Vincular el cliente de Stripe con un usuario de la aplicación.</li>
                                            </ul>
                                        </ul>
                                        <div class="alert alert-secondary mt-3">
                                            <i class="fas fa-info-circle"></i> <strong>Nota:</strong> StripeLabApp simplifica la gestión de clientes, enfocándose principalmente en transacciones y suscripciones. En una aplicación de producción, esta estrategia tendría un rol más importante en mantener sincronizada la información de los clientes.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- SubscriptionCreatedStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingSubscriptionCreated">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSubscriptionCreated" aria-expanded="false" aria-controls="collapseSubscriptionCreated">
                                        SubscriptionCreatedStrategy
                                    </button>
                                </h2>
                                <div id="collapseSubscriptionCreated" class="accordion-collapse collapse" aria-labelledby="headingSubscriptionCreated" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>customer.subscription.created</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>SubscriptionRepository</code>, <code>SubscriptionFactory</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Procesa la creación de nuevas suscripciones, extrayendo información como:</li>
                                            <ul>
                                                <li>ID de suscripción y cliente</li>
                                                <li>Estado de la suscripción</li>
                                                <li>Detalles del plan (ID, nombre, importe, intervalo)</li>
                                                <li>Fechas importantes (inicio, fin del periodo actual, etc.)</li>
                                            </ul>
                                            <li>Crea un nuevo registro de suscripción en la base de datos.</li>
                                        </ul>
                                        <div class="alert alert-info mt-3">
                                            <i class="fas fa-info-circle"></i> <strong>Flujo:</strong> Esta estrategia suele ejecutarse después de <code>checkout.session.completed</code> y antes de <code>invoice.paid</code> cuando un cliente se suscribe a un plan. Registra los detalles de la suscripción que serán utilizados para gestionar el acceso a funcionalidades premium o contenido restringido.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- SubscriptionUpdatedStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingSubscriptionUpdated">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSubscriptionUpdated" aria-expanded="false" aria-controls="collapseSubscriptionUpdated">
                                        SubscriptionUpdatedStrategy
                                    </button>
                                </h2>
                                <div id="collapseSubscriptionUpdated" class="accordion-collapse collapse" aria-labelledby="headingSubscriptionUpdated" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>customer.subscription.updated</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>SubscriptionRepository</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Procesa actualizaciones de suscripciones existentes, detectando cambios como:</li>
                                            <ul>
                                                <li>Cambios de estado (activa, pasada a periodo de prueba, etc.)</li>
                                                <li>Cambios de plan o cantidad</li>
                                                <li>Programación de cancelación (<code>cancel_at_period_end = true</code>)</li>
                                                <li>Actualizaciones de fechas (nuevo periodo de facturación)</li>
                                            </ul>
                                            <li>Actualiza el registro de suscripción en la base de datos.</li>
                                            <li>Presta especial atención a la detección de cancelaciones programadas, para reflejar correctamente que la suscripción terminará al final del periodo actual.</li>
                                        </ul>
                                        <div class="alert alert-warning mt-3">
                                            <i class="fas fa-exclamation-triangle"></i> <strong>Caso especial:</strong> Cuando un usuario solicita cancelar su suscripción al final del periodo actual, Stripe envía un evento <code>customer.subscription.updated</code> con <code>cancel_at_period_end = true</code>, no un evento de cancelación inmediata. Esta estrategia maneja ese escenario específico.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- SubscriptionDeletedStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingSubscriptionDeleted">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSubscriptionDeleted" aria-expanded="false" aria-controls="collapseSubscriptionDeleted">
                                        SubscriptionDeletedStrategy
                                    </button>
                                </h2>
                                <div id="collapseSubscriptionDeleted" class="accordion-collapse collapse" aria-labelledby="headingSubscriptionDeleted" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>customer.subscription.deleted</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>SubscriptionRepository</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Procesa la cancelación definitiva de una suscripción, ya sea:</li>
                                            <ul>
                                                <li>Por cancelación inmediata solicitada por el cliente o administrador.</li>
                                                <li>Por finalización del periodo actual en una suscripción previamente marcada para cancelación.</li>
                                                <li>Por fallo en el pago después de varios intentos de renovación.</li>
                                            </ul>
                                            <li>Actualiza el estado de la suscripción a "canceled" en la base de datos.</li>
                                            <li>Registra las fechas de cancelación y finalización.</li>
                                        </ul>
                                        <div class="alert alert-info mt-3">
                                            <i class="fas fa-info-circle"></i> <strong>Impacto:</strong> El procesamiento correcto de este evento es crucial para actualizar los permisos de acceso del usuario. Cuando se recibe este evento, se debe revocar el acceso a funcionalidades premium o contenido restringido que requería una suscripción activa.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- InvoicePaidStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingInvoicePaid">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInvoicePaid" aria-expanded="false" aria-controls="collapseInvoicePaid">
                                        InvoicePaidStrategy
                                    </button>
                                </h2>
                                <div id="collapseInvoicePaid" class="accordion-collapse collapse" aria-labelledby="headingInvoicePaid" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>invoice.paid</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>TransactionRepository</code>, <code>SubscriptionRepository</code>, <code>TransactionFactory</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Procesa facturas pagadas, que pueden corresponder a:</li>
                                            <ul>
                                                <li>El pago inicial de una nueva suscripción.</li>
                                                <li>Renovaciones periódicas de suscripciones existentes.</li>
                                            </ul>
                                            <li>Extrae detalles importantes de la factura: importe, cliente, descripción, referencias a la suscripción.</li>
                                            <li>Crea un registro de transacción de tipo SUBSCRIPTION en la base de datos.</li>
                                            <li>Si la factura corresponde a una renovación, actualiza el periodo actual de la suscripción.</li>
                                        </ul>
                                        <div class="alert alert-success mt-3">
                                            <i class="fas fa-check-circle"></i> <strong>Importancia:</strong> Este evento es fundamental para el seguimiento financiero de las suscripciones, ya que confirma cada pago recurrente. También permite mantener un historial completo de todos los pagos realizados por cada suscripción.
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="alert alert-info">
                    <i class="fas fa-cogs"></i> <strong>Arquitectura de Estrategias:</strong>
                    <p>El sistema de estrategias en StripeLabApp utiliza la Factory Method para crear las estrategias adecuadas según el tipo de evento. Esto permite una fácil extensión para soportar nuevos tipos de eventos simplemente añadiendo nuevas clases de estrategia sin modificar el código existente.</p>
                    <p>Cada estrategia se enfoca en una responsabilidad específica, siguiendo el principio de responsabilidad única, lo que facilita el mantenimiento y las pruebas unitarias.</p>
                </div>
            </div>

            <div id="mappers" class="subsection">
                <h4>7.8. Mappers (src/Mappers/)</h4>
                <p>
                    Los Mappers son responsables de transformar entre diferentes representaciones de datos, principalmente de objetos de dominio (Models) a DTOs y viceversa, así como de convertir payloads de eventos de Stripe a estructuras internas.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Rol principal de los Mappers</strong>
                    </div>
                    <div class="card-body">
                        <p>Los Mappers en StripeLabApp cumplen varias funciones clave:</p>
                        <ul>
                            <li><strong>Transformar objetos Stripe</strong> (con estructuras complejas y anidadas) en objetos propios de la aplicación.</li>
                            <li><strong>Convertir Models a DTOs</strong> para presentación en la interfaz de usuario, eliminando campos innecesarios o sensibles.</li>
                            <li><strong>Estandarizar formatos</strong> para fechas, monedas y valores enumerados.</li>
                            <li><strong>Manejar campos opcionales o nulos</strong> de manera segura.</li>
                            <li><strong>Extraer información relevante</strong> de estructuras de datos anidadas.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class SubscriptionMapper
{
   /**
    * Convierte un objeto SubscriptionsModel a SubscriptionDTO
    */
   public function toDto(SubscriptionsModel $model): SubscriptionDTO
   {
       $dto = new SubscriptionDTO();
       $dto->id = $model->transaction_id ?? 0;
       $dto->subscriptionId = $model->subscription_id;
       $dto->customerId = $model->customer_id;
       $dto->status = $model->status;
       $dto->planId = $model->plan_id;
       $dto->planName = $model->plan_name;
       $dto->amount = $model->amount;
       $dto->currency = $model->currency;
       $dto->interval = $model->interval;
       $dto->currentPeriodStart = $model->current_period_start;
       $dto->currentPeriodEnd = $model->current_period_end;
       $dto->canceledAt = $model->canceled_at;
       $dto->cancelAtPeriodEnd = $model->cancel_at_period_end;
       $dto->createdAt = $model->created_at;
       $dto->endedAt = $model->ended_at;

       return $dto;
   }

   /**
    * Extrae información de suscripción de un evento Stripe
    */
   public function fromStripeEvent(\Stripe\Event $event): SubscriptionDTO
   {
       // Asegurarse de que el objeto es una suscripción
       if ($event->data->object->object !== 'subscription') {
           throw new InvalidWebhookPayloadException('Object is not a subscription');
       }

       $subscription = $event->data->object;

       $dto = new SubscriptionDTO();
       $dto->subscriptionId = $subscription->id;
       $dto->customerId = $subscription->customer;
       $dto->status = $subscription->status;

       // Extraer información del plan (puede estar anidada en 'items')
       if (!empty($subscription->plan)) {
           $plan = $subscription->plan;
           $dto->planId = $plan->id;
           $dto->planName = $plan->nickname ?? 'Plan ' . $plan->id;
           $dto->amount = $plan->amount / 100; // Convertir de centavos a unidades
           $dto->currency = $plan->currency;
           $dto->interval = $plan->interval;
       } elseif (!empty($subscription->items->data[0]->plan)) {
           $plan = $subscription->items->data[0]->plan;
           $dto->planId = $plan->id;
           $dto->planName = $plan->nickname ?? 'Plan ' . $plan->id;
           $dto->amount = $plan->amount / 100;
           $dto->currency = $plan->currency;
           $dto->interval = $plan->interval;
       }

       // Convertir timestamps Unix a objetos DateTime
       $dto->currentPeriodStart = new \DateTime('@' . $subscription->current_period_start);
       $dto->currentPeriodEnd = new \DateTime('@' . $subscription->current_period_end);
       $dto->createdAt = new \DateTime('@' . $subscription->created);

       // Manejar campos opcionales
       $dto->canceledAt = $subscription->canceled_at
           ? new \DateTime('@' . $subscription->canceled_at)
           : null;
       $dto->endedAt = $subscription->ended_at
           ? new \DateTime('@' . $subscription->ended_at)
           : null;
       $dto->cancelAtPeriodEnd = $subscription->cancel_at_period_end ?? false;

       return $dto;
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-warning mt-3">
                            <i class="fas fa-exclamation-triangle"></i> <strong>Desafío:</strong> Los payloads de Stripe pueden variar significativamente en estructura según el tipo de evento y la versión de la API. Los Mappers deben ser robustos ante estas variaciones, manejando correctamente campos opcionales y estructuras anidadas.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>TransactionMapper</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <code>TransactionMapper</code> es uno de los mappers más utilizados, ya que maneja las transacciones financieras que son el núcleo de la aplicación. Sus responsabilidades específicas incluyen:
                        </p>
                        <ul>
                            <li>Transformar objetos <code>TransactionsModel</code> a <code>TransactionDTO</code> para presentación.</li>
                            <li>Extraer información relevante de eventos <code>payment_intent.succeeded</code>, <code>charge.succeeded</code> e <code>invoice.paid</code>.</li>
                            <li>Formatear los importes, convirtiendo de centavos (formato de Stripe) a unidades.</li>
                            <li>Extraer detalles del método de pago a partir de estructuras anidadas complejas.</li>
                            <li>Manejar los diferentes tipos de transacción (PAYMENT, SUBSCRIPTION, REFUND).</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class TransactionMapper
{
   /**
    * Extrae información de un PaymentIntent de un evento Stripe
    */
   public function fromPaymentIntent(\Stripe\PaymentIntent $paymentIntent): TransactionDTO
   {
       $dto = new TransactionDTO();
       $dto->transactionId = $paymentIntent->id;
       $dto->customerId = $paymentIntent->customer ?? null;
       $dto->type = $paymentIntent->setup_future_usage === 'off_session'
           ? TransactionTypeEnum::SUBSCRIPTION->value
           : TransactionTypeEnum::PAYMENT->value;
       $dto->amount = $paymentIntent->amount / 100; // Convertir de centavos a unidades
       $dto->currency = $paymentIntent->currency;
       $dto->status = $paymentIntent->status === 'succeeded'
           ? TransactionStatusEnum::COMPLETED->value
           : TransactionStatusEnum::PENDING->value;
       $dto->createdAt = new \DateTime('@' . $paymentIntent->created);
       $dto->description = $paymentIntent->description;

       // Las URLs de recibo generalmente no están disponibles en el PaymentIntent,
       // se completarán posteriormente con el evento charge.succeeded
       $dto->receiptUrl = null;

       return $dto;
   }

   /**
    * Extrae información de un Charge de un evento Stripe
    */
   public function fromCharge(\Stripe\Charge $charge): array
   {
       $paymentMethodDetails = [];

       // Extraer detalles del método de pago
       if (!empty($charge->payment_method_details->card)) {
           $card = $charge->payment_method_details->card;
           $paymentMethodDetails = [
               'type' => 'card',
               'brand' => $card->brand,
               'last4' => $card->last4,
               'exp_month' => $card->exp_month,
               'exp_year' => $card->exp_year,
               'country' => $card->country,
               'checks' => [
                   'cvc_check' => $card->checks->cvc_check ?? null,
                   'address_line1_check' => $card->checks->address_line1_check ?? null,
                   'address_postal_code_check' => $card->checks->address_postal_code_check ?? null,
               ]
           ];
       }

       return [
           'transaction_id' => $charge->payment_intent ?? $charge->id,
           'receipt_url' => $charge->receipt_url,
           'payment_method_details' => json_encode($paymentMethodDetails)
       ];
   }

   /**
    * Convierte un objeto TransactionsModel a TransactionDTO
    */
   public function toDto(TransactionsModel $model): TransactionDTO
   {
       $dto = new TransactionDTO();
       $dto->id = $model->transaction_id;
       $dto->transactionId = $model->stripe_transaction_id;
       $dto->customerId = $model->stripe_customer_id;
       $dto->type = $model->transaction_type;
       $dto->amount = $model->amount;
       $dto->currency = $model->currency;
       $dto->status = $model->status;
       $dto->paymentMethodDetails = $model->payment_method_details;
       $dto->receiptUrl = $model->receipt_url;
       $dto->createdAt = $model->created_at;
       $dto->description = $model->description;

       return $dto;
   }

   // ... otros métodos para diferentes fuentes de datos
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Ventaja:</strong> Al centralizar la lógica de transformación de datos en mappers dedicados, StripeLabApp consigue un código más limpio, más fácil de mantener y probar. Cada Mapper sigue el principio de responsabilidad única, enfocándose únicamente en la transformación de un tipo específico de datos.
                        </div>
                    </div>
                </div>
            </div>

            <div id="factories" class="subsection">
                <h4>7.9. Factories (src/Factories/)</h4>
                <p>
                    Las Factories son responsables de crear instancias de objetos complejos, especialmente entidades de dominio, a partir de DTOs o datos externos como los payloads de Stripe.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Rol principal de las Factories</strong>
                    </div>
                    <div class="card-body">
                        <p>Las Factories en StripeLabApp cumplen varias funciones importantes:</p>
                        <ul>
                            <li><strong>Crear instancias de entidades</strong> (Models) a partir de DTOs o payloads externos.</li>
                            <li><strong>Manejar conversiones complejas</strong> de tipos (timestamps a DateTime, strings a Enums, etc.).</li>
                            <li><strong>Garantizar la integridad de los datos</strong> aplicando validaciones y valores por defecto.</li>
                            <li><strong>Centralizar la lógica de creación</strong> para evitar duplicación en el código.</li>
                            <li><strong>Facilitar las pruebas unitarias</strong> al aislar la lógica de creación.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class TransactionFactory
{
   /**
    * Crea un TransactionsModel a partir de un TransactionDTO
    */
   public function createFromDto(TransactionDTO $dto): TransactionsModel
   {
       $model = new TransactionsModel();

       // Solo asignar transaction_id si ya existe (para actualizaciones)
       if ($dto->id > 0) {
           $model->transaction_id = $dto->id;
       }

       $model->stripe_transaction_id = $dto->transactionId;
       $model->stripe_customer_id = $dto->customerId;

       // Convertir el tipo de string a Enum (si se usa PHP 8.1+)
       $model->transaction_type = $dto->type;

       $model->amount = $dto->amount;
       $model->currency = strtolower($dto->currency);
       $model->status = $dto->status;
       $model->payment_method_details = $dto->paymentMethodDetails;
       $model->receipt_url = $dto->receiptUrl;

       // Convertir DateTime a DateTimeImmutable
       $model->created_at = DateTimeImmutable::createFromMutable($dto->createdAt);

       $model->description = $dto->description;

       return $model;
   }

   /**
    * Crea un TransactionsModel a partir de un PaymentIntent de Stripe
    */
   public function createFromPaymentIntent(\Stripe\PaymentIntent $paymentIntent): TransactionsModel
   {
       $model = new TransactionsModel();
       $model->stripe_transaction_id = $paymentIntent->id;
       $model->stripe_customer_id = $paymentIntent->customer ?? null;

       // Determinar el tipo de transacción basado en metadata o comportamiento
       $model->transaction_type = $paymentIntent->setup_future_usage === 'off_session'
           ? TransactionTypeEnum::SUBSCRIPTION->value
           : TransactionTypeEnum::PAYMENT->value;

       // Convertir de centavos a unidades
       $model->amount = $paymentIntent->amount / 100;
       $model->currency = strtolower($paymentIntent->currency);

       // Determinar el estado
       $model->status = $paymentIntent->status === 'succeeded'
           ? TransactionStatusEnum::COMPLETED->value
           : TransactionStatusEnum::PENDING->value;

       // Las URLs de recibo generalmente no están disponibles en el PaymentIntent
       $model->receipt_url = null;

       // Convertir timestamp a DateTimeImmutable
       $model->created_at = new DateTimeImmutable('@' . $paymentIntent->created);

       $model->description = $paymentIntent->description;

       return $model;
   }

   /**
    * Crea un TransactionsModel a partir de una Invoice de Stripe
    */
   public function createFromInvoice(\Stripe\Invoice $invoice): TransactionsModel
   {
       $model = new TransactionsModel();
       $model->stripe_transaction_id = $invoice->payment_intent ?? $invoice->id;
       $model->stripe_customer_id = $invoice->customer;

       // Las facturas pagadas generalmente corresponden a suscripciones
       $model->transaction_type = TransactionTypeEnum::SUBSCRIPTION->value;

       // Convertir de centavos a unidades
       $model->amount = $invoice->amount_paid / 100;
       $model->currency = strtolower($invoice->currency);

       // Determinar el estado basado en el estado de la factura
       $model->status = $invoice->status === 'paid'
           ? TransactionStatusEnum::COMPLETED->value
           : TransactionStatusEnum::PENDING->value;

       // URLs y detalles adicionales
       $model->receipt_url = null; // Se completará con el evento charge.succeeded
       $model->payment_method_details = null; // Se completará con el evento charge.succeeded

       // Convertir timestamp a DateTimeImmutable
       $model->created_at = new DateTimeImmutable('@' . $invoice->created);

       // Crear una descripción basada en la suscripción
       if ($invoice->subscription) {
           $model->description = "Payment for subscription " . $invoice->subscription;
       } else {
           $model->description = "Invoice payment " . $invoice->number;
       }

       return $model;
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-lightbulb"></i> <strong>Diseño:</strong> Las Factories implementan el patrón Factory Method, proporcionando múltiples métodos para crear el mismo tipo de objeto a partir de diferentes fuentes de datos. Esto hace que el código sea más flexible y adaptable a diferentes escenarios.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>StripeEventStrategyFactory</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <code>StripeEventStrategyFactory</code> es particularmente importante, ya que implementa la creación dinámica de estrategias basada en el tipo de evento recibido. Sus responsabilidades incluyen:
                        </p>
                        <ul>
                            <li>Determinar qué estrategia debe manejar cada tipo de evento de Stripe.</li>
                            <li>Crear y configurar la instancia de estrategia apropiada con sus dependencias.</li>
                            <li>Manejar casos donde no existe una estrategia específica para un tipo de evento.</li>
                            <li>Centralizar la lógica de mapeo entre tipos de eventos y sus estrategias.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class StripeEventStrategyFactory
{
   private TransactionRepository $transactionRepository;
   private SubscriptionRepository $subscriptionRepository;
   private TransactionFactory $transactionFactory;
   private SubscriptionFactory $subscriptionFactory;
   private TransactionMapper $transactionMapper;
   private SubscriptionMapper $subscriptionMapper;
   private EventLogger $eventLogger;
   private ErrorLogger $errorLogger;
   private UnhandledStripeEventLogger $unhandledEventLogger;

   public function __construct(
       TransactionRepository $transactionRepository,
       SubscriptionRepository $subscriptionRepository,
       TransactionFactory $transactionFactory,
       SubscriptionFactory $subscriptionFactory,
       TransactionMapper $transactionMapper,
       SubscriptionMapper $subscriptionMapper,
       EventLogger $eventLogger,
       ErrorLogger $errorLogger,
       UnhandledStripeEventLogger $unhandledEventLogger
   ) {
       $this->transactionRepository = $transactionRepository;
       $this->subscriptionRepository = $subscriptionRepository;
       $this->transactionFactory = $transactionFactory;
       $this->subscriptionFactory = $subscriptionFactory;
       $this->transactionMapper = $transactionMapper;
       $this->subscriptionMapper = $subscriptionMapper;
       $this->eventLogger = $eventLogger;
       $this->errorLogger = $errorLogger;
       $this->unhandledEventLogger = $unhandledEventLogger;
   }

   /**
    * Crea la estrategia adecuada para el tipo de evento dado
    */
   public function createStrategy(string $eventType): ?StripeEventStrategyInterface
   {
       // Normalizar el tipo de evento para usar Enum
       $eventType = strtolower($eventType);

       // Mapeo de tipos de eventos a clases de estrategia
       $strategyMap = [
           StripeEventTypeEnum::CHECKOUT_SESSION_COMPLETED->value => CheckoutSessionCompletedStrategy::class,
           StripeEventTypeEnum::PAYMENT_INTENT_SUCCEEDED->value => PaymentIntentSucceededStrategy::class,
           StripeEventTypeEnum::CHARGE_SUCCEEDED->value => ChargeSucceededStrategy::class,
           StripeEventTypeEnum::CUSTOMER_CREATED->value => CustomerCreatedOrUpdatedStrategy::class,
           StripeEventTypeEnum::CUSTOMER_UPDATED->value => CustomerCreatedOrUpdatedStrategy::class,
           StripeEventTypeEnum::CUSTOMER_SUBSCRIPTION_CREATED->value => SubscriptionCreatedStrategy::class,
           StripeEventTypeEnum::CUSTOMER_SUBSCRIPTION_UPDATED->value => SubscriptionUpdatedStrategy::class,
           StripeEventTypeEnum::CUSTOMER_SUBSCRIPTION_DELETED->value => SubscriptionDeletedStrategy::class,
           StripeEventTypeEnum::INVOICE_PAID->value => InvoicePaidStrategy::class,
       ];

       // Si no hay una estrategia específica para este tipo de evento, devolver null
       if (!isset($strategyMap[$eventType])) {
           return null;
       }

       // Crear la estrategia basada en el tipo de evento
       $strategyClass = $strategyMap[$eventType];

       // Configurar las dependencias específicas para cada tipo de estrategia
       switch ($strategyClass) {
           case CheckoutSessionCompletedStrategy::class:
               return new CheckoutSessionCompletedStrategy(
                   $this->transactionRepository,
                   $this->transactionFactory,
                   $this->eventLogger,
                   $this->errorLogger
               );

           case PaymentIntentSucceededStrategy::class:
               return new PaymentIntentSucceededStrategy(
                   $this->transactionRepository,
                   $this->transactionFactory,
                   $this->transactionMapper,
                   $this->eventLogger,
                   $this->errorLogger
               );

           case ChargeSucceededStrategy::class:
               return new ChargeSucceededStrategy(
                   $this->transactionRepository,
                   $this->transactionMapper,
                   $this->eventLogger,
                   $this->errorLogger
               );

           case SubscriptionCreatedStrategy::class:
               return new SubscriptionCreatedStrategy(
                   $this->subscriptionRepository,
                   $this->subscriptionFactory,
                   $this->subscriptionMapper,
                   $this->eventLogger,
                   $this->errorLogger
               );

           // ... casos similares para otras estrategias

           default:
               return null;
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Flexibilidad:</strong> Esta implementación permite añadir soporte para nuevos tipos de eventos simplemente actualizando el mapeo en <code>$strategyMap</code> y creando la nueva clase de estrategia correspondiente, sin necesidad de modificar el código existente (principio Open/Closed).
                        </div>
                    </div>
                </div>
            </div>

            <div id="repositories" class="subsection">
                <h4>7.10. Repositories (src/Repository/)</h4>
                <p>
                    Los Repositories en StripeLabApp abstraen la capa de persistencia, proporcionando una interfaz orientada a objetos para realizar operaciones CRUD y consultas específicas sobre las entidades del dominio.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Rol principal de los Repositories</strong>
                    </div>
                    <div class="card-body">
                        <p>Los Repositories cumplen varias funciones esenciales:</p>
                        <ul>
                            <li><strong>Abstraer la tecnología de base de datos</strong> subyacente (MySQL, en este caso).</li>
                            <li><strong>Implementar operaciones CRUD</strong> básicas (Create, Read, Update, Delete) para cada entidad.</li>
                            <li><strong>Proporcionar métodos de búsqueda especializados</strong> basados en criterios específicos del dominio.</li>
                            <li><strong>Gestionar transacciones</strong> y garantizar la integridad de los datos.</li>
                            <li><strong>Centralizar la lógica de acceso a datos</strong> y prevenir la duplicación de consultas SQL.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class TransactionRepository
{
   private \PDO $pdo;
   private DatabaseLogger $logger;

   public function __construct(\PDO $pdo, DatabaseLogger $logger)
   {
       $this->pdo = $pdo;
       $this->logger = $logger;
   }

   /**
    * Guarda una nueva transacción en la base de datos
    */
   public function save(TransactionsModel $transaction): bool
   {
       try {
           $sql = "INSERT INTO transactions (
                       stripe_transaction_id, stripe_customer_id, transaction_type,
                       amount, currency, status, payment_method_details,
                       receipt_url, created_at, description
                   ) VALUES (
                       :stripe_transaction_id, :stripe_customer_id, :transaction_type,
                       :amount, :currency, :status, :payment_method_details,
                       :receipt_url, :created_at, :description
                   )";

           $stmt = $this->pdo->prepare($sql);

           $createdAt = $transaction->created_at->format('Y-m-d H:i:s');

           $params = [
               ':stripe_transaction_id' => $transaction->stripe_transaction_id,
               ':stripe_customer_id' => $transaction->stripe_customer_id,
               ':transaction_type' => $transaction->transaction_type,
               ':amount' => $transaction->amount,
               ':currency' => $transaction->currency,
               ':status' => $transaction->status,
               ':payment_method_details' => $transaction->payment_method_details,
               ':receipt_url' => $transaction->receipt_url,
               ':created_at' => $createdAt,
               ':description' => $transaction->description,
           ];

           $result = $stmt->execute($params);

           if ($result) {
               // Asignar el ID generado automáticamente
               $transaction->transaction_id = (int)$this->pdo->lastInsertId();
               $this->logger->log("Transacción guardada: {$transaction->stripe_transaction_id} (ID: {$transaction->transaction_id})");
           }

           return $result;
       } catch (\PDOException $e) {
           $this->logger->log("Error al guardar transacción: " . $e->getMessage());
           throw new DatabaseException("Error al guardar transacción: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Actualiza una transacción existente
    */
   public function update(TransactionsModel $transaction): bool
   {
       try {
           $sql = "UPDATE transactions SET
                       stripe_customer_id = :stripe_customer_id,
                       transaction_type = :transaction_type,
                       amount = :amount,
                       currency = :currency,
                       status = :status,
                       payment_method_details = :payment_method_details,
                       receipt_url = :receipt_url,
                       description = :description
                   WHERE stripe_transaction_id = :stripe_transaction_id";

           $stmt = $this->pdo->prepare($sql);

           $params = [
               ':stripe_transaction_id' => $transaction->stripe_transaction_id,
               ':stripe_customer_id' => $transaction->stripe_customer_id,
               ':transaction_type' => $transaction->transaction_type,
               ':amount' => $transaction->amount,
               ':currency' => $transaction->currency,
               ':status' => $transaction->status,
               ':payment_method_details' => $transaction->payment_method_details,
               ':receipt_url' => $transaction->receipt_url,
               ':description' => $transaction->description
           ];

           $result = $stmt->execute($params);

           if ($result) {
               $this->logger->log("Transacción actualizada: {$transaction->stripe_transaction_id}");
           }

           return $result;
       } catch (\PDOException $e) {
           $this->logger->log("Error al actualizar transacción: " . $e->getMessage());
           throw new DatabaseException("Error al actualizar transacción: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Busca una transacción por su ID de Stripe
    */
   public function findByStripeId(string $stripeId): ?TransactionsModel
   {
       try {
           $sql = "SELECT * FROM transactions WHERE stripe_transaction_id = :stripe_id";
           $stmt = $this->pdo->prepare($sql);
           $stmt->execute([':stripe_id' => $stripeId]);

           $data = $stmt->fetch(\PDO::FETCH_ASSOC);

           if (!$data) {
               return null;
           }

           return $this->createModelFromData($data);
       } catch (\PDOException $e) {
           $this->logger->log("Error al buscar transacción: " . $e->getMessage());
           throw new DatabaseException("Error al buscar transacción: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Busca transacciones por ID de cliente
    */
   public function findByCustomerId(string $customerId): array
   {
       try {
           $sql = "SELECT * FROM transactions WHERE stripe_customer_id = :customer_id ORDER BY created_at DESC";
           $stmt = $this->pdo->prepare($sql);
           $stmt->execute([':customer_id' => $customerId]);

           $transactions = [];
           while ($data = $stmt->fetch(\PDO::FETCH_ASSOC)) {
               $transactions[] = $this->createModelFromData($data);
           }

           return $transactions;
       } catch (\PDOException $e) {
           $this->logger->log("Error al buscar transacciones por cliente: " . $e->getMessage());
           throw new DatabaseException("Error al buscar transacciones por cliente: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Obtiene todas las transacciones con paginación
    */
   public function findAll(int $limit = 10, int $offset = 0): array
   {
       try {
           $sql = "SELECT * FROM transactions ORDER BY created_at DESC LIMIT :limit OFFSET :offset";
           $stmt = $this->pdo->prepare($sql);
           $stmt->bindValue(':limit', $limit, \PDO::PARAM_INT);
           $stmt->bindValue(':offset', $offset, \PDO::PARAM_INT);
           $stmt->execute();

           $transactions = [];
           while ($data = $stmt->fetch(\PDO::FETCH_ASSOC)) {
               $transactions[] = $this->createModelFromData($data);
           }

           return $transactions;
       } catch (\PDOException $e) {
           $this->logger->log("Error al obtener transacciones: " . $e->getMessage());
           throw new DatabaseException("Error al obtener transacciones: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Crea un modelo a partir de datos de la base de datos
    */
   private function createModelFromData(array $data): TransactionsModel
   {
       $model = new TransactionsModel();
       $model->transaction_id = (int)$data['transaction_id'];
       $model->stripe_transaction_id = $data['stripe_transaction_id'];
       $model->stripe_customer_id = $data['stripe_customer_id'];
       $model->transaction_type = $data['transaction_type'];
       $model->amount = (float)$data['amount'];
       $model->currency = $data['currency'];
       $model->status = $data['status'];
       $model->payment_method_details = $data['payment_method_details'];
       $model->receipt_url = $data['receipt_url'];
       $model->created_at = new \DateTimeImmutable($data['created_at']);
       $model->description = $data['description'];

       return $model;
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-database"></i> <strong>Manejo de IDs:</strong> Observe que <code>TransactionRepository</code> maneja un ID autoincremental (<code>transaction_id</code>) que se asigna automáticamente al guardar, mientras que <code>SubscriptionRepository</code> utiliza el ID de Stripe como clave primaria natural. Esto refleja la naturaleza diferente de estas entidades: las transacciones son registros internos que pueden existir sin un ID de Stripe (por ejemplo, para pagos manuales), mientras que las suscripciones siempre están vinculadas a una suscripción específica en Stripe.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>SubscriptionRepository</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <code>SubscriptionRepository</code> gestiona la persistencia de suscripciones, que tienen consideraciones específicas diferentes a las transacciones:
                        </p>
                        <ul>
                            <li><strong>Clave primaria natural:</strong> Utiliza el ID de Stripe (<code>subscription_id</code>) como clave primaria en lugar de un autoincremental.</li>
                            <li><strong>Actualizaciones frecuentes:</strong> Las suscripciones se actualizan regularmente (cambios de estado, renovaciones, etc.).</li>
                            <li><strong>Fechas críticas:</strong> Gestiona múltiples fechas importantes (creación, inicio de periodo, fin de periodo, cancelación).</li>
                            <li><strong>Estados específicos:</strong> Incluye campos para estados especiales como <code>cancel_at_period_end</code>.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class SubscriptionRepository
{
   private \PDO $pdo;
   private DatabaseLogger $logger;

   public function __construct(\PDO $pdo, DatabaseLogger $logger)
   {
       $this->pdo = $pdo;
       $this->logger = $logger;
   }

   /**
    * Guarda una nueva suscripción
    */
   public function save(SubscriptionsModel $subscription): bool
   {
       try {
           $sql = "INSERT INTO subscriptions (
                       subscription_id, customer_id, status, plan_id, plan_name,
                       amount, currency, `interval`, current_period_start,
                       current_period_end, canceled_at, cancel_at_period_end,
                       created_at, ended_at
                   ) VALUES (
                       :subscription_id, :customer_id, :status, :plan_id, :plan_name,
                       :amount, :currency, :interval, :current_period_start,
                       :current_period_end, :canceled_at, :cancel_at_period_end,
                       :created_at, :ended_at
                   )";

           $stmt = $this->pdo->prepare($sql);

           $currentPeriodStart = $subscription->current_period_start->format('Y-m-d H:i:s');
           $currentPeriodEnd = $subscription->current_period_end->format('Y-m-d H:i:s');
           $createdAt = $subscription->created_at->format('Y-m-d H:i:s');
           $canceledAt = $subscription->canceled_at ? $subscription->canceled_at->format('Y-m-d H:i:s') : null;
           $endedAt = $subscription->ended_at ? $subscription->ended_at->format('Y-m-d H:i:s') : null;

           $params = [
               ':subscription_id' => $subscription->subscription_id,
               ':customer_id' => $subscription->customer_id,
               ':status' => $subscription->status,
               ':plan_id' => $subscription->plan_id,
               ':plan_name' => $subscription->plan_name,
               ':amount' => $subscription->amount,
               ':currency' => $subscription->currency,
               ':interval' => $subscription->interval,
               ':current_period_start' => $currentPeriodStart,
               ':current_period_end' => $currentPeriodEnd,
               ':canceled_at' => $canceledAt,
               ':cancel_at_period_end' => $subscription->cancel_at_period_end ? 1 : 0,
               ':created_at' => $createdAt,
               ':ended_at' => $endedAt
           ];

           $result = $stmt->execute($params);

           if ($result) {
               $this->logger->log("Suscripción guardada: {$subscription->subscription_id}");
           }

           return $result;
       } catch (\PDOException $e) {
           // Manejar el caso específico de duplicado (la suscripción ya existe)
           if ($e->getCode() == '23000') {
               // Actualizar en lugar de insertar si ya existe
               return $this->update($subscription);
           }

           $this->logger->log("Error al guardar suscripción: " . $e->getMessage());
           throw new DatabaseException("Error al guardar suscripción: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Actualiza una suscripción existente
    */
   public function update(SubscriptionsModel $subscription): bool
   {
       try {
           $sql = "UPDATE subscriptions SET
                       customer_id = :customer_id,
                       status = :status,
                       plan_id = :plan_id,
                       plan_name = :plan_name,
                       amount = :amount,
                       currency = :currency,
                       `interval` = :interval,
                       current_period_start = :current_period_start,
                       current_period_end = :current_period_end,
                       canceled_at = :canceled_at,
                       cancel_at_period_end = :cancel_at_period_end,
                       ended_at = :ended_at
                   WHERE subscription_id = :subscription_id";

           $stmt = $this->pdo->prepare($sql);

           $currentPeriodStart = $subscription->current_period_start->format('Y-m-d H:i:s');
           $currentPeriodEnd = $subscription->current_period_end->format('Y-m-d H:i:s');
           $canceledAt = $subscription->canceled_at ? $subscription->canceled_at->format('Y-m-d H:i:s') : null;
           $endedAt = $subscription->ended_at ? $subscription->ended_at->format('Y-m-d H:i:s') : null;

           $params = [
               ':subscription_id' => $subscription->subscription_id,
               ':customer_id' => $subscription->customer_id,
               ':status' => $subscription->status,
               ':plan_id' => $subscription->plan_id,
               ':plan_name' => $subscription->plan_name,
               ':amount' => $subscription->amount,
               ':currency' => $subscription->currency,
               ':interval' => $subscription->interval,
               ':current_period_start' => $currentPeriodStart,
               ':current_period_end' => $currentPeriodEnd,
               ':canceled_at' => $canceledAt,
               ':cancel_at_period_end' => $subscription->cancel_at_period_end ? 1 : 0,
               ':ended_at' => $endedAt
           ];

           $result = $stmt->execute($params);

           if ($result) {
               $this->logger->log("Suscripción actualizada: {$subscription->subscription_id}");
           }

           return $result;
       } catch (\PDOException $e) {
           $this->logger->log("Error al actualizar suscripción: " . $e->getMessage());
           throw new DatabaseException("Error al actualizar suscripción: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Busca una suscripción por su ID
    */
   public function findById(string $subscriptionId): ?SubscriptionsModel
   {
       try {
           $sql = "SELECT * FROM subscriptions WHERE subscription_id = :subscription_id";
           $stmt = $this->pdo->prepare($sql);
           $stmt->execute([':subscription_id' => $subscriptionId]);

           $data = $stmt->fetch(\PDO::FETCH_ASSOC);

           if (!$data) {
               return null;
           }

           return $this->createModelFromData($data);
       } catch (\PDOException $e) {
           $this->logger->log("Error al buscar suscripción: " . $e->getMessage());
           throw new DatabaseException("Error al buscar suscripción: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Busca suscripciones por ID de cliente
    */
   public function findByCustomerId(string $customerId): array
   {
       try {
           $sql = "SELECT * FROM subscriptions WHERE customer_id = :customer_id ORDER BY created_at DESC";
           $stmt = $this->pdo->prepare($sql);
           $stmt->execute([':customer_id' => $customerId]);

           $subscriptions = [];
           while ($data = $stmt->fetch(\PDO::FETCH_ASSOC)) {
               $subscriptions[] = $this->createModelFromData($data);
           }

           return $subscriptions;
       } catch (\PDOException $e) {
           $this->logger->log("Error al buscar suscripciones por cliente: " . $e->getMessage());
           throw new DatabaseException("Error al buscar suscripciones por cliente: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Obtiene todas las suscripciones
    */
   public function findAll(): array
   {
       try {
           $sql = "SELECT * FROM subscriptions ORDER BY created_at DESC";
           $stmt = $this->pdo->prepare($sql);
           $stmt->execute();

           $subscriptions = [];
           while ($data = $stmt->fetch(\PDO::FETCH_ASSOC)) {
               $subscriptions[] = $this->createModelFromData($data);
           }

           return $subscriptions;
       } catch (\PDOException $e) {
           $this->logger->log("Error al obtener suscripciones: " . $e->getMessage());
           throw new DatabaseException("Error al obtener suscripciones: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Busca suscripciones activas
    */
   public function findActiveSubscriptions(): array
   {
       try {
           $sql = "SELECT * FROM subscriptions WHERE status = 'active' ORDER BY created_at DESC";
           $stmt = $this->pdo->prepare($sql);
           $stmt->execute();

           $subscriptions = [];
           while ($data = $stmt->fetch(\PDO::FETCH_ASSOC)) {
               $subscriptions[] = $this->createModelFromData($data);
           }

           return $subscriptions;
       } catch (\PDOException $e) {
           $this->logger->log("Error al obtener suscripciones activas: " . $e->getMessage());
           throw new DatabaseException("Error al obtener suscripciones activas: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Crea un modelo a partir de datos de la base de datos
    */
   private function createModelFromData(array $data): SubscriptionsModel
   {
       $model = new SubscriptionsModel();
       $model->subscription_id = $data['subscription_id'];
       $model->customer_id = $data['customer_id'];
       $model->status = $data['status'];
       $model->plan_id = $data['plan_id'];
       $model->plan_name = $data['plan_name'];
       $model->amount = (float)$data['amount'];
       $model->currency = $data['currency'];
       $model->interval = $data['interval'];
       $model->current_period_start = new \DateTimeImmutable($data['current_period_start']);
       $model->current_period_end = new \DateTimeImmutable($data['current_period_end']);
       $model->canceled_at = $data['canceled_at'] ? new \DateTimeImmutable($data['canceled_at']) : null;
       $model->cancel_at_period_end = (bool)$data['cancel_at_period_end'];
       $model->created_at = new \DateTimeImmutable($data['created_at']);
       $model->ended_at = $data['ended_at'] ? new \DateTimeImmutable($data['ended_at']) : null;

       return $model;
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Diseño robusto:</strong> Los repositorios en StripeLabApp proporcionan una abstracción completa sobre la capa de persistencia, haciendo que el resto de la aplicación no necesite conocer los detalles de cómo se almacenan los datos. Esto facilita cambios en la implementación de almacenamiento sin afectar al resto del código.
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Sección 8 -->
        <section id="flujos-datos" class="mb-4">
            <h3>8. Flujos de Datos Específicos en StripeLabApp</h3>
            <p>
                En esta sección exploraremos los principales flujos de datos en StripeLabApp, siguiendo el recorrido completo desde la interfaz de usuario hasta la base de datos, pasando por todos los componentes relevantes.
            </p>

            <div id="flujo-pago-unico" class="subsection">
                <h4>8.1. Flujo de Pago Único</h4>
                <p>
                    El flujo de pago único muestra cómo StripeLabApp procesa un pago desde que el usuario lo inicia hasta que se completa y se registra en la base de datos.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Diagrama de Secuencia: Flujo de Pago Único</strong>
                    </div>
                    <div class="card-body">
                        <div class="mermaid-diagram">
                       <pre class="mermaid">
sequenceDiagram
   participant User as Usuario
   participant Frontend as Frontend (single-payment.php)
   participant CheckoutEndpoint as v1/create_payment_session.php
   participant CheckoutService as StripeCheckoutSessionService
   participant Stripe as Stripe API
   participant StripeCheckout as Stripe Checkout (Navegador)
   participant WebhookEndpoint as v1/webhook.php
   participant WebhookController as StripeWebhookController
   participant WebhookService as StripeWebhookService
   participant PIStrategy as PaymentIntentSucceededStrategy
   participant ChargeStrategy as ChargeSucceededStrategy
   participant Repository as TransactionRepository
   participant DB as Base de Datos

   User->>Frontend: 1. Selecciona Producto y Hace Clic en "Pagar"
   Frontend->>CheckoutEndpoint: 2. Solicita sesión de pago (POST)
   CheckoutEndpoint->>CheckoutService: 3. Llama a createPaymentSession()
   CheckoutService->>Stripe: 4. Crea Checkout Session (API call)
   Stripe-->>CheckoutService: 5. Devuelve Session ID
   CheckoutService-->>CheckoutEndpoint: 6. Devuelve Session ID
   CheckoutEndpoint-->>Frontend: 7. Devuelve Session ID (JSON)
   Frontend->>StripeCheckout: 8. Redirecciona con sessionId
   User->>StripeCheckout: 9. Completa formulario de pago
   StripeCheckout->>Stripe: 10. Envía datos de pago
   Stripe-->>StripeCheckout: 11. Confirma pago exitoso
   StripeCheckout->>Frontend: 12. Redirecciona a success_url

   Note over Stripe,WebhookEndpoint: Proceso asíncrono

   Stripe->>WebhookEndpoint: 13a. Envía evento payment_intent.succeeded
   WebhookEndpoint->>WebhookController: 14a. Pasa payload y firma
   WebhookController->>WebhookService: 15a. Verifica firma y procesa evento
   WebhookService->>PIStrategy: 16a. Delega a PaymentIntentSucceededStrategy
   PIStrategy->>Repository: 17a. Crea registro de transacción
   Repository->>DB: 18a. INSERT en tabla transactions
   Repository-->>PIStrategy: 19a. Confirma éxito
   PIStrategy-->>WebhookService: 20a. Devuelve éxito
   WebhookService-->>WebhookController: 21a. Devuelve éxito
   WebhookController-->>WebhookEndpoint: 22a. Devuelve código 200
   WebhookEndpoint-->>Stripe: 23a. Responde con código 200

   Stripe->>WebhookEndpoint: 13b. Envía evento charge.succeeded
   WebhookEndpoint->>WebhookController: 14b. Pasa payload y firma
   WebhookController->>WebhookService: 15b. Verifica firma y procesa evento
   WebhookService->>ChargeStrategy: 16b. Delega a ChargeSucceededStrategy
   ChargeStrategy->>Repository: 17b. Busca transacción por stripe_transaction_id
   Repository-->>ChargeStrategy: 18b. Devuelve modelo de transacción
   ChargeStrategy->>ChargeStrategy: 19b. Añade receipt_url y detalles de pago
   ChargeStrategy->>Repository: 20b. Actualiza la transacción
   Repository->>DB: 21b. UPDATE en tabla transactions
   Repository-->>ChargeStrategy: 22b. Confirma éxito
   ChargeStrategy-->>WebhookService: 23b. Devuelve éxito
   WebhookService-->>WebhookController: 24b. Devuelve éxito
   WebhookController-->>WebhookEndpoint: 25b. Devuelve código 200
   WebhookEndpoint-->>Stripe: 26b. Responde con código 200
                       </pre>
                        </div>
                    </div>
                </div>

                <div class="alert alert-info">
                    <i class="fas fa-info-circle"></i> <strong>Puntos clave en el flujo de pago único:</strong>
                    <ul>
                        <li>La interfaz de usuario inicia el flujo solicitando una sesión de Checkout a través del endpoint <code>create_payment_session.php</code>.</li>
                        <li>Stripe Checkout proporciona una interfaz segura y optimizada para la entrada de datos de tarjeta.</li>
                        <li>El procesamiento real ocurre de forma asíncrona mediante webhooks después de que el pago se complete.</li>
                        <li>Dos estrategias principales intervienen: <code>PaymentIntentSucceededStrategy</code> crea el registro inicial, y <code>ChargeSucceededStrategy</code> lo enriquece con detalles adicionales como la URL del recibo.</li>
                        <li>Todo el estado del pago se mantiene en Stripe hasta que llegan los webhooks, lo que hace que el flujo sea robusto ante interrupciones de red o recargas de página.</li>
                    </ul>
                </div>
            </div>

            <div id="flujo-nueva-suscripcion" class="subsection">
                <h4>8.2. Flujo de Nueva Suscripción</h4>
                <p>
                    El flujo de nueva suscripción es más complejo que el de pago único, ya que involucra múltiples eventos de webhook y afecta a varias entidades del sistema.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Diagrama de Secuencia: Flujo de Nueva Suscripción</strong>
                    </div>
                    <div class="card-body">
                        <div class="mermaid-diagram">
                       <pre class="mermaid">
sequenceDiagram
   participant User as Usuario
   participant Frontend as Frontend (subscriptions-payment.php)
   participant SubEndpoint as v1/create_subscription_session.php
   participant CheckoutService as StripeCheckoutSessionService
   participant Stripe as Stripe API
   participant StripeCheckout as Stripe Checkout (Navegador)
   participant WebhookEndpoint as v1/webhook.php
   participant WebhookController as StripeWebhookController
   participant WebhookService as StripeWebhookService
   participant CSStrategy as CheckoutSessionCompletedStrategy
   participant SubStrategy as SubscriptionCreatedStrategy
   participant IPStrategy as InvoicePaidStrategy
   participant SubRepo as SubscriptionRepository
   participant TransRepo as TransactionRepository
   participant DB as Base de Datos

   User->>Frontend: 1. Selecciona Plan y Hace Clic en "Suscribirse"
   Frontend->>SubEndpoint: 2. Solicita sesión de suscripción (POST)
   SubEndpoint->>CheckoutService: 3. Llama a createSubscriptionSession()
   CheckoutService->>Stripe: 4. Crea Checkout Session (API call)
   Stripe-->>CheckoutService: 5. Devuelve Session ID
   CheckoutService-->>SubEndpoint: 6. Devuelve Session ID
   SubEndpoint-->>Frontend: 7. Devuelve Session ID (JSON)
   Frontend->>StripeCheckout: 8. Redirecciona con sessionId
   User->>StripeCheckout: 9. Completa formulario de pago
   StripeCheckout->>Stripe: 10. Envía datos de pago
   Stripe-->>StripeCheckout: 11. Confirma suscripción exitosa
   StripeCheckout->>Frontend: 12. Redirecciona a success_url

   Note over Stripe,WebhookEndpoint: Proceso asíncrono (múltiples eventos)

   Stripe->>WebhookEndpoint: 13. Envía evento checkout.session.completed
   WebhookEndpoint->>WebhookController: 14. Pasa payload y firma
   WebhookController->>WebhookService: 15. Verifica firma y procesa evento
   WebhookService->>CSStrategy: 16. Delega a CheckoutSessionCompletedStrategy
   CSStrategy->>CSStrategy: 17. Registra metadata de la sesión
   CSStrategy-->>WebhookService: 18. Devuelve éxito
   WebhookService-->>WebhookController: 19. Devuelve éxito
   WebhookController-->>WebhookEndpoint: 20. Devuelve código 200
   WebhookEndpoint-->>Stripe: 21. Responde con código 200

   Stripe->>WebhookEndpoint: 22. Envía evento customer.subscription.created
   WebhookEndpoint->>WebhookController: 23. Pasa payload y firma
   WebhookController->>WebhookService: 24. Verifica firma y procesa evento
   WebhookService->>SubStrategy: 25. Delega a SubscriptionCreatedStrategy
   SubStrategy->>SubRepo: 26. Crea registro de suscripción
   SubRepo->>DB: 27. INSERT en tabla subscriptions
   SubRepo-->>SubStrategy: 28. Confirma éxito
   SubStrategy-->>WebhookService: 29. Devuelve éxito
   WebhookService-->>WebhookController: 30. Devuelve éxito
   WebhookController-->>WebhookEndpoint: 31. Devuelve código 200
   WebhookEndpoint-->>Stripe: 32. Responde con código 200

   Stripe->>WebhookEndpoint: 33. Envía evento invoice.paid
   WebhookEndpoint->>WebhookController: 34. Pasa payload y firma
   WebhookController->>WebhookService: 35. Verifica firma y procesa evento
   WebhookService->>IPStrategy: 36. Delega a InvoicePaidStrategy
   IPStrategy->>TransRepo: 37. Crea registro de transacción de suscripción
   TransRepo->>DB: 38. INSERT en tabla transactions
   TransRepo-->>IPStrategy: 39. Confirma éxito
   IPStrategy-->>WebhookService: 40. Devuelve éxito
   WebhookService-->>WebhookController: 41. Devuelve éxito
   WebhookController-->>WebhookEndpoint: 42. Devuelve código 200
   WebhookEndpoint-->>Stripe: 43. Responde con código 200
                       </pre>
                        </div>
                    </div>
                </div>

                <div class="alert alert-info">
                    <i class="fas fa-info-circle"></i> <strong>Puntos clave en el flujo de nueva suscripción:</strong>
                    <ul>
                        <li>Similar al flujo de pago único, el proceso comienza con la creación de una sesión de Checkout, pero configurada para suscripciones.</li>
                        <li>Tres eventos principales de webhook son procesados por diferentes estrategias:</li>
                        <ul>
                            <li><code>checkout.session.completed</code>: Indica que el usuario ha completado el formulario de pago.</li>
                            <li><code>customer.subscription.created</code>: Registra la nueva suscripción en la base de datos.</li>
                            <li><code>invoice.paid</code>: Registra el pago inicial de la suscripción como una transacción.</li>
                        </ul>
                        <li>El orden de llegada de estos eventos no está garantizado, por lo que cada estrategia debe ser independiente y resistente a recibir eventos fuera de secuencia.</li>
                        <li>Se crean entradas tanto en la tabla <code>subscriptions</code> como en <code>transactions</code>, vinculadas por el ID del cliente y de la suscripción.</li>
                    </ul>
                </div>
            </div>

            <div id="flujo-cancelacion-suscripcion" class="subsection">
                <h4>8.3. Flujo de Cancelación de Suscripción</h4>
                <p>
                    El flujo de cancelación de suscripción muestra cómo StripeLabApp maneja las solicitudes de cancelación, ya sea inmediata o al final del periodo actual.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Diagrama de Secuencia: Flujo de Cancelación de Suscripción</strong>
                    </div>
                    <div class="card-body">
                        <div class="mermaid-diagram">
                       <pre class="mermaid">
sequenceDiagram
   participant User as Usuario
   participant Frontend as Frontend (view-subscriptions.php)
   participant ManageEndpoint as v1/api/api-manage-subscription.php
   participant ManageController as SubscriptionManagementController
   participant ManageService as StripeSubscriptionManagementService
   participant Stripe as Stripe API
   participant WebhookEndpoint as v1/webhook.php
   participant WebhookController as StripeWebhookController
   participant WebhookService as StripeWebhookService
   participant UpdStrategy as SubscriptionUpdatedStrategy
   participant DelStrategy as SubscriptionDeletedStrategy
   participant SubRepo as SubscriptionRepository
   participant DB as Base de Datos

   alt Cancelación al final del periodo
       User->>Frontend: 1. Hace clic en "Cancelar al final del periodo"
       Frontend->>ManageEndpoint: 2. POST con subscription_id y cancel_at_period_end=true
       ManageEndpoint->>ManageController: 3. Llama a cancelSubscription()
       ManageController->>ManageService: 4. Llama a cancelSubscription(id, true)
       ManageService->>Stripe: 5. update() con cancel_at_period_end=true
       Stripe-->>ManageService: 6. Devuelve suscripción actualizada
       ManageService->>SubRepo: 7. Actualiza suscripción localmente
       SubRepo->>DB: 8. UPDATE tabla subscriptions
       SubRepo-->>ManageService: 9. Confirma éxito
       ManageService-->>ManageController: 10. Devuelve datos actualizados
       ManageController-->>ManageEndpoint: 11. Devuelve respuesta de éxito
       ManageEndpoint-->>Frontend: 12. Devuelve JSON con estado
       Frontend->>User: 13. Muestra confirmación

       Note over Stripe,WebhookEndpoint: Proceso asíncrono

       Stripe->>WebhookEndpoint: 14. Envía evento customer.subscription.updated
       WebhookEndpoint->>WebhookController: 15. Pasa payload y firma
       WebhookController->>WebhookService: 16. Verifica firma y procesa evento
       WebhookService->>UpdStrategy: 17. Delega a SubscriptionUpdatedStrategy
       UpdStrategy->>UpdStrategy: 18. Detecta cancel_at_period_end=true
       UpdStrategy->>SubRepo: 19. Busca suscripción por ID
       SubRepo-->>UpdStrategy: 20. Devuelve modelo de suscripción
       UpdStrategy->>SubRepo: 21. Actualiza estado de cancelación
       SubRepo->>DB: 22. UPDATE cancel_at_period_end=1
       SubRepo-->>UpdStrategy: 23. Confirma éxito
       UpdStrategy-->>WebhookService: 24. Devuelve éxito
       WebhookService-->>WebhookController: 25. Devuelve éxito
       WebhookController-->>WebhookEndpoint: 26. Devuelve código 200
       WebhookEndpoint-->>Stripe: 27. Responde con código 200

       Note over Stripe,WebhookEndpoint: Al finalizar el periodo

       Stripe->>WebhookEndpoint: 28. Envía evento customer.subscription.deleted
       WebhookEndpoint->>WebhookController: 29. Pasa payload y firma
       WebhookController->>WebhookService: 30. Verifica firma y procesa evento
       WebhookService->>DelStrategy: 31. Delega a SubscriptionDeletedStrategy
       DelStrategy->>SubRepo: 32. Busca suscripción por ID
       SubRepo-->>DelStrategy: 33. Devuelve modelo de suscripción
       DelStrategy->>SubRepo: 34. Actualiza estado a "canceled"
       SubRepo->>DB: 35. UPDATE status="canceled", ended_at=now()
       SubRepo-->>DelStrategy: 36. Confirma éxito
       DelStrategy-->>WebhookService: 37. Devuelve éxito
       WebhookService-->>WebhookController: 38. Devuelve éxito
       WebhookController-->>WebhookEndpoint: 39. Devuelve código 200
       WebhookEndpoint-->>Stripe: 40. Responde con código 200
   else Cancelación inmediata
       User->>Frontend: 1. Hace clic en "Cancelar ahora"
       Frontend->>ManageEndpoint: 2. POST con subscription_id y cancel_at_period_end=false
       ManageEndpoint->>ManageController: 3. Llama a cancelSubscription()
       ManageController->>ManageService: 4. Llama a cancelSubscription(id, false)
       ManageService->>Stripe: 5. retrieve() + cancel()
       Stripe-->>ManageService: 6. Devuelve suscripción cancelada
       ManageService->>SubRepo: 7. Actualiza suscripción localmente
       SubRepo->>DB: 8. UPDATE tabla subscriptions
       SubRepo-->>ManageService: 9. Confirma éxito
       ManageService-->>ManageController: 10. Devuelve datos actualizados
       ManageController-->>ManageEndpoint: 11. Devuelve respuesta de éxito
       ManageEndpoint-->>Frontend: 12. Devuelve JSON con estado
       Frontend->>User: 13. Muestra confirmación

       Note over Stripe,WebhookEndpoint: Proceso asíncrono

       Stripe->>WebhookEndpoint: 14. Envía evento customer.subscription.deleted
       WebhookEndpoint->>WebhookController: 15. Pasa payload y firma
       WebhookController->>WebhookService: 16. Verifica firma y procesa evento
       WebhookService->>DelStrategy: 17. Delega a SubscriptionDeletedStrategy
       DelStrategy->>SubRepo: 18. Busca suscripción por ID
       SubRepo-->>DelStrategy: 19. Devuelve modelo de suscripción
       DelStrategy->>SubRepo: 20. Actualiza estado a "canceled"
       SubRepo->>DB: 21. UPDATE status="canceled", ended_at=now()
       SubRepo-->>DelStrategy: 22. Confirma éxito
       DelStrategy-->>WebhookService: 23. Devuelve éxito
       WebhookService-->>WebhookController: 24. Devuelve éxito
       WebhookController-->>WebhookEndpoint: 25. Devuelve código 200
       WebhookEndpoint-->>Stripe: 26. Responde con código 200
   end
                       </pre>
                        </div>
                    </div>
                </div>

                <div class="alert alert-info">
                    <i class="fas fa-info-circle"></i> <strong>Puntos clave en el flujo de cancelación de suscripción:</strong>
                    <ul>
                        <li>StripeLabApp soporta dos tipos de cancelación:</li>
                        <ul>
                            <li><strong>Cancelación al final del periodo</strong>: La suscripción permanece activa hasta el final del periodo pagado, y luego no se renueva.</li>
                            <li><strong>Cancelación inmediata</strong>: La suscripción se cancela inmediatamente, sin esperar al final del periodo actual (generalmente sin reembolso).</li>
                        </ul>
                        <li>La cancelación se inicia desde la interfaz de usuario (<code>view-subscriptions.php</code>) y se procesa a través del endpoint API <code>api-manage-subscription.php</code>.</li>
                        <li>La aplicación actualiza inmediatamente el registro local de la suscripción y luego recibe una confirmación asíncrona a través de webhooks.</li>
                        <li>Diferentes eventos llegan según el tipo de cancelación:</li>
                        <ul>
                            <li>Cancelación al final del periodo: Primero <code>customer.subscription.updated</code> con <code>cancel_at_period_end=true</code>, y luego <code>customer.subscription.deleted</code> cuando finaliza el periodo.</li>
                            <li>Cancelación inmediata: Solo <code>customer.subscription.deleted</code> inmediatamente.</li>
                        </ul>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Sección 9 -->
        <section id="visualizacion-datos" class="mb-4">
            <h3>9. Visualización de Datos en StripeLabApp</h3>
            <p>
                StripeLabApp proporciona varias páginas para visualizar y gestionar los datos de transacciones y suscripciones. Estas páginas consumen los endpoints API para mostrar información actualizada y permitir acciones como la cancelación de suscripciones.
            </p>

            <div id="pagina-facturas" class="subsection">
                <h4>9.1. Página de Facturas/Recibos (invoices.php)</h4>
                <p>
                    La página de facturas permite visualizar todas las transacciones procesadas por el sistema, incluyendo pagos únicos y pagos recurrentes de suscripciones.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Características principales</strong>
                    </div>
                    <div class="card-body">
                        <p><strong>Obtención de datos:</strong></p>
                        <ul>
                            <li>Realiza solicitudes AJAX al endpoint <code>api-invoices.php</code> con diferentes acciones:</li>
                            <ul>
                                <li><code>action=list_all</code>: Lista todas las transacciones en el sistema.</li>
                                <li><code>action=list_customer</code>: Lista las transacciones de un cliente específico.</li>
                            </ul>
                            <li>El parámetro <code>page</code> permite la paginación de resultados (por defecto, 10 transacciones por página).</li>
                            <li>Los resultados se reciben en formato JSON y se renderizan dinámicamente en la tabla.</li>
                        </ul>

                        <p><strong>Información mostrada:</strong></p>
                        <ul>
                            <li><strong>ID de Transacción:</strong> El identificador único de Stripe para la transacción.</li>
                            <li><strong>Cliente:</strong> El ID del cliente en Stripe y su email (si está disponible).</li>
                            <li><strong>Fecha:</strong> La fecha y hora en que se procesó la transacción.</li>
                            <li><strong>Importe:</strong> El monto de la transacción con su moneda correspondiente.</li>
                            <li><strong>Tipo:</strong> Si es un pago único (PAYMENT) o de suscripción (SUBSCRIPTION).</li>
                            <li><strong>Estado:</strong> El estado actual de la transacción (COMPLETED, FAILED, REFUNDED).</li>
                            <li><strong>Recibo:</strong> Un enlace al recibo en PDF generado por Stripe (cuando está disponible).</li>
                            <li><strong>Descripción:</strong> Información adicional sobre la transacción.</li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-code"></i> <strong>Implementación:</strong> La página utiliza JavaScript para cargar los datos de manera asíncrona y actualizar la tabla sin recargar la página. También implementa paginación del lado del cliente y filtrado básico por tipo de transacción.
                        </div>

                        <p><strong>Ejemplo de código para cargar facturas:</strong></p>
                        <div class="code-snippet">
                       <pre><code class="language-javascript">
function loadInvoices(page = 1) {
   // Mostrar indicador de carga
   $('#loading-indicator').show();

   // Determinar la acción basada en los filtros
   let action = 'list_all';
   let params = { action: action, page: page };

   if ($('#customer-filter').val()) {
       action = 'list_customer';
       params.customer_id = $('#customer-filter').val();
   }

   // Realizar solicitud AJAX
   $.ajax({
       url: 'v1/api/api-invoices.php',
       type: 'GET',
       data: params,
       dataType: 'json',
       success: function(response) {
           // Ocultar indicador de carga
           $('#loading-indicator').hide();

           if (response.error) {
               showError(response.error);
               return;
           }

           // Renderizar los resultados en la tabla
           renderInvoicesTable(response.invoices);

           // Actualizar paginación
           updatePagination(page, response.total_pages);
       },
       error: function(xhr, status, error) {
           $('#loading-indicator').hide();
           showError('Error al cargar los datos: ' + error);
       }
   });
}

function renderInvoicesTable(invoices) {
   const tableBody = $('#invoices-table tbody');
   tableBody.empty();

   if (invoices.length === 0) {
       tableBody.append('<tr><td colspan="8" class="text-center">No hay facturas disponibles</td></tr>');
       return;
   }

   invoices.forEach(function(invoice) {
       const row = $('<tr></tr>');

       // Formatear datos para la tabla
       const formattedDate = new Date(invoice.createdAt).toLocaleString();
       const formattedAmount = new Intl.NumberFormat('es-ES', {
           style: 'currency',
           currency: invoice.currency.toUpperCase()
       }).format(invoice.amount);

       // Crear celdas con la información
       row.append(`<td>${invoice.transactionId}</td>`);
       row.append(`<td>${invoice.customerId || 'N/A'}</td>`);
       row.append(`<td>${formattedDate}</td>`);
       row.append(`<td>${formattedAmount}</td>`);
       row.append(`<td><span class="badge bg-${invoice.type === 'SUBSCRIPTION' ? 'primary' : 'success'}">${invoice.type}</span></td>`);
       row.append(`<td><span class="badge bg-${invoice.status === 'COMPLETED' ? 'success' : 'danger'}">${invoice.status}</span></td>`);

       // Enlace al recibo si está disponible
       if (invoice.receiptUrl) {
           row.append(`<td><a href="${invoice.receiptUrl}" target="_blank" class="btn btn-sm btn-outline-primary">Ver Recibo</a></td>`);
       } else {
           row.append(`<td>No disponible</td>`);
       }

       row.append(`<td>${invoice.description || 'N/A'}</td>`);

       tableBody.append(row);
   });
}
                       </code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <div id="pagina-suscripciones" class="subsection">
                <h4>9.2. Página de Suscripciones (view-subscriptions.php)</h4>
                <p>
                    La página de suscripciones permite visualizar todas las suscripciones activas e inactivas en el sistema, así como realizar acciones de gestión como la cancelación.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Características principales</strong>
                    </div>
                    <div class="card-body">
                        <p><strong>Estructura de pestañas:</strong></p>
                        <ul>
                            <li><strong>Todas las Suscripciones:</strong> Muestra todas las suscripciones en el sistema.</li>
                            <li><strong>Suscripciones por Cliente:</strong> Permite filtrar suscripciones por ID de cliente.</li>
                        </ul>

                        <p><strong>Obtención de datos:</strong></p>
                        <ul>
                            <li>Realiza solicitudes AJAX al endpoint <code>api-subscriptions.php</code> con diferentes acciones:</li>
                            <ul>
                                <li><code>action=list_all_system</code>: Lista todas las suscripciones registradas.</li>
                                <li><code>action=list_customer</code>: Lista las suscripciones de un cliente específico.</li>
                            </ul>
                            <li>Los resultados se reciben en formato JSON y se renderizan dinámicamente en la tabla.</li>
                        </ul>

                        <p><strong>Información mostrada:</strong></p>
                        <ul>
                            <li><strong>ID de Suscripción:</strong> El identificador único de Stripe para la suscripción.</li>
                            <li><strong>Cliente:</strong> El ID del cliente en Stripe.</li>
                            <li><strong>Plan:</strong> El nombre del plan de suscripción.</li>
                            <li><strong>Importe:</strong> El monto periódico de la suscripción (mensual o anual).</li>
                            <li><strong>Estado:</strong> El estado actual de la suscripción (active, canceled, etc.).</li>
                            <li><strong>Periodo Actual:</strong> Fechas de inicio y fin del periodo actual.</li>
                            <li><strong>Cancelación Programada:</strong> Indica si la suscripción se cancelará al final del periodo actual.</li>
                            <li><strong>Acciones:</strong> Botones para gestionar la suscripción (cancelar ahora o al final del periodo).</li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-code"></i> <strong>Implementación:</strong> La página utiliza JavaScript para cargar los datos de manera asíncrona y actualizar la tabla sin recargar la página. Las acciones de cancelación también se procesan de forma asíncrona mediante solicitudes AJAX al endpoint <code>api-manage-subscription.php</code>.
                        </div>

                        <p><strong>Funcionalidad de cancelación:</strong></p>
                        <div class="code-snippet">
                       <pre><code class="language-javascript">
function cancelSubscription(subscriptionId, cancelAtPeriodEnd = true) {
   // Confirmar la acción
   const confirmMessage = cancelAtPeriodEnd
       ? '¿Estás seguro de que deseas cancelar esta suscripción al final del periodo actual?'
       : '¿Estás seguro de que deseas cancelar esta suscripción inmediatamente? No se realizará ningún reembolso por el periodo no utilizado.';

   if (!confirm(confirmMessage)) {
       return;
   }

   // Mostrar indicador de carga
   $('#loading-indicator').show();

   // Realizar solicitud AJAX
   $.ajax({
       url: 'v1/api/api-manage-subscription.php',
       type: 'POST',
       data: {
           action: 'cancel',
           subscription_id: subscriptionId,
           cancel_at_period_end: cancelAtPeriodEnd
       },
       dataType: 'json',
       success: function(response) {
           // Ocultar indicador de carga
           $('#loading-indicator').hide();

           if (response.error) {
               showError(response.error);
               return;
           }

           // Mostrar mensaje de éxito
           showSuccess(response.message);

           // Recargar los datos para actualizar la tabla
           loadSubscriptions();
       },
       error: function(xhr, status, error) {
           $('#loading-indicator').hide();
           showError('Error al cancelar la suscripción: ' + error);
       }
   });
}

function renderSubscriptionsTable(subscriptions) {
   const tableBody = $('#subscriptions-table tbody');
   tableBody.empty();

   if (subscriptions.length === 0) {
       tableBody.append('<tr><td colspan="8" class="text-center">No hay suscripciones disponibles</td></tr>');
       return;
   }

   subscriptions.forEach(function(subscription) {
       const row = $('<tr></tr>');

       // Formatear datos para la tabla
       const formattedAmount = new Intl.NumberFormat('es-ES', {
           style: 'currency',
           currency: subscription.currency.toUpperCase()
       }).format(subscription.amount);

       const periodStart = new Date(subscription.currentPeriodStart).toLocaleDateString();
       const periodEnd = new Date(subscription.currentPeriodEnd).toLocaleDateString();

       // Crear celdas con la información
       row.append(`<td>${subscription.subscriptionId}</td>`);
       row.append(`<td>${subscription.customerId}</td>`);
       row.append(`<td>${subscription.planName}</td>`);
       row.append(`<td>${formattedAmount} / ${subscription.interval}</td>`);

       // Estado con indicador visual
       const statusClass = subscription.status === 'active' ? 'success' :
                         (subscription.status === 'canceled' ? 'danger' : 'warning');
       row.append(`<td><span class="badge bg-${statusClass}">${subscription.status}</span></td>`);

       row.append(`<td>${periodStart} - ${periodEnd}</td>`);

       // Cancelación programada
       if (subscription.cancelAtPeriodEnd) {
           row.append(`<td><span class="badge bg-warning">Sí</span></td>`);
       } else {
           row.append(`<td>No</td>`);
       }

       // Acciones disponibles según el estado
       const actions = $('<td></td>');
       if (subscription.status === 'active') {
           if (!subscription.cancelAtPeriodEnd) {
               // Botón para cancelar al final del periodo
               const btnCancelEnd = $(`<button class="btn btn-sm btn-warning me-2">Cancelar al final del periodo</button>`);
               btnCancelEnd.on('click', function() {
                   cancelSubscription(subscription.subscriptionId, true);
               });
               actions.append(btnCancelEnd);

               // Botón para cancelar inmediatamente
               const btnCancelNow = $(`<button class="btn btn-sm btn-danger">Cancelar ahora</button>`);
               btnCancelNow.on('click', function() {
                   cancelSubscription(subscription.subscriptionId, false);
               });
               actions.append(btnCancelNow);
           } else {
               // Ya está programada para cancelarse, opción para revertir
               const btnRevert = $(`<button class="btn btn-sm btn-outline-success">Revertir cancelación</button>`);
               btnRevert.on('click', function() {
                   revertCancellation(subscription.subscriptionId);
               });
               actions.append(btnRevert);
           }
       } else {
           actions.append('No disponible');
       }

       row.append(actions);
       tableBody.append(row);
   });
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Integración completa:</strong> Esta página demuestra la integración completa entre la interfaz de usuario, la API de StripeLabApp y la API de Stripe. Permite a los usuarios ver y gestionar sus suscripciones de manera intuitiva, mientras que la aplicación mantiene sincronizada la información local con Stripe.
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </section>

    <!-- PARTE III -->
    <section id="parte3" class="mb-5">
        <h2>PARTE III: Propuesta para la integración con ILIAS</h2>
        <p class="lead">
            Esta sección presenta conceptos preliminares y propuestas para integrar StripeLabApp con ILIAS, permitiendo la implementación de pagos y suscripciones en la plataforma de aprendizaje.
        </p>

        <!-- Secciones placeholder para desarrollo futuro -->
        <section id="conceptos-integracion" class="mb-4">
            <h3>10. Conceptos de Integración: StripeLabApp e ILIAS</h3>
            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i> Contenido a desarrollar en el futuro.
            </div>
        </section>

        <section id="estrategias-integracion" class="mb-4">
            <h3>11. Estrategias de Integración (Propuestas)</h3>
            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i> Contenido a desarrollar en el futuro.
            </div>
        </section>

        <section id="modificaciones-stripelabapp" class="mb-4">
            <h3>12. Modificaciones Necesarias en StripeLabApp para la Integración con ILIAS (Ejemplos)</h3>
            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i> Contenido a desarrollar en el futuro.
            </div>
        </section>

        <section id="modificaciones-ilias" class="mb-4">
            <h3>13. Modificaciones Necesarias en ILIAS para la Integración</h3>
            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i> Contenido a desarrollar en el futuro.
            </div>
        </section>

        <section id="consideraciones-seguridad" class="mb-4">
            <h3>14. Consideraciones de Seguridad para la Integración</h3>
            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i> Contenido a desarrollar en el futuro.
            </div>
        </section>
    </section>

    <!-- Scripts de Bootstrap, jQuery, etc. -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.3.min.js"></script>
    <!-- Highlight.js para resaltado de código -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <!-- Mermaid para diagramas -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@9.3.0/dist/mermaid.min.js"></script>
    <script>
        // Inicializar highlight.js
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightBlock(block);
            });

            // Inicializar Mermaid
            mermaid.initialize({
                startOnLoad: true,
                theme: 'default',
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                }
            });
        });
    </script>
</div>
    </body>
</html>
