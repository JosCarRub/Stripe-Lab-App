¡Excelente! Estos logs son oro puro para entender el flujo completo y cómo tu aplicación está reaccionando.

Confirmación del Éxito y Análisis de los Logs:

Suscripción Anual Creada y Guardada (sub_1RO5QfP71JLI6sb9EKIosSQS):

StripeSubscriptions:

+------------------------------+--------------------+--------------------+--------+--------------------------------+----------+----------------------+---------------------+----------------------+-------------+----------+-----------------------+---------------------+---------------------+
| subscription_id              | stripe_customer_id | customer_email     | status | stripe_price_id                | interval | current_period_start | current_period_end  | cancel_at_period_end | canceled_at | ended_at | latest_transaction_id | created_at_stripe   | created_at_local    |
+------------------------------+--------------------+--------------------+--------+--------------------------------+----------+----------------------+---------------------+----------------------+-------------+----------+-----------------------+---------------------+---------------------+
| sub_1RO5QfP71JLI6sb9EKIosSQS | cus_SIgoJvUF0ooe7U | TESTanual@TEST.COM | active | price_1RLNsHP71JLI6sb9ez8HJsHt | year     | 2025-05-12 23:06:36  | 2026-05-12 23:06:36 |                    0 | NULL        | NULL     |                     2 | 2025-05-12 23:06:36 | 2025-05-12 23:06:39 |
+------------------------------+--------------------+--------------------+--------+--------------------------------+----------+----------------------+---------------------+----------------------+-------------+----------+-----------------------+---------------------+---------------------+


¡Perfecto! Se ha guardado la suscripción anual.

customer_email está poblado.

latest_transaction_id es 2, que corresponde a la factura de esta suscripción.

Transacciones Guardadas (StripeTransactions):

ID 1 (Pago Único Anterior): pi_3RO5KdP71JLI6sb91XFQkshR - one_time_receipt. Correcto.

ID 2 (Factura de la Suscripción Anual): in_1RO5QgP71JLI6sb9HSRdDSiW - subscription_invoice.

stripe_subscription_id: sub_1RO5QfP71JLI6sb9EKIosSQS - ¡Correcto!

stripe_payment_intent_id: pi_3RO5QeP71JLI6sb90iwvxrFW - Correcto, es el PI que pagó esta factura.

stripe_charge_id: ch_3RO5QeP71JLI6sb90RTFOULQ - Correcto, es el Charge asociado.

document_url y pdf_url están presentes.

Ausencia de Transacción Duplicada para el PI de la Suscripción:

¡MUY BIEN! No hay una entrada separada de tipo one_time_receipt para pi_3RO5QeP71JLI6sb90iwvxrFW. Esto significa que la lógica en PaymentIntentSucceededStrategyImpl (la que verifica la descripción "Subscription creation") está funcionando y evitando la creación de la transacción redundante.

Flujo de Eventos (Resumido de events.log y stripe_payloads.log):

Checkout (checkout.session.completed para cs_test_a1pbv8QoyAgXUfa043e3KZqh...):

Se procesa por CheckoutSessionCompletedStrategyImpl.

Como mode: "subscription", intenta actualizar el email en la suscripción (que aún no existe en BD, por lo que loguea "Suscripción de Checkout aún no en BD").

Creación de Entidades de Stripe:

payment_method.attached (Unhandled)

customer.created (cus_SIgoJvUF0ooe7U) - Procesado por CustomerCreatedOrUpdatedStrategyImpl.

customer.updated - Procesado.

Creación de la Suscripción (customer.subscription.created para sub_1RO5QfP71JLI6sb9EKIosSQS):

SubscriptionMapper DEBUG log muestra el payload.

Los fallbacks para current_period_start (usando start_date) y current_period_end (usando items.data[0].current_period_end) funcionan.

SubscriptionCreatedStrategyImpl intenta obtener el email del cliente (y lo consigue, como vemos en la BD).

Se crea y guarda el SubscriptionsModel.

Pago de la Primera Factura:

payment_intent.created (pi_3RO5QeP71JLI6sb90iwvxrFW) (Unhandled)

invoice.created (in_1RO5QgP71JLI6sb9HSRdDSiW) (Unhandled)

payment_intent.succeeded (pi_3RO5QeP71JLI6sb90iwvxrFW):

PaymentIntentSucceededStrategyImpl lo procesa.

Loguea: PaymentIntent DTO mapeado. - Context: {"pi_id":"pi_3RO5QeP71JLI6sb90iwvxrFW","description":"Subscription creation","invoice_id_in_pi_dto":null}

Loguea: Descripción del PI sugiere pago de suscripción/factura.

Loguea: PaymentIntent parece ser para una factura/suscripción (ID: N/A). No se creará una transacción 'one_time_receipt' separada...

¡Esto es exactamente lo que queríamos! No crea la transacción duplicada.

charge.succeeded (ch_3RO5QeP71JLI6sb90RTFOULQ) - Procesado por ChargeSucceededStrategyImpl. Intenta encontrar una transacción por el PI pi_3RO5QeP71JLI6sb90iwvxrFW. En este punto, la transacción de la factura (ID 2) aún no se ha creado, por lo que loguea "No se encontró transacción asociada...". Esto está bien, porque InvoicePaidStrategyImpl creará la transacción y ya tendrá el charge_id del payload de la factura.

invoice.finalized (Unhandled)

invoice.paid (in_1RO5QgP71JLI6sb9HSRdDSiW):

InvoicePaidStrategyImpl lo procesa.

InvoiceMapper mapea el DTO, incluyendo el subscription_id y el payment_intent_id.

Se crea la TransactionsModel (será la ID 2 en tu BD).

Se actualiza latest_transaction_id en StripeSubscriptions con el ID 2.

invoice.payment_succeeded (Unhandled) - Este es un evento más antiguo, invoice.paid es el preferido.

Conclusión del Flujo de Suscripción Anual:
¡El flujo se ve muy bien! La suscripción se crea, la factura se registra como una única transacción, y la suscripción se enlaza a esa transacción. La heurística en PaymentIntentSucceededStrategyImpl está funcionando para evitar la transacción redundante.

Flujo de Pago Único (Basado en tus logs de evt_3RO5KdP71JLI6sb91yQofxm9 para pi_3RO5KdP71JLI6sb91XFQkshR):

checkout.session.completed (cs_test_a1QTFJUpCnFuxSFS...):

mode: "payment", payment_status: "paid".

CheckoutSessionCompletedStrategyImpl lo procesa.

Como es payment y paid, y el paymentIntentId (pi_3RO5KdP71JLI6sb91XFQkshR) está presente, intenta crear una transacción preliminar. Si no existe una para ese PI, la crea. (Esta sería la transacción ID 1 en tu BD).

payment_intent.created (pi_3RO5KdP71JLI6sb91XFQkshR) (Unhandled).

payment_intent.succeeded (pi_3RO5KdP71JLI6sb91XFQkshR):

PaymentIntentSucceededStrategyImpl lo procesa.

Encuentra la transacción existente (ID 1) creada por CheckoutSessionCompletedStrategyImpl.

Loguea: Transacción ya existe para este PaymentIntent.

Intenta enriquecerla con receipt_url del Charge (si tryEnrichTransactionWithChargeDetails tiene éxito).

charge.succeeded (ch_3RO5KdP71JLI6sb91oRRGx4P):

ChargeSucceededStrategyImpl lo procesa.

Busca una transacción por el payment_intent_id (pi_3RO5KdP71JLI6sb91XFQkshR). Encuentra la transacción ID 1.

Actualiza la transacción ID 1 con el receipt_url del Charge.

Conclusión del Flujo de Pago Único:
También se ve bien. Se crea una transacción a partir de checkout.session.completed (o podría ser directamente desde payment_intent.succeeded si ese evento llegara primero y la estrategia no encontrara una existente). Luego, los eventos payment_intent.succeeded y charge.succeeded pueden enriquecer esa transacción.

Documentación de Payloads y Base de Datos (Borrador):

Ahora, basándonos en estos flujos y los payloads que has proporcionado, podemos empezar a documentar.

Sección Propuesta para la Documentación Web: "Flujos de Eventos y Mapeo de Datos"

Introducción:
StripeLabApp procesa varios webhooks de Stripe para mantener su base de datos local sincronizada con los eventos que ocurren en Stripe. Esta sección detalla los flujos de eventos clave para pagos únicos y suscripciones, y cómo los datos de los payloads de Stripe se mapean a las tablas StripeTransactions y StripeSubscriptions.

Tablas de Base de Datos Relevantes:

StripeTransactions: Almacena todos los eventos financieros significativos, ya sean pagos únicos (recibos) o facturas pagadas de suscripciones.

transaction_id (PK, BIGINT UNSIGNED AUTO_INCREMENT): ID interno de la transacción.

stripe_customer_id (VARCHAR): ID del cliente de Stripe (cus_...).

customer_email, customer_name (VARCHAR): Información denormalizada del cliente.

transaction_type (ENUM): 'one_time_receipt' o 'subscription_invoice'.

stripe_payment_intent_id (VARCHAR, UNIQUE): ID del PaymentIntent (pi_...).

stripe_invoice_id (VARCHAR, UNIQUE): ID de la Invoice (in_...).

stripe_subscription_id (VARCHAR): ID de la Suscripción (sub_...) si la transacción está relacionada con una.

stripe_charge_id (VARCHAR, UNIQUE): ID del Charge (ch_...).

amount (INT): Monto en la unidad mínima de la moneda (ej. céntimos).

currency (VARCHAR): Código de moneda (ej. eur, usd).

status (VARCHAR): Estado del objeto de Stripe (ej. succeeded para PI/Charge, paid para Invoice).

description (VARCHAR): Descripción de la transacción.

document_url (VARCHAR): URL del recibo (para pagos únicos) o de la factura alojada (para facturas).

pdf_url (VARCHAR): URL del PDF de la factura (solo para Invoices).

period_start, period_end (TIMESTAMP): Periodo cubierto por la factura (para suscripciones).

transaction_date_stripe (TIMESTAMP): Fecha de creación del objeto principal de Stripe.

created_at_local (TIMESTAMP): Fecha de creación del registro local.

StripeSubscriptions: Almacena información sobre las suscripciones de los clientes.

subscription_id (PK, VARCHAR): ID de la suscripción de Stripe (sub_...).

stripe_customer_id (VARCHAR): ID del cliente de Stripe.

customer_email (VARCHAR): Email del cliente (denormalizado).

status (VARCHAR): Estado de la suscripción (active, trialing, canceled, past_due, etc.).

stripe_price_id (VARCHAR): ID del Precio de Stripe (price_...).

interval (VARCHAR): Intervalo de facturación (month, year).

current_period_start, current_period_end (TIMESTAMP): Periodo de facturación actual.

cancel_at_period_end (BOOLEAN): Si la suscripción se cancelará al final del periodo.

canceled_at (TIMESTAMP): Fecha de cancelación.

ended_at (TIMESTAMP): Fecha de finalización definitiva.

latest_transaction_id (FK, BIGINT UNSIGNED): Enlace al transaction_id de la última factura pagada en StripeTransactions.

created_at_stripe (TIMESTAMP): Fecha de creación de la suscripción en Stripe.

created_at_local (TIMESTAMP): Fecha de creación del registro local.

Flujo 1: Pago Único a través de Stripe Checkout

Eventos de Stripe Involucrados (en orden aproximado):

checkout.session.completed

payment_intent.created (Generalmente no manejado por una estrategia específica en esta app)

payment_intent.succeeded

charge.succeeded

charge.updated (Generalmente no manejado)

Procesamiento y Mapeo de Datos:

checkout.session.completed (Payload Ejemplo: evt_1RO5KeP71JLI6sb9FJJodAWj)

Estrategia: CheckoutSessionCompletedStrategyImpl

Datos Clave del Payload:

id (cs_...): ID de la sesión de Checkout.

mode: "payment"

payment_status: "paid"

customer_details: Contiene email y name proporcionados por el usuario.

payment_intent (pi_...): ID del PaymentIntent asociado.

Acciones en la App:

Se mapea a CheckoutSessionCompletedDTO.

Si mode es "payment" y payment_status es "paid", y no existe una transacción para el payment_intent_id, la TransactionModelFactory crea una TransactionsModel preliminar:

transaction_type: one_time_receipt

stripe_payment_intent_id: Del DTO.

customer_email, customer_name: Del customer_details del DTO.

amount, currency: Del DTO.

status: "paid" (del payment_status del DTO).

transaction_date_stripe: created del DTO.

description: Algo como "Pago vía Checkout Session [cs_id]".

document_url, pdf_url, stripe_charge_id: Probablemente null en este punto, se esperan de eventos posteriores.

Se guarda en StripeTransactions.

payment_intent.succeeded (Payload Ejemplo: evt_3RO5KdP71JLI6sb91yQofxm9 para pi_3RO5KdP71JLI6sb91XFQkshR)

Estrategia: PaymentIntentSucceededStrategyImpl

Datos Clave del Payload:

id (pi_...): ID del PaymentIntent.

amount_received, currency.

status: "succeeded".

created: Timestamp.

latest_charge (ch_...): ID del Charge asociado.

description: Puede ser null o una descripción del pago.

invoice: Importante: Este campo es null en el payload de este evento para un pago único directo.

Acciones en la App:

Se mapea a PaymentIntentDTO.

La estrategia verifica si ya existe una transacción para este pi_id.

Si fue creada por checkout.session.completed, la encuentra.

Como $piDTO->invoiceId es null (porque no es un pago de factura de Stripe), la estrategia lo considera un pago único directo.

Si no existe una transacción previa, la TransactionModelFactory crea una TransactionsModel:

transaction_type: one_time_receipt.

stripe_payment_intent_id: Del DTO.

amount, currency, status, transaction_date_stripe, description: Del DTO.

La estrategia intenta obtener el objeto Charge usando $piDTO->latestChargeId y el StripeClient para obtener el receipt_url.

Si se obtiene el ChargeDTO, el document_url (receipt_url) y stripe_charge_id se actualizan en el TransactionsModel (o se establecen si es una nueva creación).

Se guarda/actualiza en StripeTransactions.

charge.succeeded (Payload Ejemplo: evt_3RO5KdP71JLI6sb9133PVEJF para ch_3RO5KdP71JLI6sb91oRRGx4P)

Estrategia: ChargeSucceededStrategyImpl

Datos Clave del Payload:

id (ch_...): ID del Charge.

payment_intent (pi_...): ID del PaymentIntent.

receipt_url: URL del recibo.

billing_details: Contiene name y email.

status: "succeeded".

Acciones en la App:

Se mapea a ChargeDTO.

Busca una TransactionsModel existente usando el payment_intent_id del ChargeDTO.

Si la encuentra, actualiza:

document_url con chargeDTO->receiptUrl.

stripe_charge_id con chargeDTO->id.

customer_name y customer_email si son diferentes o no estaban.

Se guarda la TransactionsModel actualizada.

Resultado en BD para Pago Único: Una única entrada en StripeTransactions de tipo one_time_receipt, con stripe_payment_intent_id, stripe_charge_id, document_url (el recibo), y datos del cliente.

Flujo 2: Nueva Suscripción (Mensual/Anual) vía Stripe Checkout

Eventos de Stripe Involucrados (en orden aproximado):

checkout.session.completed

payment_method.attached (No manejado)

customer.created

customer.updated

payment_intent.created (No manejado)

invoice.created (No manejado)

customer.subscription.created

payment_intent.succeeded

charge.succeeded

invoice.finalized (No manejado)

invoice.paid

invoice.payment_succeeded (No manejado)

Procesamiento y Mapeo de Datos:

checkout.session.completed (Payload Ejemplo: evt_1RO5QhP71JLI6sb9P1YkiSWK)

Estrategia: CheckoutSessionCompletedStrategyImpl

Datos Clave del Payload:

mode: "subscription"

payment_status: "paid" (si hay pago inicial)

customer (cus_...): ID del cliente.

customer_details: email, name.

subscription (sub_...): ID de la suscripción creada.

invoice (in_...): ID de la primera factura.

Acciones en la App:

Mapea a CheckoutSessionCompletedDTO.

Como mode es "subscription", la lógica principal es intentar actualizar el customer_email en el SubscriptionsModel si ya existe (lo cual es improbable en este punto del flujo, pero es una salvaguarda). Loguea "Suscripción de Checkout aún no en BD...".

customer.created / customer.updated (Payloads Ejemplo: evt_1RO5QgP71JLI6sb9Fu0J83H9, evt_1RO5QhP71JLI6sb9opYb4rJ9)

Estrategia: CustomerCreatedOrUpdatedStrategyImpl

Datos Clave del Payload: id (cus_...), email, name.

Acciones en la App:

Mapea a CustomerDTO.

Intenta encontrar suscripciones existentes para este customer_id y actualiza su customer_email si es diferente. (En una creación nueva, no habrá suscripciones aún).

customer.subscription.created (Payload Ejemplo: evt_1RO5QhP71JLI6sb98NwCeJDG para sub_1RO5QfP71JLI6sb9EKIosSQS)

Estrategia: SubscriptionCreatedStrategyImpl

Datos Clave del Payload:

id (sub_...): ID de la suscripción.

customer (cus_...): ID del cliente.

status: "active" (o "trialing", etc.).

created: Timestamp.

current_period_start, current_period_end: Timestamps del periodo actual (pueden ser null en el nivel raíz, pero el mapper los busca en items o usa start_date).

items.data[0].price.id: El stripe_price_id.

items.data[0].price.recurring.interval: El interval.

latest_invoice (in_...): ID de la factura más reciente (la primera en este caso).

Acciones en la App:

Mapea a SubscriptionDTO.

(Opcional) Intenta obtener el customer_email haciendo una llamada a la API de Stripe para el objeto Customer (tus logs muestran que esto sucede y obtiene el email).

SubscriptionModelFactory crea un SubscriptionsModel.

SubscriptionRepository guarda el nuevo registro en StripeSubscriptions. latest_transaction_id es null inicialmente.

payment_intent.succeeded (Payload Ejemplo: evt_3RO5QeP71JLI6sb901YvX6mc para pi_3RO5QeP71JLI6sb90iwvxrFW)

Estrategia: PaymentIntentSucceededStrategyImpl

Datos Clave del Payload: id (pi_...), description ("Subscription creation"), latest_charge. Importante: invoice es null en este payload.

Acciones en la App:

Mapea a PaymentIntentDTO. $piDTO->invoiceId será null.

La estrategia verifica si ya existe una transacción para este PI (no debería).

Heurística: Como $piDTO->description contiene "Subscription creation", la variable $isLikelySubscriptionPayment se vuelve true.

La estrategia loguea que delega en InvoicePaidStrategy y hace return, NO creando una transacción one_time_receipt. ¡Esto es lo que corrige la duplicación!

charge.succeeded (Payload Ejemplo: evt_3RO5QeP71JLI6sb90WyVApBR para ch_3RO5QeP71JLI6sb90RTFOULQ)

Estrategia: ChargeSucceededStrategyImpl

Datos Clave: id (ch_...), payment_intent (pi_...), receipt_url.

Acciones:

Mapea a ChargeDTO.

Intenta encontrar una transacción por payment_intent_id. En este punto del flujo, la transacción de la factura (que tendrá el payment_intent_id) aún no ha sido creada por InvoicePaidStrategyImpl. Por lo tanto, loguea "No se encontró transacción asociada...". Esto está bien.

invoice.paid (Payload Ejemplo: evt_1RO5QhP71JLI6sb9SWgjHtQL para in_1RO5QgP71JLI6sb9HSRdDSiW)

Estrategia: InvoicePaidStrategyImpl

Datos Clave del Payload:

id (in_...): ID de la factura.

customer (cus_...).

subscription (sub_...): ID de la suscripción (tu mapper mejorado lo extrae de parent.subscription_details.subscription o lines).

payment_intent (pi_...): ID del PaymentIntent que pagó esta factura.

charge (ch_...): ID del Charge.

amount_paid, currency, status ("paid").

hosted_invoice_url, invoice_pdf.

period_start, period_end.

Acciones en la App:

Mapea a InvoiceDTO.

Verifica idempotencia (no debería existir una transacción para este invoice_id).

TransactionModelFactory crea un TransactionsModel:

transaction_type: subscription_invoice.

Todos los IDs de Stripe (invoice_id, payment_intent_id, subscription_id, charge_id) se populan.

document_url y pdf_url se establecen.

TransactionRepository guarda esta transacción (ej. con transaction_id = 2 en tus datos de BD).

Actualiza StripeSubscriptions: Busca la suscripción por invoiceDTO->subscriptionId y establece latest_transaction_id al transaction_id recién creado (ej. 2).

Resultado en BD para Nueva Suscripción:

StripeSubscriptions: 1 fila para la nueva suscripción, con status: active, customer_email, y latest_transaction_id apuntando a la transacción de la factura.

StripeTransactions: 1 fila para la factura pagada, de tipo subscription_invoice, con todos los IDs de Stripe relevantes y los enlaces a los documentos.

Flujo 3: Cancelación de Suscripción (Ej. stripe trigger customer.subscription.deleted)

Eventos de Stripe Involucrados:

customer.subscription.deleted (o customer.subscription.updated si se cancela al final del periodo)

Procesamiento y Mapeo de Datos:

customer.subscription.deleted (o .updated con cancel_at_period_end: true o status: 'canceled')

Estrategia: SubscriptionDeletedStrategyImpl o SubscriptionUpdatedStrategyImpl.

Datos Clave del Payload (para .deleted o un .updated que la cancela):

id (sub_...): ID de la suscripción.

status: "canceled" (para cancelación inmediata) o podría ser "active" pero con cancel_at_period_end: true y canceled_at poblado si es una cancelación programada que ahora se efectúa. Si el evento es customer.subscription.deleted, el status en el payload ya es el final.

canceled_at: Timestamp de cuándo se solicitó/efectuó la cancelación.

ended_at: Timestamp de cuándo la suscripción realmente terminó (puede ser igual a canceled_at o al final del periodo).

Acciones en la App:

SubscriptionMapper mapea a SubscriptionDTO.

La estrategia (SubscriptionDeletedStrategyImpl o SubscriptionUpdatedStrategyImpl) busca la SubscriptionsModel existente.

Actualiza el status a SubscriptionStatusEnum::CANCELED (o el estado final que venga).

Establece canceled_at y/o ended_at en el modelo.

Si es SubscriptionUpdatedStrategyImpl y cancel_at_period_end es true, actualiza ese booleano.

SubscriptionRepository guarda los cambios en StripeSubscriptions.

Resultado en BD para Suscripción Cancelada:

El registro existente en StripeSubscriptions se actualiza:

status cambia a "canceled" (o el estado final).

canceled_at y/o ended_at se rellenan.

cancel_at_period_end puede cambiar.

Eventos No Manejados (Ejemplos de tu unhandled_stripe_events.log):

payment_method.attached:

Payload: Contiene detalles del PaymentMethod (pm_...) y el Customer (cus_...) al que se adjuntó.

Por qué no lo manejamos (por ahora): No tenemos una tabla local de PaymentMethods. Si la tuviéramos, o si quisiéramos actualizar el default_payment_method en nuestro CustomerModel local, crearíamos una estrategia. Para esta app de prueba, no es esencial.

product.created, plan.created, price.created:

Payloads: Contienen detalles de los productos, planes (obsoleto) y precios creados en Stripe.

Por qué no los manejamos: Esta aplicación no sincroniza el catálogo de productos/precios de Stripe a una BD local. Los precios se obtienen vía lookup_key cuando se necesitan para crear sesiones de Checkout. Si quisieras un catálogo local, necesitarías estrategias para estos.

payment_intent.created, invoice.created, invoice.finalized:

Payloads: Indican la creación o finalización de estos objetos antes de su estado "exitoso" o "pagado".

Por qué no los manejamos: Generalmente, nos interesan los eventos de "éxito" para tomar acciones de persistencia. Registrar estos eventos intermedios añadiría muchas entradas a StripeTransactions que podrían no ser directamente útiles para el usuario final, aunque sí para auditoría detallada.

invoice.payment_succeeded:

Este es un evento más antiguo. invoice.paid es el evento preferido y más completo para facturas pagadas. Como ya manejamos invoice.paid, no necesitamos una estrategia separada para invoice.payment_succeeded.

charge.updated:

Indica una actualización en un objeto Charge. A menos que necesites rastrear cambios específicos en los cargos después de su creación/éxito, no es esencial.

Conclusión de esta Documentación de Flujo:

Este análisis detallado de los eventos, los payloads y cómo interactúan con tu base de datos a través de las diferentes capas de la aplicación (Mappers, Factories, Repositories, Strategies) es fundamental.

Datos Clave Recogidos:

Para Transacciones: IDs de Stripe (PI, Invoice, Charge, Subscription), datos del cliente (denormalizados), monto, moneda, estado, descripción, URLs de documentos, fechas y periodos. Esto permite mostrar una lista de "facturas/recibos" con enlaces a los documentos oficiales y detalles del pago.

Para Suscripciones: IDs de Stripe (Subscription, Customer, Price), estado, intervalo, periodos actuales, fechas de cancelación/finalización, email del cliente y un enlace a la última transacción pagada. Esto permite mostrar el estado actual de las suscripciones, su historial básico y gestionarlas.

Importancia para la Funcionalidad:

Guardar Pagos: payment_intent.succeeded (para pagos únicos directos) e invoice.paid (para facturas) son clave.

Guardar Suscripciones: customer.subscription.created es el evento principal.

Gestionar Estado de Suscripciones: customer.subscription.updated y customer.subscription.deleted actualizan el estado.

Mostrar Facturas/Recibos: Los datos en StripeTransactions permiten esto. El document_url (para recibos de PI/Charge) y pdf_url/hosted_invoice_url (para Invoices) son cruciales.

Este nivel de detalle te da una base sólida para la documentación y para entender profundamente cómo funciona tu integración. ¡Excelente trabajo al llegar hasta aquí y analizar los logs con tanto detalle!