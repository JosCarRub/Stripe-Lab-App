<!-- Sección 7 -->
        <section id="arquitectura-detallada" class="mb-4">
            <h3>7. Arquitectura Detallada de StripeLabApp</h3>

            <div id="diagrama-componentes" class="subsection">
                <h4>7.1. Diagrama de Componentes de StripeLabApp</h4>
                <p>
                    El siguiente diagrama muestra la estructura de componentes de StripeLabApp y cómo interactúan entre sí. Esto proporciona una visión general de la arquitectura de la aplicación antes de profundizar en cada capa.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Diagrama de componentes y sus interacciones</strong>
                    </div>
                    <div class="card-body">
                        <div class="mermaid-diagram">
                        <pre class="mermaid">
graph LR
    subgraph "User Interaction"
        direction LR
        UserInterface["Frontend (public/)"]
    end

    subgraph "Application Core (src/)"
        direction TB
        Controllers["Controllers (src/Controller)"]
        Services["Services (src/Service)"]
        Strategies["Strategies (src/Strategy)"]
        MappersFactories["Mappers & Factories (src/Mappers, src/Factories)"]
        Repositories["Repositories (src/Repository)"]
        Commons["Commons (DTOs, Entities, Enums, Exceptions, Loggers)"]
    end

    subgraph "Configuration"
        direction LR
        Bootstrap["config/Bootstrap.php"]
        EnvFile[".env File"]
    end

    subgraph "External Services"
        direction LR
        StripeAPI[("Stripe API")]
        Database[("MySQL DB")]
    end

    UserInterface --> EndpointsApi["Endpoints API (public/v1/api)"]
    UserInterface --> EndpointsCheckout["Endpoints Checkout (public/v1/)"]
    EndpointsApi --> Controllers
    EndpointsCheckout --> Services

    StripeAPI -- Webhooks --> WebhookEndpoint["Webhook Endpoint (public/v1/webhook.php)"]
    WebhookEndpoint --> Controllers

    Controllers --> Services
    Services --> Strategies
    Services --> Repositories  // Directamente para servicios de display/gestión
    Services --> StripeAPI     // Para StripeCheckoutSessionService, StripeSubscriptionManagementService

    Strategies --> MappersFactories
    MappersFactories --> CommonsDtoEntity["DTOs / Entities"]
    Strategies --> Repositories

    Repositories --> Database
    Repositories --> CommonsEntities["Entities"]

    Bootstrap -- Manages/Provides --> Controllers
    Bootstrap -- Manages/Provides --> Services
    Bootstrap -- Manages/Provides --> Strategies
    Bootstrap -- Manages/Provides --> MappersFactories
    Bootstrap -- Manages/Provides --> Repositories
    Bootstrap -- Uses --> EnvFile
    Bootstrap -- Uses --> CommonsLoggers["Loggers"]

    Commons --> Controllers
    Commons --> Services
    Commons --> Strategies
    Commons --> MappersFactories
    Commons --> Repositories

    classDef default fill:#fff,stroke:#333,stroke-width:2px;
                        </pre>
                        </div>
                    </div>
                </div>

                <p>
                    Como se muestra en el diagrama, StripeLabApp sigue una arquitectura en capas con una clara separación de responsabilidades:
                </p>
                <ul>
                    <li><strong>Capa de Presentación:</strong> Interfaz de usuario y puntos de entrada API.</li>
                    <li><strong>Capa de Controladores:</strong> Manejan las solicitudes HTTP y coordinan las operaciones.</li>
                    <li><strong>Capa de Servicios:</strong> Implementan la lógica de negocio y orquestan las operaciones complejas.</li>
                    <li><strong>Capa de Estrategias:</strong> Encapsulan la lógica específica para cada tipo de evento de Stripe.</li>
                    <li><strong>Capa de Mappers y Factories:</strong> Facilitan la conversión entre formatos de datos y la creación de objetos.</li>
                    <li><strong>Capa de Repositorios:</strong> Proporcionan acceso a datos y abstraen la capa de persistencia.</li>
                    <li><strong>Capa de Commons:</strong> Contiene componentes transversales utilizados por toda la aplicación.</li>
                </ul>

                <div class="alert alert-info">
                    <i class="fas fa-info-circle"></i> <strong>Patrón de diseño:</strong> La arquitectura combina varios patrones, incluyendo MVC (Modelo-Vista-Controlador), Repository, Strategy y Factory. Esta combinación proporciona flexibilidad y facilita la extensión del sistema para manejar nuevos tipos de eventos o funcionalidades.
                </div>
            </div>

            <div id="capa-commons" class="subsection">
                <h4>7.2. Capa Commons</h4>
                <p>
                    La capa Commons contiene componentes fundamentales utilizados en toda la aplicación, proporcionando estructura, tipado y funcionalidades comunes. Estos componentes son la base sobre la que se construyen las demás capas.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>DTOs (Data Transfer Objects)</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Los DTOs en StripeLabApp facilitan la transferencia de datos entre las diferentes capas de la aplicación sin exponer los detalles de implementación de las entidades de dominio. También proporcionan una estructura clara para los datos que se envían al frontend.
                        </p>

                        <p><strong>Ejemplos de DTOs:</strong></p>
                        <ul>
                            <li>
                                <strong>SubscriptionDTO:</strong> Representa una suscripción con todos los datos necesarios para la visualización y gestión:
                                <div class="code-snippet">
                                <pre><code class="language-php">
class SubscriptionDTO
{
    public int $id;
    public string $subscriptionId;
    public string $customerId;
    public string $status;
    public string $planId;
    public string $planName;
    public float $amount;
    public string $currency;
    public string $interval;
    public DateTime $currentPeriodStart;
    public DateTime $currentPeriodEnd;
    public ?DateTime $canceledAt;
    public bool $cancelAtPeriodEnd;
    public DateTime $createdAt;
    public ?DateTime $endedAt;
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>InvoiceDTO:</strong> Contiene la información de una factura para mostrar en la interfaz:
                                <div class="code-snippet">
                                <pre><code class="language-php">
class InvoiceDTO
{
    public string $invoiceId;
    public string $customerId;
    public ?string $subscriptionId;
    public float $amount;
    public string $currency;
    public string $status;
    public DateTime $createdAt;
    public ?string $invoiceUrl;
    public ?string $receiptUrl;
    public ?string $description;
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>TransactionDTO:</strong> Representa una transacción de pago, ya sea única o parte de una suscripción:
                                <div class="code-snippet">
                                <pre><code class="language-php">
                                class TransactionDTO
                                {
                                    public int $id;
                                    public string $transactionId;
                                    public ?string $customerId;
                                    public string $type;
                                    public float $amount;
                                    public string $currency;
                                    public string $status;
                                    public ?string $paymentMethodDetails;
                                    public ?string $receiptUrl;
                                    public DateTime $createdAt;
                                    public ?string $description;
                                }

                                 </code></pre>
                                </div>
                            </li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-lightbulb"></i> <strong>Beneficio:</strong> Los DTOs proporcionan una capa de abstracción que facilita la evolución de las entidades internas sin afectar a las interfaces externas. También simplifican la serialización a JSON para las respuestas API.
                        </div>
                    </div>
                </div>
                <!-- Aquí termina la sección 7.2 parcial - continúa con el resto de la sección 7.2 y las siguientes secciones -->

                <!-- Continuación de la sección 7.2 Capa Commons -->
                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Entidades (Models)</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Las entidades o modelos representan los objetos de dominio principales de la aplicación y corresponden directamente a las tablas de la base de datos. Contienen la lógica específica del dominio y las reglas de negocio.
                        </p>

                        <p><strong>Principales modelos:</strong></p>
                        <ul>
                            <li>
                                <strong>TransactionsModel:</strong> Representa una transacción financiera en el sistema:
                                <div class="code-snippet">
                                <pre><code class="language-php">
class TransactionsModel
{
    public int $transaction_id; // ID autoincremental en la BD
    public string $stripe_transaction_id; // ID de Stripe (payment_intent o charge)
    public ?string $stripe_customer_id; // ID del cliente en Stripe
    public string $transaction_type; // Tipo (PAYMENT, SUBSCRIPTION, REFUND)
    public float $amount; // Importe
    public string $currency; // Moneda (EUR, USD, etc.)
    public string $status; // Estado (COMPLETED, FAILED, REFUNDED)
    public ?string $payment_method_details; // Detalles del método de pago en JSON
    public ?string $receipt_url; // URL al recibo en Stripe
    public DateTimeImmutable $created_at; // Fecha de creación
    public ?string $description; // Descripción opcional
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>SubscriptionsModel:</strong> Representa una suscripción de un cliente:
                                <div class="code-snippet">
                                <pre><code class="language-php">
class SubscriptionsModel
{
    public string $subscription_id; // ID de Stripe (sub_...)
    public string $customer_id; // ID del cliente en Stripe
    public string $status; // Estado (active, canceled, etc.)
    public string $plan_id; // ID del plan en Stripe
    public string $plan_name; // Nombre descriptivo del plan
    public float $amount; // Importe por periodo
    public string $currency; // Moneda
    public string $interval; // Intervalo (month, year)
    public DateTimeImmutable $current_period_start; // Inicio del periodo actual
    public DateTimeImmutable $current_period_end; // Fin del periodo actual
    public ?DateTimeImmutable $canceled_at; // Fecha de cancelación (si aplica)
    public bool $cancel_at_period_end; // Si se cancelará al final del periodo
    public DateTimeImmutable $created_at; // Fecha de creación
    public ?DateTimeImmutable $ended_at; // Fecha de finalización (si terminó)
}
                                </code></pre>
                                </div>
                            </li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-database"></i> <strong>Relación con la base de datos:</strong>
                            <p>Cada campo de estos modelos corresponde directamente a una columna en las tablas <code>transactions</code> y <code>subscriptions</code> respectivamente. La tabla <code>transactions</code> utiliza un <code>transaction_id</code> autoincremental como clave primaria, mientras que <code>subscriptions</code> utiliza el <code>subscription_id</code> de Stripe como clave primaria natural.</p>
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Enums</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Las enumeraciones proporcionan un tipado fuerte para valores constantes en la aplicación, mejorando la legibilidad del código y reduciendo errores por el uso de strings literales.
                        </p>

                        <p><strong>Principales enumeraciones:</strong></p>
                        <ul>
                            <li>
                                <strong>StripeEventTypeEnum:</strong> Define los tipos de eventos de Stripe que la aplicación maneja:
                                <div class="code-snippet">
                                <pre><code class="language-php">
enum StripeEventTypeEnum: string
{
    case CHECKOUT_SESSION_COMPLETED = 'checkout.session.completed';
    case PAYMENT_INTENT_SUCCEEDED = 'payment_intent.succeeded';
    case CHARGE_SUCCEEDED = 'charge.succeeded';
    case CUSTOMER_CREATED = 'customer.created';
    case CUSTOMER_UPDATED = 'customer.updated';
    case CUSTOMER_SUBSCRIPTION_CREATED = 'customer.subscription.created';
    case CUSTOMER_SUBSCRIPTION_UPDATED = 'customer.subscription.updated';
    case CUSTOMER_SUBSCRIPTION_DELETED = 'customer.subscription.deleted';
    case INVOICE_PAID = 'invoice.paid';
    // ... otros eventos soportados
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>TransactionTypeEnum:</strong> Define los tipos de transacciones financieras:
                                <div class="code-snippet">
                                <pre><code class="language-php">
enum TransactionTypeEnum: string
{
    case PAYMENT = 'PAYMENT';           // Pago único
    case SUBSCRIPTION = 'SUBSCRIPTION';  // Pago de suscripción
    case REFUND = 'REFUND';              // Reembolso
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>TransactionStatusEnum:</strong> Define los posibles estados de una transacción:
                                <div class="code-snippet">
                                <pre><code class="language-php">
enum TransactionStatusEnum: string
{
    case COMPLETED = 'COMPLETED';  // Transacción completada
    case FAILED = 'FAILED';        // Transacción fallida
    case REFUNDED = 'REFUNDED';    // Transacción reembolsada
    case PENDING = 'PENDING';      // Transacción pendiente
}
                                </code></pre>
                                </div>
                            </li>
                        </ul>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Beneficio:</strong> El uso de enums mejora la legibilidad del código, proporciona autocompletado en IDEs, y evita errores por el uso de strings incorrectos. También facilita la evolución del código, ya que los cambios en los valores se reflejan automáticamente en todas partes donde se utiliza el enum.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Excepciones Personalizadas</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            StripeLabApp utiliza excepciones personalizadas para manejar diferentes tipos de errores de manera específica, facilitando su captura y tratamiento adecuado.
                        </p>

                        <p><strong>Principales excepciones:</strong></p>
                        <ul>
                            <li>
                                <strong>ConfigurationException:</strong> Lanzada cuando hay un problema con la configuración de la aplicación (variables de entorno faltantes, valores incorrectos).
                            </li>
                            <li>
                                <strong>DatabaseException:</strong> Encapsula errores de la base de datos, proporcionando contexto adicional sobre la operación que falló.
                            </li>
                            <li>
                                <strong>InvalidWebhookPayloadException:</strong> Lanzada cuando el payload de un webhook no tiene el formato esperado o falta información crítica.
                            </li>
                            <li>
                                <strong>WebhookProcessingException:</strong> Indica un error durante el procesamiento de un webhook por parte de una estrategia específica.
                            </li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-info-circle"></i> <strong>Nota:</strong> Además de estas excepciones personalizadas, StripeLabApp también maneja las excepciones nativas de la biblioteca de Stripe, como <code>Stripe\Exception\SignatureVerificationException</code> para errores de verificación de firma de webhook, o <code>Stripe\Exception\ApiErrorException</code> para errores de la API de Stripe.
                        </div>

                        <p>
                            El uso de excepciones personalizadas permite un manejo más granular de los errores, facilitando respuestas específicas según el tipo de problema que ocurra.
                        </p>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Loggers</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            StripeLabApp implementa un sistema de logging especializado para diferentes aspectos de la aplicación, facilitando la depuración y la auditoría de operaciones críticas.
                        </p>

                        <p><strong>Loggers especializados:</strong></p>
                        <ul>
                            <li>
                                <strong>EventLogger:</strong> Registra información general sobre los eventos de la aplicación, como inicializaciones, procesos completados, o cambios de estado.
                            </li>
                            <li>
                                <strong>ErrorLogger:</strong> Captura y registra errores y excepciones, incluyendo trazas completas para facilitar la depuración.
                            </li>
                            <li>
                                <strong>DatabaseLogger:</strong> Registra operaciones críticas de base de datos, como inserciones, actualizaciones y errores específicos de la capa de persistencia.
                            </li>
                            <li>
                                <strong>StripePayloadLogger:</strong> Guarda los payloads recibidos de Stripe (omitiendo información sensible), lo que facilita el diagnóstico de problemas relacionados con webhooks.
                            </li>
                            <li>
                                <strong>UnhandledStripeEventLogger:</strong> Registra eventos de Stripe para los que no hay una estrategia implementada, facilitando la identificación de eventos que podrían requerir soporte en el futuro.
                            </li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
// Ejemplo de uso de loggers en una estrategia
try {
    // Procesar evento de Stripe
    $this->stripePayloadLogger->log($webhookPayload, 'payment_intent.succeeded');

    // Operación específica
    $transaction = $this->createTransaction($paymentIntent);
    $this->eventLogger->log("Transacción creada: {$transaction->stripe_transaction_id}");

    // Operación de base de datos
    $success = $this->transactionRepository->save($transaction);
    $this->databaseLogger->log("Transacción guardada en BD: {$transaction->stripe_transaction_id}");
} catch (Exception $e) {
    $this->errorLogger->logException($e, "Error al procesar payment_intent.succeeded");
    throw new WebhookProcessingException("No se pudo procesar el pago", 0, $e);
}
                        </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-shield-alt"></i> <strong>Importancia:</strong> Un buen sistema de logging es crucial para aplicaciones que manejan pagos, ya que permite auditar todas las operaciones financieras, facilita la detección y solución de problemas, y proporciona evidencia para la reconciliación financiera y resolución de disputas.
                        </div>
                    </div>
                </div>
            </div>

            <div id="capa-configuracion" class="subsection">
                <h4>7.3. Capa de Configuración (config/)</h4>
                <p>
                    La capa de configuración proporciona la infraestructura básica para inicializar la aplicación, cargar configuraciones y gestionar dependencias.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Bootstrap.php</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <code>Bootstrap.php</code> actúa como un Service Locator simple, gestionando la inicialización de la aplicación y la instanciación perezosa (lazy loading) de las dependencias principales. Sus responsabilidades incluyen:
                        </p>
                        <ul>
                            <li><strong>Carga de variables de entorno</strong> desde el archivo <code>.env</code> utilizando la biblioteca PHPDotEnv.</li>
                            <li><strong>Definición de constantes globales</strong> basadas en variables de entorno.</li>
                            <li><strong>Inicialización de Stripe</strong> con la clave API secreta.</li>
                            <li><strong>Registro de manejadores de errores y excepciones</strong> para capturar problemas no controlados.</li>
                            <li><strong>Configuración de zonas horarias y locales</strong> para estandarizar el formato de fechas y números.</li>
                            <li><strong>Provisión de instancias de servicios, controladores y repositorios</strong> mediante métodos de acceso.</li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
class Bootstrap
{
    private static ?Bootstrap $instance = null;
    private array $services = [];

    private function __construct()
    {
        // Cargar variables de entorno desde .env
        $dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/..');
        $dotenv->load();

        // Inicializar Stripe con la clave API secreta
        \Stripe\Stripe::setApiKey($_ENV['STRIPE_SECRET_KEY']);

        // Configurar zona horaria y locale
        date_default_timezone_set('Europe/Madrid');
        setlocale(LC_MONETARY, 'es_ES.UTF-8');
    }

    public static function getInstance(): Bootstrap
    {
        if (self::$instance === null) {
            self::$instance = new Bootstrap();
        }
        return self::$instance;
    }

    // Métodos para obtener servicios y dependencias (lazy loading)
    public function getTransactionRepository(): TransactionRepository
    {
        if (!isset($this->services[TransactionRepository::class])) {
            $this->services[TransactionRepository::class] = new TransactionRepository(
                DatabaseConnection::getInstance()->getPdo()
            );
        }
        return $this->services[TransactionRepository::class];
    }

    public function getStripeWebhookController(): StripeWebhookController
    {
        if (!isset($this->services[StripeWebhookController::class])) {
            $this->services[StripeWebhookController::class] = new StripeWebhookController(
                $this->getStripeWebhookService(),
                $this->getEventLogger(),
                $this->getErrorLogger()
            );
        }
        return $this->services[StripeWebhookController::class];
    }

    // ... métodos similares para otros servicios y dependencias
}
                        </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-lightbulb"></i> <strong>Enfoque:</strong> Aunque esta implementación es más simple que un contenedor de inyección de dependencias completo, proporciona muchos de los mismos beneficios: centralización de la creación de objetos, lazy loading, y gestión de dependencias sin acoplamiento rígido.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>DatabaseConnection.php</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <code>DatabaseConnection.php</code> implementa un patrón Singleton para proporcionar una única instancia de conexión PDO a la base de datos MySQL. Sus responsabilidades incluyen:
                        </p>
                        <ul>
                            <li><strong>Establecer la conexión a la base de datos</strong> utilizando los parámetros de configuración del archivo <code>.env</code>.</li>
                            <li><strong>Configurar opciones de PDO</strong> para manejo de errores y codificación.</li>
                            <li><strong>Proporcionar acceso a la instancia PDO</strong> para los repositorios.</li>
                            <li><strong>Manejar errores de conexión</strong> y lanzar excepciones apropiadas.</li>

                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
class DatabaseConnection
{
    private static ?DatabaseConnection $instance = null;
    private ?\PDO $pdo = null;

    private function __construct()
    {
        try {
            $host = $_ENV['DB_HOST'];
            $port = $_ENV['DB_PORT'];
            $dbname = $_ENV['DB_NAME'];
            $username = $_ENV['DB_USER'];
            $password = $_ENV['DB_PASSWORD'];

            $dsn = "mysql:host=$host;port=$port;dbname=$dbname;charset=utf8mb4";

            $this->pdo = new \PDO($dsn, $username, $password, [
                \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
                \PDO::ATTR_DEFAULT_FETCH_MODE => \PDO::FETCH_ASSOC,
                \PDO::ATTR_EMULATE_PREPARES => false,
            ]);
        } catch (\PDOException $e) {
            throw new DatabaseException("Error de conexión a la base de datos: " . $e->getMessage(), 0, $e);
        }
    }

    public static function getInstance(): DatabaseConnection
    {
        if (self::$instance === null) {
            self::$instance = new DatabaseConnection();
        }
        return self::$instance;
    }

    public function getPdo(): \PDO
    {
        return $this->pdo;
    }
}
                        </code></pre>
                        </div>

                        <div class="alert alert-warning mt-3">
                            <i class="fas fa-exclamation-triangle"></i> <strong>Consideración:</strong> Aunque el patrón Singleton es adecuado para este caso de uso, en aplicaciones más complejas podría ser preferible utilizar un pool de conexiones o un sistema de inyección de dependencias más sofisticado para gestionar las conexiones a la base de datos.
                        </div>
                    </div>
                </div>
            </div>

            <div id="capa-presentacion" class="subsection">
                <h4>7.4. Capa de Presentación y Puntos de Entrada (public/)</h4>
                <p>
                    La capa de presentación contiene los puntos de entrada de la aplicación, incluyendo páginas web, endpoints API y el endpoint de webhook. Esta capa se encarga de la interacción con el usuario y la comunicación con sistemas externos.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Páginas de Interfaz de Usuario</strong>
                    </div>
                    <div class="card-body">
                        <p><strong>Páginas principales para iniciar flujos de pago:</strong></p>
                        <ul>
                            <li>
                                <strong>index.php:</strong> Página principal que muestra las opciones disponibles (pago único o suscripción).
                            </li>
                            <li>
                                <strong>single-payment.php:</strong> Muestra el producto de pago único con opciones para proceder al checkout.
                            </li>
                            <li>
                                <strong>subscriptions-payment.php:</strong> Presenta los planes de suscripción disponibles (mensual y anual) y permite iniciar el proceso de suscripción.
                            </li>
                        </ul>

                        <p><strong>Páginas para visualización y gestión:</strong></p>
                        <ul>
                            <li>
                                <strong>invoices.php:</strong> Muestra un listado de facturas y recibos, con opciones de filtrado por cliente y acceso a los documentos PDF.
                            </li>
                            <li>
                                <strong>view-subscriptions.php:</strong> Permite ver y gestionar las suscripciones activas, incluyendo opciones para cancelación inmediata o al final del periodo.
                            </li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-paint-brush"></i> <strong>Diseño:</strong> Todas las páginas utilizan Bootstrap 5 para el diseño y la maquetación, lo que proporciona una interfaz responsiva y moderna. También utilizan JavaScript para cargar datos de manera asíncrona desde los endpoints API.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Endpoints de Checkout</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Estos endpoints son responsables de crear sesiones de Checkout en Stripe cuando el usuario decide realizar un pago o suscribirse a un plan.
                        </p>
                        <ul>
                            <li>
                                <strong>v1/create_payment_session.php:</strong> Crea una sesión de Checkout para un pago único. Recibe parámetros como cantidad, moneda y datos del cliente, y utiliza el <code>StripeCheckoutSessionService</code> para generar la sesión en Stripe.
                            </li>
                            <li>
                                <strong>v1/create_subscription_session.php:</strong> Crea una sesión de Checkout para una suscripción. Recibe el ID del plan (mensual o anual) y datos del cliente, y utiliza el <code>StripeCheckoutSessionService</code> para configurar la suscripción en Stripe.
                            </li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
// Ejemplo simplificado de create_subscription_session.php
require_once __DIR__ . '/../../config/Bootstrap.php';

$bootstrap = Bootstrap::getInstance();
$sessionService = $bootstrap->getStripeCheckoutSessionService();

// Validar y sanitizar datos de entrada
$priceId = $_POST['price_id'] ?? null;
$customerEmail = filter_var($_POST['email'] ?? '', FILTER_SANITIZE_EMAIL);
$customerName = htmlspecialchars($_POST['name'] ?? '');

if (!$priceId || !filter_var($customerEmail, FILTER_VALIDATE_EMAIL)) {
    http_response_code(400);
    echo json_encode(['error' => 'Datos inválidos']);
    exit;
}

try {
    // Crear sesión de Checkout para suscripción
    $session = $sessionService->createSubscriptionSession(
        $priceId,
        $customerEmail,
        $customerName,
        $_ENV['SUCCESS_URL'],
        $_ENV['CANCEL_URL']
    );

    // Devolver el ID de sesión para que el frontend redirija al Checkout
    echo json_encode(['sessionId' => $session->id]);
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['error' => 'Error al crear la sesión de pago']);
    $bootstrap->getErrorLogger()->logException($e);
}
                        </code></pre>
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Endpoint de Webhook</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>v1/webhook.php:</strong> Este es el punto de entrada más crítico de la aplicación, responsable de recibir todos los webhooks enviados por Stripe. Sus responsabilidades incluyen:
                        </p>
                        <ul>
                            <li>Recibir el payload JSON completo del webhook de Stripe.</li>
                            <li>Verificar la firma criptográfica utilizando el signing secret de Stripe.</li>
                            <li>Delegar el procesamiento al <code>StripeWebhookController</code>.</li>
                            <li>Manejar errores y devolver códigos de estado HTTP apropiados.</li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
// webhook.php - Punto de entrada para webhooks de Stripe
require_once __DIR__ . '/../../config/Bootstrap.php';

$bootstrap = Bootstrap::getInstance();
$webhookController = $bootstrap->getStripeWebhookController();
$logger = $bootstrap->getEventLogger();

// Obtener el payload completo y los headers
$payload = @file_get_contents('php://input');
$sigHeader = $_SERVER['HTTP_STRIPE_SIGNATURE'] ?? '';

try {
    // Procesar el webhook y obtener una respuesta
    $response = $webhookController->handleWebhook($payload, $sigHeader);

    // Enviar la respuesta con el código HTTP adecuado
    http_response_code($response['code']);
    echo json_encode($response['body']);

    $logger->log("Webhook procesado: " . $response['body']['type'] ?? 'desconocido');
} catch (Exception $e) {
    // Manejar errores y devolver códigos apropiados
    http_response_code(500);
    echo json_encode(['error' => 'Error interno del servidor']);

    $bootstrap->getErrorLogger()->logException($e, "Error al procesar webhook");
}
                        </code></pre>
                        </div>

                        <div class="alert alert-warning mt-3">
                            <i class="fas fa-shield-alt"></i> <strong>Seguridad crítica:</strong> La verificación de la firma es esencial para garantizar que las peticiones provienen realmente de Stripe y no han sido manipuladas. Sin esta verificación, un atacante podría enviar eventos falsos que podrían resultar en fraude o manipulación de datos sensibles.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Endpoints API</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Estos endpoints proporcionan acceso a los datos de la aplicación para que la interfaz de usuario pueda mostrarlos y permitir interacciones con ellos.
                        </p>
                        <ul>
                            <li>
                                <strong>v1/api/api-invoices.php:</strong> Proporciona acceso a los datos de facturas y recibos. Admite acciones como <code>list_all</code> (listar todas las facturas) y <code>list_customer</code> (listar facturas de un cliente específico).
                            </li>
                            <li>
                                <strong>v1/api/api-subscriptions.php:</strong> Permite acceder a los datos de suscripciones. Soporta acciones como <code>list_all_system</code> (todas las suscripciones) y <code>list_customer</code> (suscripciones de un cliente).
                            </li>
                            <li>
                                <strong>v1/api/api-manage-subscription.php:</strong> Gestiona operaciones sobre suscripciones, principalmente la cancelación (inmediata o al final del periodo) utilizando el <code>StripeSubscriptionManagementService</code>.
                            </li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
// Ejemplo simplificado de api-subscriptions.php
require_once __DIR__ . '/../../../config/Bootstrap.php';

$bootstrap = Bootstrap::getInstance();
$displayService = $bootstrap->getDisplayService();

// Validar la acción solicitada
$action = $_GET['action'] ?? '';
$validActions = ['list_all_system', 'list_customer'];

if (!in_array($action, $validActions)) {
    http_response_code(400);
    echo json_encode(['error' => 'Acción no válida']);
    exit;
}

try {
    $result = [];

    // Ejecutar la acción correspondiente
    if ($action === 'list_all_system') {
        $result = $displayService->getAllSubscriptions();
    } elseif ($action === 'list_customer') {
        $customerId = $_GET['customer_id'] ?? '';
        if (!$customerId) {
            throw new \InvalidArgumentException('ID de cliente requerido');
        }
        $result = $displayService->getCustomerSubscriptions($customerId);
    }

    // Devolver los resultados como JSON
    header('Content-Type: application/json');
    echo json_encode(['subscriptions' => $result]);
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['error' => $e->getMessage()]);
    $bootstrap->getErrorLogger()->logException($e);
}
                        </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-code"></i> <strong>Arquitectura:</strong> Estos endpoints API siguen un patrón simple pero efectivo: validar la entrada, delegar la lógica a servicios especializados, y devolver respuestas JSON estructuradas que pueden ser consumidas fácilmente por el frontend.
                        </div>
                    </div>
                </div>
            </div>

            <div id="controladores" class="subsection">
                <h4>7.5. Controladores (src/Controller/)</h4>
                <p>
                    Los controladores coordinan el flujo de la aplicación, recibiendo peticiones HTTP, delegando la lógica de negocio a los servicios apropiados, y devolviendo respuestas estructuradas.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>StripeWebhookController</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Actúa como punto de entrada para los eventos de webhook de Stripe, verificando la firma y delegando el procesamiento al servicio adecuado.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Recibir y validar los payloads de webhook entrantes.</li>
                            <li>Verificar la firma criptográfica del webhook utilizando el signing secret.</li>
                            <li>Delegar el procesamiento del evento al <code>StripeWebhookService</code>.</li>
                            <li>Manejar excepciones y errores que puedan ocurrir durante el procesamiento.</li>
                            <li>Devolver respuestas HTTP apropiadas (200 OK para procesamiento exitoso, 4xx para errores del cliente, 5xx para errores del servidor).</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class StripeWebhookController
{
   private StripeWebhookService $webhookService;
   private EventLogger $eventLogger;
   private ErrorLogger $errorLogger;

   public function __construct(
       StripeWebhookService $webhookService,
       EventLogger $eventLogger,
       ErrorLogger $errorLogger
   ) {
       $this->webhookService = $webhookService;
       $this->eventLogger = $eventLogger;
       $this->errorLogger = $errorLogger;
   }

   public function handleWebhook(string $payload, string $sigHeader): array
   {
       try {
           // Verificar firma y construir el evento
           $event = $this->webhookService->constructEvent($payload, $sigHeader);

           // Registrar la recepción del evento
           $this->eventLogger->log("Webhook recibido: {$event->type} - {$event->id}");

           // Procesar el evento
           $result = $this->webhookService->processEvent($event);

           // Devolver respuesta exitosa
           return [
               'code' => 200,
               'body' => [
                   'status' => 'success',
                   'type' => $event->type,
                   'id' => $event->id
               ]
           ];
       } catch (\Stripe\Exception\SignatureVerificationException $e) {
           // Error de verificación de firma
           $this->errorLogger->logException($e, "Error de verificación de firma de webhook");
           return [
               'code' => 400,
               'body' => ['error' => 'Invalid signature']
           ];
       } catch (InvalidWebhookPayloadException $e) {
           // Payload inválido
           $this->errorLogger->logException($e, "Payload de webhook inválido");
           return [
               'code' => 400,
               'body' => ['error' => 'Invalid payload']
           ];
       } catch (WebhookProcessingException $e) {
           // Error durante el procesamiento
           $this->errorLogger->logException($e, "Error al procesar webhook");
           return [
               'code' => 500,
               'body' => ['error' => 'Processing error']
           ];
       } catch (\Exception $e) {
           // Error inesperado
           $this->errorLogger->logException($e, "Error inesperado al manejar webhook");
           return [
               'code' => 500,
               'body' => ['error' => 'Internal server error']
           ];
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-info-circle"></i> <strong>Importancia:</strong> Este controlador es crítico para el funcionamiento de la aplicación, ya que gestiona toda la comunicación asíncrona con Stripe. Su diseño robusto para el manejo de errores asegura que los webhooks sean procesados correctamente o que se proporcionen respuestas adecuadas en caso de fallos.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
<div id="capa-commons" class="subsection">
                <h4>7.2. Capa Commons</h4>
                <p>
                    La capa Commons contiene componentes fundamentales utilizados en toda la aplicación, proporcionando estructura, tipado y funcionalidades comunes. Estos componentes son la base sobre la que se construyen las demás capas.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>DTOs (Data Transfer Objects)</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Los DTOs en StripeLabApp facilitan la transferencia de datos entre las diferentes capas de la aplicación sin exponer los detalles de implementación de las entidades de dominio. También proporcionan una estructura clara para los datos que se envían al frontend.
                        </p>

                        <p><strong>Ejemplos de DTOs:</strong></p>
                        <ul>
                            <li>
                                <strong>SubscriptionDTO:</strong> Representa una suscripción con todos los datos necesarios para la visualización y gestión:
                                <div class="code-snippet">
                                <pre><code class="language-php">
class SubscriptionDTO
{
    public int $id;
    public string $subscriptionId;
    public string $customerId;
    public string $status;
    public string $planId;
    public string $planName;
    public float $amount;
    public string $currency;
    public string $interval;
    public DateTime $currentPeriodStart;
    public DateTime $currentPeriodEnd;
    public ?DateTime $canceledAt;
    public bool $cancelAtPeriodEnd;
    public DateTime $createdAt;
    public ?DateTime $endedAt;
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>InvoiceDTO:</strong> Contiene la información de una factura para mostrar en la interfaz:
                                <div class="code-snippet">
                                <pre><code class="language-php">
class InvoiceDTO
{
    public string $invoiceId;
    public string $customerId;
    public ?string $subscriptionId;
    public float $amount;
    public string $currency;
    public string $status;
    public DateTime $createdAt;
    public ?string $invoiceUrl;
    public ?string $receiptUrl;
    public ?string $description;
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>TransactionDTO:</strong> Representa una transacción de pago, ya sea única o parte de una suscripción:
                                <div class="code-snippet">
                                <pre><code class="language-php">
                                class TransactionDTO
                                {
                                    public int $id;
                                    public string $transactionId;
                                    public ?string $customerId;
                                    public string $type;
                                    public float $amount;
                                    public string $currency;
                                    public string $status;
                                    public ?string $paymentMethodDetails;
                                    public ?string $receiptUrl;
                                    public DateTime $createdAt;
                                    public ?string $description;
                                }

                                 </code></pre>
                                </div>
                            </li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-lightbulb"></i> <strong>Beneficio:</strong> Los DTOs proporcionan una capa de abstracción que facilita la evolución de las entidades internas sin afectar a las interfaces externas. También simplifican la serialización a JSON para las respuestas API.
                        </div>
                    </div>
                </div>
                <!-- Aquí termina la sección 7.2 parcial - continúa con el resto de la sección 7.2 y las siguientes secciones -->

                <!-- Continuación de la sección 7.2 Capa Commons -->
                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Entidades (Models)</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Las entidades o modelos representan los objetos de dominio principales de la aplicación y corresponden directamente a las tablas de la base de datos. Contienen la lógica específica del dominio y las reglas de negocio.
                        </p>

                        <p><strong>Principales modelos:</strong></p>
                        <ul>
                            <li>
                                <strong>TransactionsModel:</strong> Representa una transacción financiera en el sistema:
                                <div class="code-snippet">
                                <pre><code class="language-php">
class TransactionsModel
{
    public int $transaction_id; // ID autoincremental en la BD
    public string $stripe_transaction_id; // ID de Stripe (payment_intent o charge)
    public ?string $stripe_customer_id; // ID del cliente en Stripe
    public string $transaction_type; // Tipo (PAYMENT, SUBSCRIPTION, REFUND)
    public float $amount; // Importe
    public string $currency; // Moneda (EUR, USD, etc.)
    public string $status; // Estado (COMPLETED, FAILED, REFUNDED)
    public ?string $payment_method_details; // Detalles del método de pago en JSON
    public ?string $receipt_url; // URL al recibo en Stripe
    public DateTimeImmutable $created_at; // Fecha de creación
    public ?string $description; // Descripción opcional
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>SubscriptionsModel:</strong> Representa una suscripción de un cliente:
                                <div class="code-snippet">
                                <pre><code class="language-php">
class SubscriptionsModel
{
    public string $subscription_id; // ID de Stripe (sub_...)
    public string $customer_id; // ID del cliente en Stripe
    public string $status; // Estado (active, canceled, etc.)
    public string $plan_id; // ID del plan en Stripe
    public string $plan_name; // Nombre descriptivo del plan
    public float $amount; // Importe por periodo
    public string $currency; // Moneda
    public string $interval; // Intervalo (month, year)
    public DateTimeImmutable $current_period_start; // Inicio del periodo actual
    public DateTimeImmutable $current_period_end; // Fin del periodo actual
    public ?DateTimeImmutable $canceled_at; // Fecha de cancelación (si aplica)
    public bool $cancel_at_period_end; // Si se cancelará al final del periodo
    public DateTimeImmutable $created_at; // Fecha de creación
    public ?DateTimeImmutable $ended_at; // Fecha de finalización (si terminó)
}
                                </code></pre>
                                </div>
                            </li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-database"></i> <strong>Relación con la base de datos:</strong>
                            <p>Cada campo de estos modelos corresponde directamente a una columna en las tablas <code>transactions</code> y <code>subscriptions</code> respectivamente. La tabla <code>transactions</code> utiliza un <code>transaction_id</code> autoincremental como clave primaria, mientras que <code>subscriptions</code> utiliza el <code>subscription_id</code> de Stripe como clave primaria natural.</p>
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Enums</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Las enumeraciones proporcionan un tipado fuerte para valores constantes en la aplicación, mejorando la legibilidad del código y reduciendo errores por el uso de strings literales.
                        </p>

                        <p><strong>Principales enumeraciones:</strong></p>
                        <ul>
                            <li>
                                <strong>StripeEventTypeEnum:</strong> Define los tipos de eventos de Stripe que la aplicación maneja:
                                <div class="code-snippet">
                                <pre><code class="language-php">
enum StripeEventTypeEnum: string
{
    case CHECKOUT_SESSION_COMPLETED = 'checkout.session.completed';
    case PAYMENT_INTENT_SUCCEEDED = 'payment_intent.succeeded';
    case CHARGE_SUCCEEDED = 'charge.succeeded';
    case CUSTOMER_CREATED = 'customer.created';
    case CUSTOMER_UPDATED = 'customer.updated';
    case CUSTOMER_SUBSCRIPTION_CREATED = 'customer.subscription.created';
    case CUSTOMER_SUBSCRIPTION_UPDATED = 'customer.subscription.updated';
    case CUSTOMER_SUBSCRIPTION_DELETED = 'customer.subscription.deleted';
    case INVOICE_PAID = 'invoice.paid';
    // ... otros eventos soportados
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>TransactionTypeEnum:</strong> Define los tipos de transacciones financieras:
                                <div class="code-snippet">
                                <pre><code class="language-php">
enum TransactionTypeEnum: string
{
    case PAYMENT = 'PAYMENT';           // Pago único
    case SUBSCRIPTION = 'SUBSCRIPTION';  // Pago de suscripción
    case REFUND = 'REFUND';              // Reembolso
}
                                </code></pre>
                                </div>
                            </li>
                            <li>
                                <strong>TransactionStatusEnum:</strong> Define los posibles estados de una transacción:
                                <div class="code-snippet">
                                <pre><code class="language-php">
enum TransactionStatusEnum: string
{
    case COMPLETED = 'COMPLETED';  // Transacción completada
    case FAILED = 'FAILED';        // Transacción fallida
    case REFUNDED = 'REFUNDED';    // Transacción reembolsada
    case PENDING = 'PENDING';      // Transacción pendiente
}
                                </code></pre>
                                </div>
                            </li>
                        </ul>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Beneficio:</strong> El uso de enums mejora la legibilidad del código, proporciona autocompletado en IDEs, y evita errores por el uso de strings incorrectos. También facilita la evolución del código, ya que los cambios en los valores se reflejan automáticamente en todas partes donde se utiliza el enum.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Excepciones Personalizadas</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            StripeLabApp utiliza excepciones personalizadas para manejar diferentes tipos de errores de manera específica, facilitando su captura y tratamiento adecuado.
                        </p>

                        <p><strong>Principales excepciones:</strong></p>
                        <ul>
                            <li>
                                <strong>ConfigurationException:</strong> Lanzada cuando hay un problema con la configuración de la aplicación (variables de entorno faltantes, valores incorrectos).
                            </li>
                            <li>
                                <strong>DatabaseException:</strong> Encapsula errores de la base de datos, proporcionando contexto adicional sobre la operación que falló.
                            </li>
                            <li>
                                <strong>InvalidWebhookPayloadException:</strong> Lanzada cuando el payload de un webhook no tiene el formato esperado o falta información crítica.
                            </li>
                            <li>
                                <strong>WebhookProcessingException:</strong> Indica un error durante el procesamiento de un webhook por parte de una estrategia específica.
                            </li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-info-circle"></i> <strong>Nota:</strong> Además de estas excepciones personalizadas, StripeLabApp también maneja las excepciones nativas de la biblioteca de Stripe, como <code>Stripe\Exception\SignatureVerificationException</code> para errores de verificación de firma de webhook, o <code>Stripe\Exception\ApiErrorException</code> para errores de la API de Stripe.
                        </div>

                        <p>
                            El uso de excepciones personalizadas permite un manejo más granular de los errores, facilitando respuestas específicas según el tipo de problema que ocurra.
                        </p>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Loggers</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            StripeLabApp implementa un sistema de logging especializado para diferentes aspectos de la aplicación, facilitando la depuración y la auditoría de operaciones críticas.
                        </p>

                        <p><strong>Loggers especializados:</strong></p>
                        <ul>
                            <li>
                                <strong>EventLogger:</strong> Registra información general sobre los eventos de la aplicación, como inicializaciones, procesos completados, o cambios de estado.
                            </li>
                            <li>
                                <strong>ErrorLogger:</strong> Captura y registra errores y excepciones, incluyendo trazas completas para facilitar la depuración.
                            </li>
                            <li>
                                <strong>DatabaseLogger:</strong> Registra operaciones críticas de base de datos, como inserciones, actualizaciones y errores específicos de la capa de persistencia.
                            </li>
                            <li>
                                <strong>StripePayloadLogger:</strong> Guarda los payloads recibidos de Stripe (omitiendo información sensible), lo que facilita el diagnóstico de problemas relacionados con webhooks.
                            </li>
                            <li>
                                <strong>UnhandledStripeEventLogger:</strong> Registra eventos de Stripe para los que no hay una estrategia implementada, facilitando la identificación de eventos que podrían requerir soporte en el futuro.
                            </li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
// Ejemplo de uso de loggers en una estrategia
try {
    // Procesar evento de Stripe
    $this->stripePayloadLogger->log($webhookPayload, 'payment_intent.succeeded');

    // Operación específica
    $transaction = $this->createTransaction($paymentIntent);
    $this->eventLogger->log("Transacción creada: {$transaction->stripe_transaction_id}");

    // Operación de base de datos
    $success = $this->transactionRepository->save($transaction);
    $this->databaseLogger->log("Transacción guardada en BD: {$transaction->stripe_transaction_id}");
} catch (Exception $e) {
    $this->errorLogger->logException($e, "Error al procesar payment_intent.succeeded");
    throw new WebhookProcessingException("No se pudo procesar el pago", 0, $e);
}
                        </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-shield-alt"></i> <strong>Importancia:</strong> Un buen sistema de logging es crucial para aplicaciones que manejan pagos, ya que permite auditar todas las operaciones financieras, facilita la detección y solución de problemas, y proporciona evidencia para la reconciliación financiera y resolución de disputas.
                        </div>
                    </div>
                </div>
            </div>

            <div id="capa-configuracion" class="subsection">
                <h4>7.3. Capa de Configuración (config/)</h4>
                <p>
                    La capa de configuración proporciona la infraestructura básica para inicializar la aplicación, cargar configuraciones y gestionar dependencias.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Bootstrap.php</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <code>Bootstrap.php</code> actúa como un Service Locator simple, gestionando la inicialización de la aplicación y la instanciación perezosa (lazy loading) de las dependencias principales. Sus responsabilidades incluyen:
                        </p>
                        <ul>
                            <li><strong>Carga de variables de entorno</strong> desde el archivo <code>.env</code> utilizando la biblioteca PHPDotEnv.</li>
                            <li><strong>Definición de constantes globales</strong> basadas en variables de entorno.</li>
                            <li><strong>Inicialización de Stripe</strong> con la clave API secreta.</li>
                            <li><strong>Registro de manejadores de errores y excepciones</strong> para capturar problemas no controlados.</li>
                            <li><strong>Configuración de zonas horarias y locales</strong> para estandarizar el formato de fechas y números.</li>
                            <li><strong>Provisión de instancias de servicios, controladores y repositorios</strong> mediante métodos de acceso.</li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
class Bootstrap
{
    private static ?Bootstrap $instance = null;
    private array $services = [];

    private function __construct()
    {
        // Cargar variables de entorno desde .env
        $dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/..');
        $dotenv->load();

        // Inicializar Stripe con la clave API secreta
        \Stripe\Stripe::setApiKey($_ENV['STRIPE_SECRET_KEY']);

        // Configurar zona horaria y locale
        date_default_timezone_set('Europe/Madrid');
        setlocale(LC_MONETARY, 'es_ES.UTF-8');
    }

    public static function getInstance(): Bootstrap
    {
        if (self::$instance === null) {
            self::$instance = new Bootstrap();
        }
        return self::$instance;
    }

    // Métodos para obtener servicios y dependencias (lazy loading)
    public function getTransactionRepository(): TransactionRepository
    {
        if (!isset($this->services[TransactionRepository::class])) {
            $this->services[TransactionRepository::class] = new TransactionRepository(
                DatabaseConnection::getInstance()->getPdo()
            );
        }
        return $this->services[TransactionRepository::class];
    }

    public function getStripeWebhookController(): StripeWebhookController
    {
        if (!isset($this->services[StripeWebhookController::class])) {
            $this->services[StripeWebhookController::class] = new StripeWebhookController(
                $this->getStripeWebhookService(),
                $this->getEventLogger(),
                $this->getErrorLogger()
            );
        }
        return $this->services[StripeWebhookController::class];
    }

    // ... métodos similares para otros servicios y dependencias
}
                        </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-lightbulb"></i> <strong>Enfoque:</strong> Aunque esta implementación es más simple que un contenedor de inyección de dependencias completo, proporciona muchos de los mismos beneficios: centralización de la creación de objetos, lazy loading, y gestión de dependencias sin acoplamiento rígido.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>DatabaseConnection.php</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <code>DatabaseConnection.php</code> implementa un patrón Singleton para proporcionar una única instancia de conexión PDO a la base de datos MySQL. Sus responsabilidades incluyen:
                        </p>
                        <ul>
                            <li><strong>Establecer la conexión a la base de datos</strong> utilizando los parámetros de configuración del archivo <code>.env</code>.</li>
                            <li><strong>Configurar opciones de PDO</strong> para manejo de errores y codificación.</li>
                            <li><strong>Proporcionar acceso a la instancia PDO</strong> para los repositorios.</li>
                            <li><strong>Manejar errores de conexión</strong> y lanzar excepciones apropiadas.</li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
class DatabaseConnection
{
    private static ?DatabaseConnection $instance = null;
    private ?\PDO $pdo = null;

    private function __construct()
    {
        try {
            $host = $_ENV['DB_HOST'];
            $port = $_ENV['DB_PORT'];
            $dbname = $_ENV['DB_NAME'];
            $username = $_ENV['DB_USER'];
            $password = $_ENV['DB_PASSWORD'];

            $dsn = "mysql:host=$host;port=$port;dbname=$dbname;charset=utf8mb4";

            $this->pdo = new \PDO($dsn, $username, $password, [
                \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
                \PDO::ATTR_DEFAULT_FETCH_MODE => \PDO::FETCH_ASSOC,
                \PDO::ATTR_EMULATE_PREPARES => false,
            ]);
        } catch (\PDOException $e) {
            throw new DatabaseException("Error de conexión a la base de datos: " . $e->getMessage(), 0, $e);
        }
    }

    public static function getInstance(): DatabaseConnection
    {
        if (self::$instance === null) {
            self::$instance = new DatabaseConnection();
        }
        return self::$instance;
    }

    public function getPdo(): \PDO
    {
        return $this->pdo;
    }
}
                        </code></pre>
                        </div>

                        <div class="alert alert-warning mt-3">
                            <i class="fas fa-exclamation-triangle"></i> <strong>Consideración:</strong> Aunque el patrón Singleton es adecuado para este caso de uso, en aplicaciones más complejas podría ser preferible utilizar un pool de conexiones o un sistema de inyección de dependencias más sofisticado para gestionar las conexiones a la base de datos.
                        </div>
                    </div>
                </div>
            </div>

            <div id="capa-presentacion" class="subsection">
                <h4>7.4. Capa de Presentación y Puntos de Entrada (public/)</h4>
                <p>
                    La capa de presentación contiene los puntos de entrada de la aplicación, incluyendo páginas web, endpoints API y el endpoint de webhook. Esta capa se encarga de la interacción con el usuario y la comunicación con sistemas externos.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Páginas de Interfaz de Usuario</strong>
                    </div>
                    <div class="card-body">
                        <p><strong>Páginas principales para iniciar flujos de pago:</strong></p>
                        <ul>
                            <li>
                                <strong>index.php:</strong> Página principal que muestra las opciones disponibles (pago único o suscripción).
                            </li>
                            <li>
                                <strong>single-payment.php:</strong> Muestra el producto de pago único con opciones para proceder al checkout.
                            </li>
                            <li>
                                <strong>subscriptions-payment.php:</strong> Presenta los planes de suscripción disponibles (mensual y anual) y permite iniciar el proceso de suscripción.
                            </li>
                        </ul>

                        <p><strong>Páginas para visualización y gestión:</strong></p>
                        <ul>
                            <li>
                                <strong>invoices.php:</strong> Muestra un listado de facturas y recibos, con opciones de filtrado por cliente y acceso a los documentos PDF.
                            </li>
                            <li>
                                <strong>view-subscriptions.php:</strong> Permite ver y gestionar las suscripciones activas, incluyendo opciones para cancelación inmediata o al final del periodo.
                            </li>
                        </ul>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-paint-brush"></i> <strong>Diseño:</strong> Todas las páginas utilizan Bootstrap 5 para el diseño y la maquetación, lo que proporciona una interfaz responsiva y moderna. También utilizan JavaScript para cargar datos de manera asíncrona desde los endpoints API.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Endpoints de Checkout</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Estos endpoints son responsables de crear sesiones de Checkout en Stripe cuando el usuario decide realizar un pago o suscribirse a un plan.
                        </p>
                        <ul>
                            <li>
                                <strong>v1/create_payment_session.php:</strong> Crea una sesión de Checkout para un pago único. Recibe parámetros como cantidad, moneda y datos del cliente, y utiliza el <code>StripeCheckoutSessionService</code> para generar la sesión en Stripe.
                            </li>
                            <li>
                                <strong>v1/create_subscription_session.php:</strong> Crea una sesión de Checkout para una suscripción. Recibe el ID del plan (mensual o anual) y datos del cliente, y utiliza el <code>StripeCheckoutSessionService</code> para configurar la suscripción en Stripe.
                            </li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
// Ejemplo simplificado de create_subscription_session.php
require_once __DIR__ . '/../../config/Bootstrap.php';

$bootstrap = Bootstrap::getInstance();
$sessionService = $bootstrap->getStripeCheckoutSessionService();

// Validar y sanitizar datos de entrada
$priceId = $_POST['price_id'] ?? null;
$customerEmail = filter_var($_POST['email'] ?? '', FILTER_SANITIZE_EMAIL);
$customerName = htmlspecialchars($_POST['name'] ?? '');

if (!$priceId || !filter_var($customerEmail, FILTER_VALIDATE_EMAIL)) {
    http_response_code(400);
    echo json_encode(['error' => 'Datos inválidos']);
    exit;
}

try {
    // Crear sesión de Checkout para suscripción
    $session = $sessionService->createSubscriptionSession(
        $priceId,
        $customerEmail,
        $customerName,
        $_ENV['SUCCESS_URL'],
        $_ENV['CANCEL_URL']
    );

    // Devolver el ID de sesión para que el frontend redirija al Checkout
    echo json_encode(['sessionId' => $session->id]);
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['error' => 'Error al crear la sesión de pago']);
    $bootstrap->getErrorLogger()->logException($e);
}
                        </code></pre>
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Endpoint de Webhook</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>v1/webhook.php:</strong> Este es el punto de entrada más crítico de la aplicación, responsable de recibir todos los webhooks enviados por Stripe. Sus responsabilidades incluyen:
                        </p>
                        <ul>
                            <li>Recibir el payload JSON completo del webhook de Stripe.</li>
                            <li>Verificar la firma criptográfica utilizando el signing secret de Stripe.</li>
                            <li>Delegar el procesamiento al <code>StripeWebhookController</code>.</li>
                            <li>Manejar errores y devolver códigos de estado HTTP apropiados.</li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
// webhook.php - Punto de entrada para webhooks de Stripe
require_once __DIR__ . '/../../config/Bootstrap.php';

$bootstrap = Bootstrap::getInstance();
$webhookController = $bootstrap->getStripeWebhookController();
$logger = $bootstrap->getEventLogger();

// Obtener el payload completo y los headers
$payload = @file_get_contents('php://input');
$sigHeader = $_SERVER['HTTP_STRIPE_SIGNATURE'] ?? '';

try {
    // Procesar el webhook y obtener una respuesta
    $response = $webhookController->handleWebhook($payload, $sigHeader);

    // Enviar la respuesta con el código HTTP adecuado
    http_response_code($response['code']);
    echo json_encode($response['body']);

    $logger->log("Webhook procesado: " . $response['body']['type'] ?? 'desconocido');
} catch (Exception $e) {
    // Manejar errores y devolver códigos apropiados
    http_response_code(500);
    echo json_encode(['error' => 'Error interno del servidor']);

    $bootstrap->getErrorLogger()->logException($e, "Error al procesar webhook");
}
                        </code></pre>
                        </div>

                        <div class="alert alert-warning mt-3">
                            <i class="fas fa-shield-alt"></i> <strong>Seguridad crítica:</strong> La verificación de la firma es esencial para garantizar que las peticiones provienen realmente de Stripe y no han sido manipuladas. Sin esta verificación, un atacante podría enviar eventos falsos que podrían resultar en fraude o manipulación de datos sensibles.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Endpoints API</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            Estos endpoints proporcionan acceso a los datos de la aplicación para que la interfaz de usuario pueda mostrarlos y permitir interacciones con ellos.
                        </p>
                        <ul>
                            <li>
                                <strong>v1/api/api-invoices.php:</strong> Proporciona acceso a los datos de facturas y recibos. Admite acciones como <code>list_all</code> (listar todas las facturas) y <code>list_customer</code> (listar facturas de un cliente específico).
                            </li>
                            <li>
                                <strong>v1/api/api-subscriptions.php:</strong> Permite acceder a los datos de suscripciones. Soporta acciones como <code>list_all_system</code> (todas las suscripciones) y <code>list_customer</code> (suscripciones de un cliente).
                            </li>
                            <li>
                                <strong>v1/api/api-manage-subscription.php:</strong> Gestiona operaciones sobre suscripciones, principalmente la cancelación (inmediata o al final del periodo) utilizando el <code>StripeSubscriptionManagementService</code>.
                            </li>
                        </ul>

                        <div class="code-snippet">
                        <pre><code class="language-php">
// Ejemplo simplificado de api-subscriptions.php
require_once __DIR__ . '/../../../config/Bootstrap.php';

$bootstrap = Bootstrap::getInstance();
$displayService = $bootstrap->getDisplayService();

// Validar la acción solicitada
$action = $_GET['action'] ?? '';
$validActions = ['list_all_system', 'list_customer'];

if (!in_array($action, $validActions)) {
    http_response_code(400);
    echo json_encode(['error' => 'Acción no válida']);
    exit;
}

try {
    $result = [];

    // Ejecutar la acción correspondiente
    if ($action === 'list_all_system') {
        $result = $displayService->getAllSubscriptions();
    } elseif ($action === 'list_customer') {
        $customerId = $_GET['customer_id'] ?? '';
        if (!$customerId) {
            throw new \InvalidArgumentException('ID de cliente requerido');
        }
        $result = $displayService->getCustomerSubscriptions($customerId);
    }

    // Devolver los resultados como JSON
    header('Content-Type: application/json');
    echo json_encode(['subscriptions' => $result]);
} catch (Exception $e) {
    http_response_code(500);
    echo json_encode(['error' => $e->getMessage()]);
    $bootstrap->getErrorLogger()->logException($e);
}
                        </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-code"></i> <strong>Arquitectura:</strong> Estos endpoints API siguen un patrón simple pero efectivo: validar la entrada, delegar la lógica a servicios especializados, y devolver respuestas JSON estructuradas que pueden ser consumidas fácilmente por el frontend.
                        </div>
                    </div>
                </div>
            </div>

            <div id="controladores" class="subsection">
                <h4>7.5. Controladores (src/Controller/)</h4>
                <p>
                    Los controladores coordinan el flujo de la aplicación, recibiendo peticiones HTTP, delegando la lógica de negocio a los servicios apropiados, y devolviendo respuestas estructuradas.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>StripeWebhookController</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Actúa como punto de entrada para los eventos de webhook de Stripe, verificando la firma y delegando el procesamiento al servicio adecuado.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Recibir y validar los payloads de webhook entrantes.</li>
                            <li>Verificar la firma criptográfica del webhook utilizando el signing secret.</li>
                            <li>Delegar el procesamiento del evento al <code>StripeWebhookService</code>.</li>
                            <li>Manejar excepciones y errores que puedan ocurrir durante el procesamiento.</li>
                            <li>Devolver respuestas HTTP apropiadas (200 OK para procesamiento exitoso, 4xx para errores del cliente, 5xx para errores del servidor).</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class StripeWebhookController
{
   private StripeWebhookService $webhookService;
   private EventLogger $eventLogger;
   private ErrorLogger $errorLogger;

   public function __construct(
       StripeWebhookService $webhookService,
       EventLogger $eventLogger,
       ErrorLogger $errorLogger
   ) {
       $this->webhookService = $webhookService;
       $this->eventLogger = $eventLogger;
       $this->errorLogger = $errorLogger;
   }

   public function handleWebhook(string $payload, string $sigHeader): array
   {
       try {
           // Verificar firma y construir el evento
           $event = $this->webhookService->constructEvent($payload, $sigHeader);

           // Registrar la recepción del evento
           $this->eventLogger->log("Webhook recibido: {$event->type} - {$event->id}");

           // Procesar el evento
           $result = $this->webhookService->processEvent($event);

           // Devolver respuesta exitosa
           return [
               'code' => 200,
               'body' => [
                   'status' => 'success',
                   'type' => $event->type,
                   'id' => $event->id
               ]
           ];
       } catch (\Stripe\Exception\SignatureVerificationException $e) {
           // Error de verificación de firma
           $this->errorLogger->logException($e, "Error de verificación de firma de webhook");
           return [
               'code' => 400,
               'body' => ['error' => 'Invalid signature']
           ];
       } catch (InvalidWebhookPayloadException $e) {
           // Payload inválido
           $this->errorLogger->logException($e, "Payload de webhook inválido");
           return [
               'code' => 400,
               'body' => ['error' => 'Invalid payload']
           ];
       } catch (WebhookProcessingException $e) {
           // Error durante el procesamiento
           $this->errorLogger->logException($e, "Error al procesar webhook");
           return [
               'code' => 500,
               'body' => ['error' => 'Processing error']
           ];
       } catch (\Exception $e) {
           // Error inesperado
           $this->errorLogger->logException($e, "Error inesperado al manejar webhook");
           return [
               'code' => 500,
               'body' => ['error' => 'Internal server error']
           ];
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-info-circle"></i> <strong>Importancia:</strong> Este controlador es crítico para el funcionamiento de la aplicación, ya que gestiona toda la comunicación asíncrona con Stripe. Su diseño robusto para el manejo de errores asegura que los webhooks sean procesados correctamente o que se proporcionen respuestas adecuadas en caso de fallos.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>DisplayController</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Proporciona endpoints para que la interfaz de usuario obtenga datos sobre facturas, suscripciones y transacciones.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Validar y procesar parámetros de solicitud (filtros, paginación, etc.).</li>
                            <li>Delegar la recuperación de datos al <code>DisplayService</code>.</li>
                            <li>Formatear y devolver datos en formato JSON para su consumo por el frontend.</li>
                            <li>Gestionar errores y excepciones que puedan ocurrir durante la recuperación de datos.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class DisplayController
{
   private DisplayService $displayService;
   private ErrorLogger $errorLogger;

   public function __construct(
       DisplayService $displayService,
       ErrorLogger $errorLogger
   ) {
       $this->displayService = $displayService;
       $this->errorLogger = $errorLogger;
   }

   public function getInvoices(array $params): array
   {
       try {
           // Determinar el tipo de consulta basado en los parámetros
           if (isset($params['customer_id'])) {
               $invoices = $this->displayService->getCustomerInvoices($params['customer_id']);
           } else {
               $page = isset($params['page']) ? (int)$params['page'] : 1;
               $limit = isset($params['limit']) ? (int)$params['limit'] : 10;
               $invoices = $this->displayService->getAllInvoices($page, $limit);
           }

           return [
               'code' => 200,
               'body' => [
                   'status' => 'success',
                   'invoices' => $invoices
               ]
           ];
       } catch (\Exception $e) {
           $this->errorLogger->logException($e, "Error al obtener facturas");
           return [
               'code' => 500,
               'body' => ['error' => 'Error al recuperar los datos de facturas']
           ];
       }
   }

   public function getSubscriptions(array $params): array
   {
       try {
           // Lógica similar para obtener suscripciones
           if (isset($params['customer_id'])) {
               $subscriptions = $this->displayService->getCustomerSubscriptions($params['customer_id']);
           } else {
               $subscriptions = $this->displayService->getAllSubscriptions();
           }

           return [
               'code' => 200,
               'body' => [
                   'status' => 'success',
                   'subscriptions' => $subscriptions
               ]
           ];
       } catch (\Exception $e) {
           $this->errorLogger->logException($e, "Error al obtener suscripciones");
           return [
               'code' => 500,
               'body' => ['error' => 'Error al recuperar los datos de suscripciones']
           ];
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Diseño:</strong> Este controlador sigue el principio de responsabilidad única, centrándose exclusivamente en la coordinación de las solicitudes de visualización de datos. Toda la lógica de negocio y acceso a datos se delega al <code>DisplayService</code>, manteniendo el código limpio y modular.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>SubscriptionManagementController</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Gestiona las operaciones relacionadas con la administración de suscripciones, principalmente la cancelación.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Validar parámetros de solicitud para operaciones de gestión de suscripciones.</li>
                            <li>Delegar las operaciones al <code>StripeSubscriptionManagementService</code>.</li>
                            <li>Proporcionar feedback sobre el resultado de las operaciones.</li>
                            <li>Manejar errores específicos de la API de Stripe relacionados con la gestión de suscripciones.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class SubscriptionManagementController
{
   private StripeSubscriptionManagementService $subscriptionService;
   private ErrorLogger $errorLogger;

   public function __construct(
       StripeSubscriptionManagementService $subscriptionService,
       ErrorLogger $errorLogger
   ) {
       $this->subscriptionService = $subscriptionService;
       $this->errorLogger = $errorLogger;
   }

   public function cancelSubscription(array $params): array
   {
       // Validar parámetros necesarios
       if (!isset($params['subscription_id'])) {
           return [
               'code' => 400,
               'body' => ['error' => 'ID de suscripción requerido']
           ];
       }

       $subscriptionId = $params['subscription_id'];
       $cancelAtPeriodEnd = isset($params['cancel_at_period_end'])
           ? (bool)$params['cancel_at_period_end']
           : true;

       try {
           // Intentar cancelar la suscripción
           $result = $this->subscriptionService->cancelSubscription(
               $subscriptionId,
               $cancelAtPeriodEnd
           );

           return [
               'code' => 200,
               'body' => [
                   'status' => 'success',
                   'message' => $cancelAtPeriodEnd
                       ? 'La suscripción se cancelará al final del periodo actual'
                       : 'La suscripción ha sido cancelada inmediatamente',
                   'subscription' => $result
               ]
           ];
       } catch (\Stripe\Exception\ApiErrorException $e) {
           // Manejar errores específicos de la API de Stripe
           $this->errorLogger->logException($e, "Error de API de Stripe al cancelar suscripción");
           return [
               'code' => 400,
               'body' => ['error' => 'Error al cancelar la suscripción: ' . $e->getMessage()]
           ];
       } catch (\Exception $e) {
           // Manejar otros errores inesperados
           $this->errorLogger->logException($e, "Error inesperado al cancelar suscripción");
           return [
               'code' => 500,
               'body' => ['error' => 'Error interno al procesar la solicitud']
           ];
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-lightbulb"></i> <strong>Flexibilidad:</strong> Este controlador proporciona opciones para cancelar suscripciones de forma inmediata o al final del periodo de facturación actual, dando flexibilidad tanto a los usuarios como a los administradores del sistema.
                        </div>
                    </div>
                </div>
            </div>

            <div id="servicios" class="subsection">
                <h4>7.6. Servicios (src/Service/)</h4>
                <p>
                    Los servicios implementan la lógica de negocio principal de la aplicación, coordinando operaciones complejas, interactuando con APIs externas y orquestando el flujo de datos entre diferentes componentes.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>StripeWebhookService</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Orquestar la validación y el procesamiento de los webhooks de Stripe, enrutando cada tipo de evento a la estrategia apropiada.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Verificar la firma criptográfica de los webhooks utilizando el signing secret de Stripe.</li>
                            <li>Analizar el tipo de evento recibido y determinar qué estrategia debe procesarlo.</li>
                            <li>Utilizar el <code>StripeEventStrategyFactory</code> para obtener la estrategia adecuada.</li>
                            <li>Ejecutar la estrategia correspondiente para procesar el evento.</li>
                            <li>Gestionar errores durante el procesamiento y lanzar excepciones apropiadas.</li>
                            <li>Registrar eventos no manejados para análisis futuro.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class StripeWebhookService
{
   private string $webhookSecret;
   private StripeEventStrategyFactory $strategyFactory;
   private UnhandledStripeEventLogger $unhandledEventLogger;
   private StripePayloadLogger $payloadLogger;

   public function __construct(
       string $webhookSecret,
       StripeEventStrategyFactory $strategyFactory,
       UnhandledStripeEventLogger $unhandledEventLogger,
       StripePayloadLogger $payloadLogger
   ) {
       $this->webhookSecret = $webhookSecret;
       $this->strategyFactory = $strategyFactory;
       $this->unhandledEventLogger = $unhandledEventLogger;
       $this->payloadLogger = $payloadLogger;
   }

   /**
    * Construye un objeto Event de Stripe a partir del payload y verifica su firma
    */
   public function constructEvent(string $payload, string $sigHeader): \Stripe\Event
   {
       try {
           return \Stripe\Webhook::constructEvent(
               $payload, $sigHeader, $this->webhookSecret
           );
       } catch (\UnexpectedValueException $e) {
           throw new InvalidWebhookPayloadException(
               "Invalid payload: " . $e->getMessage(), 0, $e
           );
       } catch (\Stripe\Exception\SignatureVerificationException $e) {
           throw $e; // Reenviar esta excepción específica para manejarla en el controlador
       }
   }

   /**
    * Procesa un evento de Stripe utilizando la estrategia apropiada
    */
   public function processEvent(\Stripe\Event $event): bool
   {
       // Registrar el payload (sin datos sensibles)
       $this->payloadLogger->log(json_encode($event), $event->type);

       try {
           // Intentar obtener una estrategia para este tipo de evento
           $strategy = $this->strategyFactory->createStrategy($event->type);

           // Si no hay estrategia disponible, registrar como no manejado y devolver éxito
           if ($strategy === null) {
               $this->unhandledEventLogger->log(
                   "Evento no manejado: {$event->type} - {$event->id}"
               );
               return true;
           }

           // Procesar el evento con la estrategia correspondiente
           return $strategy->process($event);
       } catch (WebhookProcessingException $e) {
           // Reenviar excepciones específicas de procesamiento
           throw $e;
       } catch (\Exception $e) {
           // Convertir otras excepciones en WebhookProcessingException
           throw new WebhookProcessingException(
               "Error al procesar evento {$event->type}: " . $e->getMessage(),
               0, $e
           );
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-cogs"></i> <strong>Diseño:</strong> Este servicio actúa como un coordinador central para el procesamiento de webhooks, siguiendo el principio de alta cohesión y bajo acoplamiento. Utiliza el patrón Factory Method para crear estrategias y el patrón Strategy para delegar el procesamiento específico de cada tipo de evento.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>StripeCheckoutSessionService</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Crear y configurar sesiones de Checkout de Stripe para pagos únicos y suscripciones.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Interactuar con la API de Stripe para crear sesiones de Checkout.</li>
                            <li>Configurar parámetros específicos para diferentes tipos de sesiones (pago único vs. suscripción).</li>
                            <li>Gestionar la información del cliente (email, nombre) y pasarla a Stripe.</li>
                            <li>Configurar URLs de redirección para éxito y cancelación.</li>
                            <li>Manejar errores de la API de Stripe y convertirlos en excepciones amigables.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class StripeCheckoutSessionService
{
   private ErrorLogger $errorLogger;

   public function __construct(ErrorLogger $errorLogger)
   {
       $this->errorLogger = $errorLogger;
   }

   /**
    * Crea una sesión de Checkout para un pago único
    */
   public function createPaymentSession(
       float $amount,
       string $currency,
       string $customerEmail,
       string $customerName,
       string $successUrl,
       string $cancelUrl
   ): \Stripe\Checkout\Session {
       try {
           return \Stripe\Checkout\Session::create([
               'payment_method_types' => ['card'],
               'line_items' => [[
                   'price_data' => [
                       'currency' => $currency,
                       'product_data' => [
                           'name' => 'Producto de pago único',
                       ],
                       'unit_amount' => (int)($amount * 100), // Convertir a centavos
                   ],
                   'quantity' => 1,
               ]],
               'customer_creation' => 'always',
               'customer_email' => $customerEmail,
               'client_reference_id' => $customerName,
               'mode' => 'payment',
               'success_url' => $successUrl,
               'cancel_url' => $cancelUrl,
           ]);
       } catch (\Stripe\Exception\ApiErrorException $e) {
           $this->errorLogger->logException($e, "Error al crear sesión de pago");
           throw new \RuntimeException("Error al crear sesión de pago: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Crea una sesión de Checkout para una suscripción
    */
   public function createSubscriptionSession(
       string $priceId,
       string $customerEmail,
       string $customerName,
       string $successUrl,
       string $cancelUrl
   ): \Stripe\Checkout\Session {
       try {
           return \Stripe\Checkout\Session::create([
               'payment_method_types' => ['card'],
               'line_items' => [[
                   'price' => $priceId,
                   'quantity' => 1,
               ]],
               'customer_creation' => 'always',
               'customer_email' => $customerEmail,
               'client_reference_id' => $customerName,
               'mode' => 'subscription',
               'success_url' => $successUrl,
               'cancel_url' => $cancelUrl,
           ]);
       } catch (\Stripe\Exception\ApiErrorException $e) {
           $this->errorLogger->logException($e, "Error al crear sesión de suscripción");
           throw new \RuntimeException("Error al crear sesión de suscripción: " . $e->getMessage(), 0, $e);
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-shield-alt"></i> <strong>Ventaja:</strong> Stripe Checkout simplifica enormemente el proceso de pago, ya que maneja automáticamente la validación de tarjetas, la autenticación 3D Secure, y ofrece una experiencia de usuario optimizada y consistente. Este servicio aprovecha esas ventajas mientras proporciona una interfaz limpia para el resto de la aplicación.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>StripeSubscriptionManagementService</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Gestionar operaciones relacionadas con suscripciones existentes, como la cancelación o actualización.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Interactuar con la API de Stripe para modificar suscripciones existentes.</li>
                            <li>Proporcionar opciones para cancelar suscripciones inmediatamente o al final del periodo.</li>
                            <li>Actualizar el estado de las suscripciones en la base de datos local para mantener la sincronización.</li>
                            <li>Manejar errores y excepciones específicas de la API de Stripe relacionadas con suscripciones.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class StripeSubscriptionManagementService
{
   private SubscriptionRepository $subscriptionRepository;
   private ErrorLogger $errorLogger;

   public function __construct(
       SubscriptionRepository $subscriptionRepository,
       ErrorLogger $errorLogger
   ) {
       $this->subscriptionRepository = $subscriptionRepository;
       $this->errorLogger = $errorLogger;
   }

   /**
    * Cancela una suscripción, inmediatamente o al final del periodo
    */
   public function cancelSubscription(
       string $subscriptionId,
       bool $cancelAtPeriodEnd = true
   ): array {
       try {
           if ($cancelAtPeriodEnd) {
               // Cancelar al final del periodo actual
               $subscription = \Stripe\Subscription::update($subscriptionId, [
                   'cancel_at_period_end' => true,
               ]);
           } else {
               // Cancelar inmediatamente
               $subscription = \Stripe\Subscription::retrieve($subscriptionId);
               $subscription = $subscription->cancel();
           }

           // Actualizar el estado en la base de datos local
           $this->updateLocalSubscription($subscription);

           return [
               'id' => $subscription->id,
               'status' => $subscription->status,
               'cancel_at_period_end' => $subscription->cancel_at_period_end,
               'current_period_end' => date('Y-m-d H:i:s', $subscription->current_period_end),
               'canceled_at' => $subscription->canceled_at
                   ? date('Y-m-d H:i:s', $subscription->canceled_at)
                   : null,
           ];
       } catch (\Stripe\Exception\ApiErrorException $e) {
           $this->errorLogger->logException($e, "Error al cancelar suscripción en Stripe");
           throw $e; // Reenviar para manejo específico en el controlador
       } catch (\Exception $e) {
           $this->errorLogger->logException($e, "Error inesperado al cancelar suscripción");
           throw new \RuntimeException("Error al cancelar la suscripción", 0, $e);
       }
   }

   /**
    * Actualiza los datos de la suscripción en la base de datos local
    */
   private function updateLocalSubscription(\Stripe\Subscription $subscription): bool
   {
       try {
           $model = new SubscriptionsModel();
           $model->subscription_id = $subscription->id;
           $model->status = $subscription->status;
           $model->cancel_at_period_end = $subscription->cancel_at_period_end;
           $model->canceled_at = $subscription->canceled_at
               ? new \DateTimeImmutable('@' . $subscription->canceled_at)
               : null;
           $model->ended_at = $subscription->ended_at
               ? new \DateTimeImmutable('@' . $subscription->ended_at)
               : null;

           return $this->subscriptionRepository->update($model);
       } catch (\Exception $e) {
           $this->errorLogger->logException($e, "Error al actualizar suscripción en BD local");
           // No relanzar la excepción para no interrumpir el flujo principal
           return false;
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-sync-alt"></i> <strong>Sincronización:</strong> Este servicio cumple un rol crucial en mantener sincronizados los datos entre Stripe y la base de datos local. Cuando se modifica una suscripción a través de este servicio, se actualiza inmediatamente el estado local, sin esperar a que llegue el webhook correspondiente.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>DisplayService</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>Rol principal:</strong> Recuperar y preparar datos de la base de datos para su visualización en la interfaz de usuario.
                        </p>
                        <p><strong>Responsabilidades:</strong></p>
                        <ul>
                            <li>Coordinar la recuperación de datos desde los repositorios.</li>
                            <li>Transformar las entidades del dominio en DTOs adecuados para la presentación.</li>
                            <li>Aplicar filtros, paginación y ordenamiento a los resultados según las necesidades de la UI.</li>
                            <li>Combinar datos de múltiples fuentes cuando sea necesario.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class DisplayService
{
   private TransactionRepository $transactionRepository;
   private SubscriptionRepository $subscriptionRepository;
   private TransactionMapper $transactionMapper;
   private SubscriptionMapper $subscriptionMapper;

   public function __construct(
       TransactionRepository $transactionRepository,
       SubscriptionRepository $subscriptionRepository,
       TransactionMapper $transactionMapper,
       SubscriptionMapper $subscriptionMapper
   ) {
       $this->transactionRepository = $transactionRepository;
       $this->subscriptionRepository = $subscriptionRepository;
       $this->transactionMapper = $transactionMapper;
       $this->subscriptionMapper = $subscriptionMapper;
   }

   /**
    * Obtiene todas las facturas/transacciones con paginación
    */
   public function getAllInvoices(int $page = 1, int $limit = 10): array
   {
       $offset = ($page - 1) * $limit;
       $transactions = $this->transactionRepository->findAll($limit, $offset);

       return array_map(
           fn($model) => $this->transactionMapper->toDto($model),
           $transactions
       );
   }

   /**
    * Obtiene las facturas/transacciones de un cliente específico
    */
   public function getCustomerInvoices(string $customerId): array
   {
       $transactions = $this->transactionRepository->findByCustomerId($customerId);

       return array_map(
           fn($model) => $this->transactionMapper->toDto($model),
           $transactions
       );
   }

   /**
    * Obtiene todas las suscripciones
    */
   public function getAllSubscriptions(): array
   {
       $subscriptions = $this->subscriptionRepository->findAll();

       return array_map(
           fn($model) => $this->subscriptionMapper->toDto($model),
           $subscriptions
       );
   }

   /**
    * Obtiene las suscripciones de un cliente específico
    */
   public function getCustomerSubscriptions(string $customerId): array
   {
       $subscriptions = $this->subscriptionRepository->findByCustomerId($customerId);

       return array_map(
           fn($model) => $this->subscriptionMapper->toDto($model),
           $subscriptions
       );
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-layer-group"></i> <strong>Separación de responsabilidades:</strong> Este servicio proporciona una clara separación entre la capa de acceso a datos (repositorios) y la capa de presentación (controladores). Los datos se transforman mediante mappers para asegurar que solo se expone la información necesaria en el formato adecuado.
                        </div>
                    </div>
                </div>
            </div>

            <div id="estrategias" class="subsection">
                <h4>7.7. Estrategias (src/Strategy/)</h4>
                <p>
                    El patrón Strategy se utiliza extensivamente en StripeLabApp para manejar los diferentes tipos de eventos de webhook de Stripe de forma modular y extensible. Cada estrategia encapsula la lógica específica para procesar un tipo particular de evento.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Patrón Strategy en StripeLabApp</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <strong>¿Por qué usar el patrón Strategy?</strong> Stripe puede enviar más de 100 tipos diferentes de eventos de webhook, cada uno requiriendo un procesamiento específico. El patrón Strategy permite:
                        </p>
                        <ul>
                            <li>Encapsular la lógica de procesamiento de cada tipo de evento en clases separadas.</li>
                            <li>Añadir soporte para nuevos tipos de eventos sin modificar el código existente (principio Open/Closed).</li>
                            <li>Facilitar las pruebas unitarias al aislar la lógica específica de cada tipo de evento.</li>
                            <li>Mantener una estructura de código clara y organizada, evitando funciones monolíticas con múltiples declaraciones switch/case.</li>
                        </ul>

                        <p><strong>Implementación:</strong></p>
                        <div class="code-snippet">
                       <pre><code class="language-php">
/**
* Interfaz común para todas las estrategias de procesamiento de eventos
*/
interface StripeEventStrategyInterface
{
   /**
    * @param \Stripe\Event $event El evento de Stripe a procesar
    * @return bool Éxito o fracaso del procesamiento
    * @throws WebhookProcessingException si ocurre un error durante el procesamiento
    */
   public function process(\Stripe\Event $event): bool;

   /**
    * @return string|array El tipo o tipos de eventos que maneja esta estrategia
    */
   public function getEventType(): string|array;
}
                       </code></pre>
                        </div>

                        <p>
                            <strong>Estrategia por defecto:</strong> Para manejar elegantemente los tipos de eventos para los que no hay una estrategia específica implementada.
                        </p>
                        <div class="code-snippet">
                       <pre><code class="language-php">
/**
* Estrategia por defecto para eventos no manejados específicamente
*/
class DefaultStripeEventStrategy implements StripeEventStrategyInterface
{
   private UnhandledStripeEventLogger $logger;

   public function __construct(UnhandledStripeEventLogger $logger)
   {
       $this->logger = $logger;
   }

   public function process(\Stripe\Event $event): bool
   {
       $this->logger->log("Evento no manejado procesado por la estrategia por defecto: {$event->type} - {$event->id}");
       return true; // Devolver éxito para no reintentar eventos que no necesitamos procesar
   }

   public function getEventType(): string
   {
       return 'default'; // Identificador especial, no corresponde a un tipo real de evento
   }
}
                       </code></pre>
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Detalle de cada Estrategia Implementada</strong>
                    </div>
                    <div class="card-body">
                        <div class="accordion" id="accordionStrategies">
                            <!-- CheckoutSessionCompletedStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingCheckoutSession">
                                    <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseCheckoutSession" aria-expanded="true" aria-controls="collapseCheckoutSession">
                                        CheckoutSessionCompletedStrategy
                                    </button>
                                </h2>
                                <div id="collapseCheckoutSession" class="accordion-collapse collapse show" aria-labelledby="headingCheckoutSession" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>checkout.session.completed</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>TransactionRepository</code>, <code>SubscriptionRepository</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Determina si la sesión de Checkout es para un pago único o una suscripción, basándose en el campo <code>mode</code>.</li>
                                            <li>Para pagos únicos: crea un registro de transacción en la base de datos.</li>
                                            <li>Para suscripciones: registra los metadatos de la sesión para su uso posterior por otras estrategias.</li>
                                            <li>Guarda referencias al cliente, pago o suscripción asociados.</li>
                                        </ul>
                                        <div class="alert alert-info mt-3">
                                            <i class="fas fa-info-circle"></i> <strong>Nota:</strong> Este evento es importante porque confirma que el usuario ha completado el flujo de pago en Stripe Checkout. Sin embargo, para pagos de suscripción, este evento se complementa con <code>invoice.paid</code> y <code>customer.subscription.created</code>, que proporcionan información adicional sobre la transacción.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- PaymentIntentSucceededStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingPaymentIntent">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapsePaymentIntent" aria-expanded="false" aria-controls="collapsePaymentIntent">
                                        PaymentIntentSucceededStrategy
                                    </button>
                                </h2>
                                <div id="collapsePaymentIntent" class="accordion-collapse collapse" aria-labelledby="headingPaymentIntent" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>payment_intent.succeeded</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>TransactionRepository</code>, <code>TransactionFactory</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Procesa eventos de pago exitoso, tanto para pagos únicos como para suscripciones.</li>
                                            <li>Extrae detalles del pago como importe, moneda, cliente, y estado.</li>
                                            <li>Utiliza una heurística para determinar si el PaymentIntent ya ha sido procesado:</li>
                                            <ul>
                                                <li>Verifica si ya existe una transacción con el mismo ID en la base de datos.</li>
                                                <li>Comprueba si el PaymentIntent está asociado a una suscripción, en cuyo caso se deja el procesamiento a <code>InvoicePaidStrategy</code>.</li>
                                            </ul>
                                            <li>Crea un registro de transacción con el tipo adecuado (PAYMENT o SUBSCRIPTION).</li>
                                        </ul>
                                        <div class="alert alert-warning mt-3">
                                            <i class="fas fa-exclamation-triangle"></i> <strong>Desafío:</strong> La correcta gestión de pagos de suscripción requiere evitar duplicaciones, ya que tanto <code>payment_intent.succeeded</code> como <code>invoice.paid</code> pueden referirse a la misma transacción. La estrategia resuelve esto comprobando la vinculación del PaymentIntent con una suscripción y delegando el procesamiento cuando corresponde.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- ChargeSucceededStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingCharge">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseCharge" aria-expanded="false" aria-controls="collapseCharge">
                                        ChargeSucceededStrategy
                                    </button>
                                </h2>
                                <div id="collapseCharge" class="accordion-collapse collapse" aria-labelledby="headingCharge" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>charge.succeeded</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>TransactionRepository</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Enriquece los registros de transacción existentes con información adicional del cargo:</li>
                                            <ul>
                                                <li>URL del recibo (<code>receipt_url</code>)</li>
                                                <li>Detalles del método de pago (últimos 4 dígitos, marca, etc.)</li>
                                                <li>Resultados de validaciones (verificación de CVC, dirección)</li>
                                            </ul>
                                            <li>Actualiza la transacción en la base de datos con estos datos adicionales.</li>
                                        </ul>
                                        <div class="alert alert-info mt-3">
                                            <i class="fas fa-lightbulb"></i> <strong>Diseño:</strong> Esta estrategia se enfoca en enriquecer datos, no en crear nuevos registros. Funciona bajo la premisa de que la transacción ya existe en la base de datos, creada previamente por <code>PaymentIntentSucceededStrategy</code> o <code>InvoicePaidStrategy</code>.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- CustomerCreatedOrUpdatedStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingCustomer">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseCustomer" aria-expanded="false" aria-controls="collapseCustomer">
                                        CustomerCreatedOrUpdatedStrategy
                                    </button>
                                </h2>
                                <div id="collapseCustomer" class="accordion-collapse collapse" aria-labelledby="headingCustomer" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>customer.created</code>, <code>customer.updated</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>CustomerRepository</code> (si se implementara la gestión de clientes)</p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>En la implementación actual, simplemente registra la recepción del evento sin realizar acciones adicionales.</li>
                                            <li>En una implementación más completa, podría:</li>
                                            <ul>
                                                <li>Crear o actualizar un registro de cliente en la base de datos.</li>
                                                <li>Sincronizar información como email, nombre, o dirección de facturación.</li>
                                                <li>Vincular el cliente de Stripe con un usuario de la aplicación.</li>
                                            </ul>
                                        </ul>
                                        <div class="alert alert-secondary mt-3">
                                            <i class="fas fa-info-circle"></i> <strong>Nota:</strong> StripeLabApp simplifica la gestión de clientes, enfocándose principalmente en transacciones y suscripciones. En una aplicación de producción, esta estrategia tendría un rol más importante en mantener sincronizada la información de los clientes.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- SubscriptionCreatedStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingSubscriptionCreated">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSubscriptionCreated" aria-expanded="false" aria-controls="collapseSubscriptionCreated">
                                        SubscriptionCreatedStrategy
                                    </button>
                                </h2>
                                <div id="collapseSubscriptionCreated" class="accordion-collapse collapse" aria-labelledby="headingSubscriptionCreated" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>customer.subscription.created</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>SubscriptionRepository</code>, <code>SubscriptionFactory</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Procesa la creación de nuevas suscripciones, extrayendo información como:</li>
                                            <ul>
                                                <li>ID de suscripción y cliente</li>
                                                <li>Estado de la suscripción</li>
                                                <li>Detalles del plan (ID, nombre, importe, intervalo)</li>
                                                <li>Fechas importantes (inicio, fin del periodo actual, etc.)</li>
                                            </ul>
                                            <li>Crea un nuevo registro de suscripción en la base de datos.</li>
                                        </ul>
                                        <div class="alert alert-info mt-3">
                                            <i class="fas fa-info-circle"></i> <strong>Flujo:</strong> Esta estrategia suele ejecutarse después de <code>checkout.session.completed</code> y antes de <code>invoice.paid</code> cuando un cliente se suscribe a un plan. Registra los detalles de la suscripción que serán utilizados para gestionar el acceso a funcionalidades premium o contenido restringido.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- SubscriptionUpdatedStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingSubscriptionUpdated">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSubscriptionUpdated" aria-expanded="false" aria-controls="collapseSubscriptionUpdated">
                                        SubscriptionUpdatedStrategy
                                    </button>
                                </h2>
                                <div id="collapseSubscriptionUpdated" class="accordion-collapse collapse" aria-labelledby="headingSubscriptionUpdated" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>customer.subscription.updated</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>SubscriptionRepository</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Procesa actualizaciones de suscripciones existentes, detectando cambios como:</li>
                                            <ul>
                                                <li>Cambios de estado (activa, pasada a periodo de prueba, etc.)</li>
                                                <li>Cambios de plan o cantidad</li>
                                                <li>Programación de cancelación (<code>cancel_at_period_end = true</code>)</li>
                                                <li>Actualizaciones de fechas (nuevo periodo de facturación)</li>
                                            </ul>
                                            <li>Actualiza el registro de suscripción en la base de datos.</li>
                                            <li>Presta especial atención a la detección de cancelaciones programadas, para reflejar correctamente que la suscripción terminará al final del periodo actual.</li>
                                        </ul>
                                        <div class="alert alert-warning mt-3">
                                            <i class="fas fa-exclamation-triangle"></i> <strong>Caso especial:</strong> Cuando un usuario solicita cancelar su suscripción al final del periodo actual, Stripe envía un evento <code>customer.subscription.updated</code> con <code>cancel_at_period_end = true</code>, no un evento de cancelación inmediata. Esta estrategia maneja ese escenario específico.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- SubscriptionDeletedStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingSubscriptionDeleted">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSubscriptionDeleted" aria-expanded="false" aria-controls="collapseSubscriptionDeleted">
                                        SubscriptionDeletedStrategy
                                    </button>
                                </h2>
                                <div id="collapseSubscriptionDeleted" class="accordion-collapse collapse" aria-labelledby="headingSubscriptionDeleted" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>customer.subscription.deleted</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>SubscriptionRepository</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Procesa la cancelación definitiva de una suscripción, ya sea:</li>
                                            <ul>
                                                <li>Por cancelación inmediata solicitada por el cliente o administrador.</li>
                                                <li>Por finalización del periodo actual en una suscripción previamente marcada para cancelación.</li>
                                                <li>Por fallo en el pago después de varios intentos de renovación.</li>
                                            </ul>
                                            <li>Actualiza el estado de la suscripción a "canceled" en la base de datos.</li>
                                            <li>Registra las fechas de cancelación y finalización.</li>
                                        </ul>
                                        <div class="alert alert-info mt-3">
                                            <i class="fas fa-info-circle"></i> <strong>Impacto:</strong> El procesamiento correcto de este evento es crucial para actualizar los permisos de acceso del usuario. Cuando se recibe este evento, se debe revocar el acceso a funcionalidades premium o contenido restringido que requería una suscripción activa.
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- InvoicePaidStrategy -->
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingInvoicePaid">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseInvoicePaid" aria-expanded="false" aria-controls="collapseInvoicePaid">
                                        InvoicePaidStrategy
                                    </button>
                                </h2>
                                <div id="collapseInvoicePaid" class="accordion-collapse collapse" aria-labelledby="headingInvoicePaid" data-bs-parent="#accordionStrategies">
                                    <div class="accordion-body">
                                        <p><strong>Eventos manejados:</strong> <code>invoice.paid</code></p>
                                        <p><strong>Dependencias principales:</strong> <code>TransactionRepository</code>, <code>SubscriptionRepository</code>, <code>TransactionFactory</code></p>
                                        <p><strong>Lógica principal:</strong></p>
                                        <ul>
                                            <li>Procesa facturas pagadas, que pueden corresponder a:</li>
                                            <ul>
                                                <li>El pago inicial de una nueva suscripción.</li>
                                                <li>Renovaciones periódicas de suscripciones existentes.</li>
                                            </ul>
                                            <li>Extrae detalles importantes de la factura: importe, cliente, descripción, referencias a la suscripción.</li>
                                            <li>Crea un registro de transacción de tipo SUBSCRIPTION en la base de datos.</li>
                                            <li>Si la factura corresponde a una renovación, actualiza el periodo actual de la suscripción.</li>
                                        </ul>
                                        <div class="alert alert-success mt-3">
                                            <i class="fas fa-check-circle"></i> <strong>Importancia:</strong> Este evento es fundamental para el seguimiento financiero de las suscripciones, ya que confirma cada pago recurrente. También permite mantener un historial completo de todos los pagos realizados por cada suscripción.
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="alert alert-info">
                    <i class="fas fa-cogs"></i> <strong>Arquitectura de Estrategias:</strong>
                    <p>El sistema de estrategias en StripeLabApp utiliza la Factory Method para crear las estrategias adecuadas según el tipo de evento. Esto permite una fácil extensión para soportar nuevos tipos de eventos simplemente añadiendo nuevas clases de estrategia sin modificar el código existente.</p>
                    <p>Cada estrategia se enfoca en una responsabilidad específica, siguiendo el principio de responsabilidad única, lo que facilita el mantenimiento y las pruebas unitarias.</p>
                </div>
            </div>

            <div id="mappers" class="subsection">
                <h4>7.8. Mappers (src/Mappers/)</h4>
                <p>
                    Los Mappers son responsables de transformar entre diferentes representaciones de datos, principalmente de objetos de dominio (Models) a DTOs y viceversa, así como de convertir payloads de eventos de Stripe a estructuras internas.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Rol principal de los Mappers</strong>
                    </div>
                    <div class="card-body">
                        <p>Los Mappers en StripeLabApp cumplen varias funciones clave:</p>
                        <ul>
                            <li><strong>Transformar objetos Stripe</strong> (con estructuras complejas y anidadas) en objetos propios de la aplicación.</li>
                            <li><strong>Convertir Models a DTOs</strong> para presentación en la interfaz de usuario, eliminando campos innecesarios o sensibles.</li>
                            <li><strong>Estandarizar formatos</strong> para fechas, monedas y valores enumerados.</li>
                            <li><strong>Manejar campos opcionales o nulos</strong> de manera segura.</li>
                            <li><strong>Extraer información relevante</strong> de estructuras de datos anidadas.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class SubscriptionMapper
{
   /**
    * Convierte un objeto SubscriptionsModel a SubscriptionDTO
    */
   public function toDto(SubscriptionsModel $model): SubscriptionDTO
   {
       $dto = new SubscriptionDTO();
       $dto->id = $model->transaction_id ?? 0;
       $dto->subscriptionId = $model->subscription_id;
       $dto->customerId = $model->customer_id;
       $dto->status = $model->status;
       $dto->planId = $model->plan_id;
       $dto->planName = $model->plan_name;
       $dto->amount = $model->amount;
       $dto->currency = $model->currency;
       $dto->interval = $model->interval;
       $dto->currentPeriodStart = $model->current_period_start;
       $dto->currentPeriodEnd = $model->current_period_end;
       $dto->canceledAt = $model->canceled_at;
       $dto->cancelAtPeriodEnd = $model->cancel_at_period_end;
       $dto->createdAt = $model->created_at;
       $dto->endedAt = $model->ended_at;

       return $dto;
   }

   /**
    * Extrae información de suscripción de un evento Stripe
    */
   public function fromStripeEvent(\Stripe\Event $event): SubscriptionDTO
   {
       // Asegurarse de que el objeto es una suscripción
       if ($event->data->object->object !== 'subscription') {
           throw new InvalidWebhookPayloadException('Object is not a subscription');
       }

       $subscription = $event->data->object;

       $dto = new SubscriptionDTO();
       $dto->subscriptionId = $subscription->id;
       $dto->customerId = $subscription->customer;
       $dto->status = $subscription->status;

       // Extraer información del plan (puede estar anidada en 'items')
       if (!empty($subscription->plan)) {
           $plan = $subscription->plan;
           $dto->planId = $plan->id;
           $dto->planName = $plan->nickname ?? 'Plan ' . $plan->id;
           $dto->amount = $plan->amount / 100; // Convertir de centavos a unidades
           $dto->currency = $plan->currency;
           $dto->interval = $plan->interval;
       } elseif (!empty($subscription->items->data[0]->plan)) {
           $plan = $subscription->items->data[0]->plan;
           $dto->planId = $plan->id;
           $dto->planName = $plan->nickname ?? 'Plan ' . $plan->id;
           $dto->amount = $plan->amount / 100;
           $dto->currency = $plan->currency;
           $dto->interval = $plan->interval;
       }

       // Convertir timestamps Unix a objetos DateTime
       $dto->currentPeriodStart = new \DateTime('@' . $subscription->current_period_start);
       $dto->currentPeriodEnd = new \DateTime('@' . $subscription->current_period_end);
       $dto->createdAt = new \DateTime('@' . $subscription->created);

       // Manejar campos opcionales
       $dto->canceledAt = $subscription->canceled_at
           ? new \DateTime('@' . $subscription->canceled_at)
           : null;
       $dto->endedAt = $subscription->ended_at
           ? new \DateTime('@' . $subscription->ended_at)
           : null;
       $dto->cancelAtPeriodEnd = $subscription->cancel_at_period_end ?? false;

       return $dto;
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-warning mt-3">
                            <i class="fas fa-exclamation-triangle"></i> <strong>Desafío:</strong> Los payloads de Stripe pueden variar significativamente en estructura según el tipo de evento y la versión de la API. Los Mappers deben ser robustos ante estas variaciones, manejando correctamente campos opcionales y estructuras anidadas.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>TransactionMapper</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <code>TransactionMapper</code> es uno de los mappers más utilizados, ya que maneja las transacciones financieras que son el núcleo de la aplicación. Sus responsabilidades específicas incluyen:
                        </p>
                        <ul>
                            <li>Transformar objetos <code>TransactionsModel</code> a <code>TransactionDTO</code> para presentación.</li>
                            <li>Extraer información relevante de eventos <code>payment_intent.succeeded</code>, <code>charge.succeeded</code> e <code>invoice.paid</code>.</li>
                            <li>Formatear los importes, convirtiendo de centavos (formato de Stripe) a unidades.</li>
                            <li>Extraer detalles del método de pago a partir de estructuras anidadas complejas.</li>
                            <li>Manejar los diferentes tipos de transacción (PAYMENT, SUBSCRIPTION, REFUND).</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class TransactionMapper
{
   /**
    * Extrae información de un PaymentIntent de un evento Stripe
    */
   public function fromPaymentIntent(\Stripe\PaymentIntent $paymentIntent): TransactionDTO
   {
       $dto = new TransactionDTO();
       $dto->transactionId = $paymentIntent->id;
       $dto->customerId = $paymentIntent->customer ?? null;
       $dto->type = $paymentIntent->setup_future_usage === 'off_session'
           ? TransactionTypeEnum::SUBSCRIPTION->value
           : TransactionTypeEnum::PAYMENT->value;
       $dto->amount = $paymentIntent->amount / 100; // Convertir de centavos a unidades
       $dto->currency = $paymentIntent->currency;
       $dto->status = $paymentIntent->status === 'succeeded'
           ? TransactionStatusEnum::COMPLETED->value
           : TransactionStatusEnum::PENDING->value;
       $dto->createdAt = new \DateTime('@' . $paymentIntent->created);
       $dto->description = $paymentIntent->description;

       // Las URLs de recibo generalmente no están disponibles en el PaymentIntent,
       // se completarán posteriormente con el evento charge.succeeded
       $dto->receiptUrl = null;

       return $dto;
   }

   /**
    * Extrae información de un Charge de un evento Stripe
    */
   public function fromCharge(\Stripe\Charge $charge): array
   {
       $paymentMethodDetails = [];

       // Extraer detalles del método de pago
       if (!empty($charge->payment_method_details->card)) {
           $card = $charge->payment_method_details->card;
           $paymentMethodDetails = [
               'type' => 'card',
               'brand' => $card->brand,
               'last4' => $card->last4,
               'exp_month' => $card->exp_month,
               'exp_year' => $card->exp_year,
               'country' => $card->country,
               'checks' => [
                   'cvc_check' => $card->checks->cvc_check ?? null,
                   'address_line1_check' => $card->checks->address_line1_check ?? null,
                   'address_postal_code_check' => $card->checks->address_postal_code_check ?? null,
               ]
           ];
       }

       return [
           'transaction_id' => $charge->payment_intent ?? $charge->id,
           'receipt_url' => $charge->receipt_url,
           'payment_method_details' => json_encode($paymentMethodDetails)
       ];
   }

   /**
    * Convierte un objeto TransactionsModel a TransactionDTO
    */
   public function toDto(TransactionsModel $model): TransactionDTO
   {
       $dto = new TransactionDTO();
       $dto->id = $model->transaction_id;
       $dto->transactionId = $model->stripe_transaction_id;
       $dto->customerId = $model->stripe_customer_id;
       $dto->type = $model->transaction_type;
       $dto->amount = $model->amount;
       $dto->currency = $model->currency;
       $dto->status = $model->status;
       $dto->paymentMethodDetails = $model->payment_method_details;
       $dto->receiptUrl = $model->receipt_url;
       $dto->createdAt = $model->created_at;
       $dto->description = $model->description;

       return $dto;
   }

   // ... otros métodos para diferentes fuentes de datos
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Ventaja:</strong> Al centralizar la lógica de transformación de datos en mappers dedicados, StripeLabApp consigue un código más limpio, más fácil de mantener y probar. Cada Mapper sigue el principio de responsabilidad única, enfocándose únicamente en la transformación de un tipo específico de datos.
                        </div>
                    </div>
                </div>
            </div>

            <div id="factories" class="subsection">
                <h4>7.9. Factories (src/Factories/)</h4>
                <p>
                    Las Factories son responsables de crear instancias de objetos complejos, especialmente entidades de dominio, a partir de DTOs o datos externos como los payloads de Stripe.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Rol principal de las Factories</strong>
                    </div>
                    <div class="card-body">
                        <p>Las Factories en StripeLabApp cumplen varias funciones importantes:</p>
                        <ul>
                            <li><strong>Crear instancias de entidades</strong> (Models) a partir de DTOs o payloads externos.</li>
                            <li><strong>Manejar conversiones complejas</strong> de tipos (timestamps a DateTime, strings a Enums, etc.).</li>
                            <li><strong>Garantizar la integridad de los datos</strong> aplicando validaciones y valores por defecto.</li>
                            <li><strong>Centralizar la lógica de creación</strong> para evitar duplicación en el código.</li>
                            <li><strong>Facilitar las pruebas unitarias</strong> al aislar la lógica de creación.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class TransactionFactory
{
   /**
    * Crea un TransactionsModel a partir de un TransactionDTO
    */
   public function createFromDto(TransactionDTO $dto): TransactionsModel
   {
       $model = new TransactionsModel();

       // Solo asignar transaction_id si ya existe (para actualizaciones)
       if ($dto->id > 0) {
           $model->transaction_id = $dto->id;
       }

       $model->stripe_transaction_id = $dto->transactionId;
       $model->stripe_customer_id = $dto->customerId;

       // Convertir el tipo de string a Enum (si se usa PHP 8.1+)
       $model->transaction_type = $dto->type;

       $model->amount = $dto->amount;
       $model->currency = strtolower($dto->currency);
       $model->status = $dto->status;
       $model->payment_method_details = $dto->paymentMethodDetails;
       $model->receipt_url = $dto->receiptUrl;

       // Convertir DateTime a DateTimeImmutable
       $model->created_at = DateTimeImmutable::createFromMutable($dto->createdAt);

       $model->description = $dto->description;

       return $model;
   }

   /**
    * Crea un TransactionsModel a partir de un PaymentIntent de Stripe
    */
   public function createFromPaymentIntent(\Stripe\PaymentIntent $paymentIntent): TransactionsModel
   {
       $model = new TransactionsModel();
       $model->stripe_transaction_id = $paymentIntent->id;
       $model->stripe_customer_id = $paymentIntent->customer ?? null;

       // Determinar el tipo de transacción basado en metadata o comportamiento
       $model->transaction_type = $paymentIntent->setup_future_usage === 'off_session'
           ? TransactionTypeEnum::SUBSCRIPTION->value
           : TransactionTypeEnum::PAYMENT->value;

       // Convertir de centavos a unidades
       $model->amount = $paymentIntent->amount / 100;
       $model->currency = strtolower($paymentIntent->currency);

       // Determinar el estado
       $model->status = $paymentIntent->status === 'succeeded'
           ? TransactionStatusEnum::COMPLETED->value
           : TransactionStatusEnum::PENDING->value;

       // Las URLs de recibo generalmente no están disponibles en el PaymentIntent
       $model->receipt_url = null;

       // Convertir timestamp a DateTimeImmutable
       $model->created_at = new DateTimeImmutable('@' . $paymentIntent->created);

       $model->description = $paymentIntent->description;

       return $model;
   }

   /**
    * Crea un TransactionsModel a partir de una Invoice de Stripe
    */
   public function createFromInvoice(\Stripe\Invoice $invoice): TransactionsModel
   {
       $model = new TransactionsModel();
       $model->stripe_transaction_id = $invoice->payment_intent ?? $invoice->id;
       $model->stripe_customer_id = $invoice->customer;

       // Las facturas pagadas generalmente corresponden a suscripciones
       $model->transaction_type = TransactionTypeEnum::SUBSCRIPTION->value;

       // Convertir de centavos a unidades
       $model->amount = $invoice->amount_paid / 100;
       $model->currency = strtolower($invoice->currency);

       // Determinar el estado basado en el estado de la factura
       $model->status = $invoice->status === 'paid'
           ? TransactionStatusEnum::COMPLETED->value
           : TransactionStatusEnum::PENDING->value;

       // URLs y detalles adicionales
       $model->receipt_url = null; // Se completará con el evento charge.succeeded
       $model->payment_method_details = null; // Se completará con el evento charge.succeeded

       // Convertir timestamp a DateTimeImmutable
       $model->created_at = new DateTimeImmutable('@' . $invoice->created);

       // Crear una descripción basada en la suscripción
       if ($invoice->subscription) {
           $model->description = "Payment for subscription " . $invoice->subscription;
       } else {
           $model->description = "Invoice payment " . $invoice->number;
       }

       return $model;
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-lightbulb"></i> <strong>Diseño:</strong> Las Factories implementan el patrón Factory Method, proporcionando múltiples métodos para crear el mismo tipo de objeto a partir de diferentes fuentes de datos. Esto hace que el código sea más flexible y adaptable a diferentes escenarios.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>StripeEventStrategyFactory</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <code>StripeEventStrategyFactory</code> es particularmente importante, ya que implementa la creación dinámica de estrategias basada en el tipo de evento recibido. Sus responsabilidades incluyen:
                        </p>
                        <ul>
                            <li>Determinar qué estrategia debe manejar cada tipo de evento de Stripe.</li>
                            <li>Crear y configurar la instancia de estrategia apropiada con sus dependencias.</li>
                            <li>Manejar casos donde no existe una estrategia específica para un tipo de evento.</li>
                            <li>Centralizar la lógica de mapeo entre tipos de eventos y sus estrategias.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class StripeEventStrategyFactory
{
   private TransactionRepository $transactionRepository;
   private SubscriptionRepository $subscriptionRepository;
   private TransactionFactory $transactionFactory;
   private SubscriptionFactory $subscriptionFactory;
   private TransactionMapper $transactionMapper;
   private SubscriptionMapper $subscriptionMapper;
   private EventLogger $eventLogger;
   private ErrorLogger $errorLogger;
   private UnhandledStripeEventLogger $unhandledEventLogger;

   public function __construct(
       TransactionRepository $transactionRepository,
       SubscriptionRepository $subscriptionRepository,
       TransactionFactory $transactionFactory,
       SubscriptionFactory $subscriptionFactory,
       TransactionMapper $transactionMapper,
       SubscriptionMapper $subscriptionMapper,
       EventLogger $eventLogger,
       ErrorLogger $errorLogger,
       UnhandledStripeEventLogger $unhandledEventLogger
   ) {
       $this->transactionRepository = $transactionRepository;
       $this->subscriptionRepository = $subscriptionRepository;
       $this->transactionFactory = $transactionFactory;
       $this->subscriptionFactory = $subscriptionFactory;
       $this->transactionMapper = $transactionMapper;
       $this->subscriptionMapper = $subscriptionMapper;
       $this->eventLogger = $eventLogger;
       $this->errorLogger = $errorLogger;
       $this->unhandledEventLogger = $unhandledEventLogger;
   }

   /**
    * Crea la estrategia adecuada para el tipo de evento dado
    */
   public function createStrategy(string $eventType): ?StripeEventStrategyInterface
   {
       // Normalizar el tipo de evento para usar Enum
       $eventType = strtolower($eventType);

       // Mapeo de tipos de eventos a clases de estrategia
       $strategyMap = [
           StripeEventTypeEnum::CHECKOUT_SESSION_COMPLETED->value => CheckoutSessionCompletedStrategy::class,
           StripeEventTypeEnum::PAYMENT_INTENT_SUCCEEDED->value => PaymentIntentSucceededStrategy::class,
           StripeEventTypeEnum::CHARGE_SUCCEEDED->value => ChargeSucceededStrategy::class,
           StripeEventTypeEnum::CUSTOMER_CREATED->value => CustomerCreatedOrUpdatedStrategy::class,
           StripeEventTypeEnum::CUSTOMER_UPDATED->value => CustomerCreatedOrUpdatedStrategy::class,
           StripeEventTypeEnum::CUSTOMER_SUBSCRIPTION_CREATED->value => SubscriptionCreatedStrategy::class,
           StripeEventTypeEnum::CUSTOMER_SUBSCRIPTION_UPDATED->value => SubscriptionUpdatedStrategy::class,
           StripeEventTypeEnum::CUSTOMER_SUBSCRIPTION_DELETED->value => SubscriptionDeletedStrategy::class,
           StripeEventTypeEnum::INVOICE_PAID->value => InvoicePaidStrategy::class,
       ];

       // Si no hay una estrategia específica para este tipo de evento, devolver null
       if (!isset($strategyMap[$eventType])) {
           return null;
       }

       // Crear la estrategia basada en el tipo de evento
       $strategyClass = $strategyMap[$eventType];

       // Configurar las dependencias específicas para cada tipo de estrategia
       switch ($strategyClass) {
           case CheckoutSessionCompletedStrategy::class:
               return new CheckoutSessionCompletedStrategy(
                   $this->transactionRepository,
                   $this->transactionFactory,
                   $this->eventLogger,
                   $this->errorLogger
               );

           case PaymentIntentSucceededStrategy::class:
               return new PaymentIntentSucceededStrategy(
                   $this->transactionRepository,
                   $this->transactionFactory,
                   $this->transactionMapper,
                   $this->eventLogger,
                   $this->errorLogger
               );

           case ChargeSucceededStrategy::class:
               return new ChargeSucceededStrategy(
                   $this->transactionRepository,
                   $this->transactionMapper,
                   $this->eventLogger,
                   $this->errorLogger
               );

           case SubscriptionCreatedStrategy::class:
               return new SubscriptionCreatedStrategy(
                   $this->subscriptionRepository,
                   $this->subscriptionFactory,
                   $this->subscriptionMapper,
                   $this->eventLogger,
                   $this->errorLogger
               );

           // ... casos similares para otras estrategias

           default:
               return null;
       }
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Flexibilidad:</strong> Esta implementación permite añadir soporte para nuevos tipos de eventos simplemente actualizando el mapeo en <code>$strategyMap</code> y creando la nueva clase de estrategia correspondiente, sin necesidad de modificar el código existente (principio Open/Closed).
                        </div>
                    </div>
                </div>
            </div>

            <div id="repositories" class="subsection">
                <h4>7.10. Repositories (src/Repository/)</h4>
                <p>
                    Los Repositories en StripeLabApp abstraen la capa de persistencia, proporcionando una interfaz orientada a objetos para realizar operaciones CRUD y consultas específicas sobre las entidades del dominio.
                </p>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>Rol principal de los Repositories</strong>
                    </div>
                    <div class="card-body">
                        <p>Los Repositories cumplen varias funciones esenciales:</p>
                        <ul>
                            <li><strong>Abstraer la tecnología de base de datos</strong> subyacente (MySQL, en este caso).</li>
                            <li><strong>Implementar operaciones CRUD</strong> básicas (Create, Read, Update, Delete) para cada entidad.</li>
                            <li><strong>Proporcionar métodos de búsqueda especializados</strong> basados en criterios específicos del dominio.</li>
                            <li><strong>Gestionar transacciones</strong> y garantizar la integridad de los datos.</li>
                            <li><strong>Centralizar la lógica de acceso a datos</strong> y prevenir la duplicación de consultas SQL.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class TransactionRepository
{
   private \PDO $pdo;
   private DatabaseLogger $logger;

   public function __construct(\PDO $pdo, DatabaseLogger $logger)
   {
       $this->pdo = $pdo;
       $this->logger = $logger;
   }

   /**
    * Guarda una nueva transacción en la base de datos
    */
   public function save(TransactionsModel $transaction): bool
   {
       try {
           $sql = "INSERT INTO transactions (
                       stripe_transaction_id, stripe_customer_id, transaction_type,
                       amount, currency, status, payment_method_details,
                       receipt_url, created_at, description
                   ) VALUES (
                       :stripe_transaction_id, :stripe_customer_id, :transaction_type,
                       :amount, :currency, :status, :payment_method_details,
                       :receipt_url, :created_at, :description
                   )";

           $stmt = $this->pdo->prepare($sql);

           $createdAt = $transaction->created_at->format('Y-m-d H:i:s');

           $params = [
               ':stripe_transaction_id' => $transaction->stripe_transaction_id,
               ':stripe_customer_id' => $transaction->stripe_customer_id,
               ':transaction_type' => $transaction->transaction_type,
               ':amount' => $transaction->amount,
               ':currency' => $transaction->currency,
               ':status' => $transaction->status,
               ':payment_method_details' => $transaction->payment_method_details,
               ':receipt_url' => $transaction->receipt_url,
               ':created_at' => $createdAt,
               ':description' => $transaction->description,
           ];

           $result = $stmt->execute($params);

           if ($result) {
               // Asignar el ID generado automáticamente
               $transaction->transaction_id = (int)$this->pdo->lastInsertId();
               $this->logger->log("Transacción guardada: {$transaction->stripe_transaction_id} (ID: {$transaction->transaction_id})");
           }

           return $result;
       } catch (\PDOException $e) {
           $this->logger->log("Error al guardar transacción: " . $e->getMessage());
           throw new DatabaseException("Error al guardar transacción: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Actualiza una transacción existente
    */
   public function update(TransactionsModel $transaction): bool
   {
       try {
           $sql = "UPDATE transactions SET
                       stripe_customer_id = :stripe_customer_id,
                       transaction_type = :transaction_type,
                       amount = :amount,
                       currency = :currency,
                       status = :status,
                       payment_method_details = :payment_method_details,
                       receipt_url = :receipt_url,
                       description = :description
                   WHERE stripe_transaction_id = :stripe_transaction_id";

           $stmt = $this->pdo->prepare($sql);

           $params = [
               ':stripe_transaction_id' => $transaction->stripe_transaction_id,
               ':stripe_customer_id' => $transaction->stripe_customer_id,
               ':transaction_type' => $transaction->transaction_type,
               ':amount' => $transaction->amount,
               ':currency' => $transaction->currency,
               ':status' => $transaction->status,
               ':payment_method_details' => $transaction->payment_method_details,
               ':receipt_url' => $transaction->receipt_url,
               ':description' => $transaction->description
           ];

           $result = $stmt->execute($params);

           if ($result) {
               $this->logger->log("Transacción actualizada: {$transaction->stripe_transaction_id}");
           }

           return $result;
       } catch (\PDOException $e) {
           $this->logger->log("Error al actualizar transacción: " . $e->getMessage());
           throw new DatabaseException("Error al actualizar transacción: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Busca una transacción por su ID de Stripe
    */
   public function findByStripeId(string $stripeId): ?TransactionsModel
   {
       try {
           $sql = "SELECT * FROM transactions WHERE stripe_transaction_id = :stripe_id";
           $stmt = $this->pdo->prepare($sql);
           $stmt->execute([':stripe_id' => $stripeId]);

           $data = $stmt->fetch(\PDO::FETCH_ASSOC);

           if (!$data) {
               return null;
           }

           return $this->createModelFromData($data);
       } catch (\PDOException $e) {
           $this->logger->log("Error al buscar transacción: " . $e->getMessage());
           throw new DatabaseException("Error al buscar transacción: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Busca transacciones por ID de cliente
    */
   public function findByCustomerId(string $customerId): array
   {
       try {
           $sql = "SELECT * FROM transactions WHERE stripe_customer_id = :customer_id ORDER BY created_at DESC";
           $stmt = $this->pdo->prepare($sql);
           $stmt->execute([':customer_id' => $customerId]);

           $transactions = [];
           while ($data = $stmt->fetch(\PDO::FETCH_ASSOC)) {
               $transactions[] = $this->createModelFromData($data);
           }

           return $transactions;
       } catch (\PDOException $e) {
           $this->logger->log("Error al buscar transacciones por cliente: " . $e->getMessage());
           throw new DatabaseException("Error al buscar transacciones por cliente: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Obtiene todas las transacciones con paginación
    */
   public function findAll(int $limit = 10, int $offset = 0): array
   {
       try {
           $sql = "SELECT * FROM transactions ORDER BY created_at DESC LIMIT :limit OFFSET :offset";
           $stmt = $this->pdo->prepare($sql);
           $stmt->bindValue(':limit', $limit, \PDO::PARAM_INT);
           $stmt->bindValue(':offset', $offset, \PDO::PARAM_INT);
           $stmt->execute();

           $transactions = [];
           while ($data = $stmt->fetch(\PDO::FETCH_ASSOC)) {
               $transactions[] = $this->createModelFromData($data);
           }

           return $transactions;
       } catch (\PDOException $e) {
           $this->logger->log("Error al obtener transacciones: " . $e->getMessage());
           throw new DatabaseException("Error al obtener transacciones: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Crea un modelo a partir de datos de la base de datos
    */
   private function createModelFromData(array $data): TransactionsModel
   {
       $model = new TransactionsModel();
       $model->transaction_id = (int)$data['transaction_id'];
       $model->stripe_transaction_id = $data['stripe_transaction_id'];
       $model->stripe_customer_id = $data['stripe_customer_id'];
       $model->transaction_type = $data['transaction_type'];
       $model->amount = (float)$data['amount'];
       $model->currency = $data['currency'];
       $model->status = $data['status'];
       $model->payment_method_details = $data['payment_method_details'];
       $model->receipt_url = $data['receipt_url'];
       $model->created_at = new \DateTimeImmutable($data['created_at']);
       $model->description = $data['description'];

       return $model;
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-info mt-3">
                            <i class="fas fa-database"></i> <strong>Manejo de IDs:</strong> Observe que <code>TransactionRepository</code> maneja un ID autoincremental (<code>transaction_id</code>) que se asigna automáticamente al guardar, mientras que <code>SubscriptionRepository</code> utiliza el ID de Stripe como clave primaria natural. Esto refleja la naturaleza diferente de estas entidades: las transacciones son registros internos que pueden existir sin un ID de Stripe (por ejemplo, para pagos manuales), mientras que las suscripciones siempre están vinculadas a una suscripción específica en Stripe.
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <strong>SubscriptionRepository</strong>
                    </div>
                    <div class="card-body">
                        <p>
                            <code>SubscriptionRepository</code> gestiona la persistencia de suscripciones, que tienen consideraciones específicas diferentes a las transacciones:
                        </p>
                        <ul>
                            <li><strong>Clave primaria natural:</strong> Utiliza el ID de Stripe (<code>subscription_id</code>) como clave primaria en lugar de un autoincremental.</li>
                            <li><strong>Actualizaciones frecuentes:</strong> Las suscripciones se actualizan regularmente (cambios de estado, renovaciones, etc.).</li>
                            <li><strong>Fechas críticas:</strong> Gestiona múltiples fechas importantes (creación, inicio de periodo, fin de periodo, cancelación).</li>
                            <li><strong>Estados específicos:</strong> Incluye campos para estados especiales como <code>cancel_at_period_end</code>.</li>
                        </ul>

                        <div class="code-snippet">
                       <pre><code class="language-php">
class SubscriptionRepository
{
   private \PDO $pdo;
   private DatabaseLogger $logger;

   public function __construct(\PDO $pdo, DatabaseLogger $logger)
   {
       $this->pdo = $pdo;
       $this->logger = $logger;
   }

   /**
    * Guarda una nueva suscripción
    */
   public function save(SubscriptionsModel $subscription): bool
   {
       try {
           $sql = "INSERT INTO subscriptions (
                       subscription_id, customer_id, status, plan_id, plan_name,
                       amount, currency, `interval`, current_period_start,
                       current_period_end, canceled_at, cancel_at_period_end,
                       created_at, ended_at
                   ) VALUES (
                       :subscription_id, :customer_id, :status, :plan_id, :plan_name,
                       :amount, :currency, :interval, :current_period_start,
                       :current_period_end, :canceled_at, :cancel_at_period_end,
                       :created_at, :ended_at
                   )";

           $stmt = $this->pdo->prepare($sql);

           $currentPeriodStart = $subscription->current_period_start->format('Y-m-d H:i:s');
           $currentPeriodEnd = $subscription->current_period_end->format('Y-m-d H:i:s');
           $createdAt = $subscription->created_at->format('Y-m-d H:i:s');
           $canceledAt = $subscription->canceled_at ? $subscription->canceled_at->format('Y-m-d H:i:s') : null;
           $endedAt = $subscription->ended_at ? $subscription->ended_at->format('Y-m-d H:i:s') : null;

           $params = [
               ':subscription_id' => $subscription->subscription_id,
               ':customer_id' => $subscription->customer_id,
               ':status' => $subscription->status,
               ':plan_id' => $subscription->plan_id,
               ':plan_name' => $subscription->plan_name,
               ':amount' => $subscription->amount,
               ':currency' => $subscription->currency,
               ':interval' => $subscription->interval,
               ':current_period_start' => $currentPeriodStart,
               ':current_period_end' => $currentPeriodEnd,
               ':canceled_at' => $canceledAt,
               ':cancel_at_period_end' => $subscription->cancel_at_period_end ? 1 : 0,
               ':created_at' => $createdAt,
               ':ended_at' => $endedAt
           ];

           $result = $stmt->execute($params);

           if ($result) {
               $this->logger->log("Suscripción guardada: {$subscription->subscription_id}");
           }

           return $result;
       } catch (\PDOException $e) {
           // Manejar el caso específico de duplicado (la suscripción ya existe)
           if ($e->getCode() == '23000') {
               // Actualizar en lugar de insertar si ya existe
               return $this->update($subscription);
           }

           $this->logger->log("Error al guardar suscripción: " . $e->getMessage());
           throw new DatabaseException("Error al guardar suscripción: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Actualiza una suscripción existente
    */
   public function update(SubscriptionsModel $subscription): bool
   {
       try {
           $sql = "UPDATE subscriptions SET
                       customer_id = :customer_id,
                       status = :status,
                       plan_id = :plan_id,
                       plan_name = :plan_name,
                       amount = :amount,
                       currency = :currency,
                       `interval` = :interval,
                       current_period_start = :current_period_start,
                       current_period_end = :current_period_end,
                       canceled_at = :canceled_at,
                       cancel_at_period_end = :cancel_at_period_end,
                       ended_at = :ended_at
                   WHERE subscription_id = :subscription_id";

           $stmt = $this->pdo->prepare($sql);

           $currentPeriodStart = $subscription->current_period_start->format('Y-m-d H:i:s');
           $currentPeriodEnd = $subscription->current_period_end->format('Y-m-d H:i:s');
           $canceledAt = $subscription->canceled_at ? $subscription->canceled_at->format('Y-m-d H:i:s') : null;
           $endedAt = $subscription->ended_at ? $subscription->ended_at->format('Y-m-d H:i:s') : null;

           $params = [
               ':subscription_id' => $subscription->subscription_id,
               ':customer_id' => $subscription->customer_id,
               ':status' => $subscription->status,
               ':plan_id' => $subscription->plan_id,
               ':plan_name' => $subscription->plan_name,
               ':amount' => $subscription->amount,
               ':currency' => $subscription->currency,
               ':interval' => $subscription->interval,
               ':current_period_start' => $currentPeriodStart,
               ':current_period_end' => $currentPeriodEnd,
               ':canceled_at' => $canceledAt,
               ':cancel_at_period_end' => $subscription->cancel_at_period_end ? 1 : 0,
               ':ended_at' => $endedAt
           ];

           $result = $stmt->execute($params);

           if ($result) {
               $this->logger->log("Suscripción actualizada: {$subscription->subscription_id}");
           }

           return $result;
       } catch (\PDOException $e) {
           $this->logger->log("Error al actualizar suscripción: " . $e->getMessage());
           throw new DatabaseException("Error al actualizar suscripción: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Busca una suscripción por su ID
    */
   public function findById(string $subscriptionId): ?SubscriptionsModel
   {
       try {
           $sql = "SELECT * FROM subscriptions WHERE subscription_id = :subscription_id";
           $stmt = $this->pdo->prepare($sql);
           $stmt->execute([':subscription_id' => $subscriptionId]);

           $data = $stmt->fetch(\PDO::FETCH_ASSOC);

           if (!$data) {
               return null;
           }

           return $this->createModelFromData($data);
       } catch (\PDOException $e) {
           $this->logger->log("Error al buscar suscripción: " . $e->getMessage());
           throw new DatabaseException("Error al buscar suscripción: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Busca suscripciones por ID de cliente
    */
   public function findByCustomerId(string $customerId): array
   {
       try {
           $sql = "SELECT * FROM subscriptions WHERE customer_id = :customer_id ORDER BY created_at DESC";
           $stmt = $this->pdo->prepare($sql);
           $stmt->execute([':customer_id' => $customerId]);

           $subscriptions = [];
           while ($data = $stmt->fetch(\PDO::FETCH_ASSOC)) {
               $subscriptions[] = $this->createModelFromData($data);
           }

           return $subscriptions;
       } catch (\PDOException $e) {
           $this->logger->log("Error al buscar suscripciones por cliente: " . $e->getMessage());
           throw new DatabaseException("Error al buscar suscripciones por cliente: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Obtiene todas las suscripciones
    */
   public function findAll(): array
   {
       try {
           $sql = "SELECT * FROM subscriptions ORDER BY created_at DESC";
           $stmt = $this->pdo->prepare($sql);
           $stmt->execute();

           $subscriptions = [];
           while ($data = $stmt->fetch(\PDO::FETCH_ASSOC)) {
               $subscriptions[] = $this->createModelFromData($data);
           }

           return $subscriptions;
       } catch (\PDOException $e) {
           $this->logger->log("Error al obtener suscripciones: " . $e->getMessage());
           throw new DatabaseException("Error al obtener suscripciones: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Busca suscripciones activas
    */
   public function findActiveSubscriptions(): array
   {
       try {
           $sql = "SELECT * FROM subscriptions WHERE status = 'active' ORDER BY created_at DESC";
           $stmt = $this->pdo->prepare($sql);
           $stmt->execute();

           $subscriptions = [];
           while ($data = $stmt->fetch(\PDO::FETCH_ASSOC)) {
               $subscriptions[] = $this->createModelFromData($data);
           }

           return $subscriptions;
       } catch (\PDOException $e) {
           $this->logger->log("Error al obtener suscripciones activas: " . $e->getMessage());
           throw new DatabaseException("Error al obtener suscripciones activas: " . $e->getMessage(), 0, $e);
       }
   }

   /**
    * Crea un modelo a partir de datos de la base de datos
    */
   private function createModelFromData(array $data): SubscriptionsModel
   {
       $model = new SubscriptionsModel();
       $model->subscription_id = $data['subscription_id'];
       $model->customer_id = $data['customer_id'];
       $model->status = $data['status'];
       $model->plan_id = $data['plan_id'];
       $model->plan_name = $data['plan_name'];
       $model->amount = (float)$data['amount'];
       $model->currency = $data['currency'];
       $model->interval = $data['interval'];
       $model->current_period_start = new \DateTimeImmutable($data['current_period_start']);
       $model->current_period_end = new \DateTimeImmutable($data['current_period_end']);
       $model->canceled_at = $data['canceled_at'] ? new \DateTimeImmutable($data['canceled_at']) : null;
       $model->cancel_at_period_end = (bool)$data['cancel_at_period_end'];
       $model->created_at = new \DateTimeImmutable($data['created_at']);
       $model->ended_at = $data['ended_at'] ? new \DateTimeImmutable($data['ended_at']) : null;

       return $model;
   }
}
                       </code></pre>
                        </div>

                        <div class="alert alert-success mt-3">
                            <i class="fas fa-check-circle"></i> <strong>Diseño robusto:</strong> Los repositorios en StripeLabApp proporcionan una abstracción completa sobre la capa de persistencia, haciendo que el resto de la aplicación no necesite conocer los detalles de cómo se almacenan los datos. Esto facilita cambios en la implementación de almacenamiento sin afectar al resto del código.
                        </div>
                    </div>
                </div>
            </div>
        </section>